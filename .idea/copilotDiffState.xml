<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/MatchRule.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/MatchRule.ts" />
              <option name="originalContent" value="/**&#10; * Represents a match rule that can be applied to database records&#10; */&#10;export interface MatchRule&lt;T = any&gt; {&#10;&#10;    /**&#10;     * Optional priority of the rule.&#10;     * Rules with lower priority numbers will be applied first.&#10;     * If not specified, the default priority is 0.&#10;     */&#10;    readonly priority?: number;&#10;&#10;    /**&#10;     * Name of the rule, used for identification and logging.&#10;     * Rule name can be added to &quot;appliedRules&quot; field in the database to track which rules were applied.&#10;     */&#10;    readonly ruleName: string;&#10;&#10;    /**&#10;     * Conditions to match records against.&#10;     * Values will be matched as regex patterns if they are strings&#10;     * and direct equality for other types.&#10;     * For example, { &quot;category&quot;: &quot;Groceries|Food&quot; } will match records where category is either &quot;Groceries&quot; or &quot;Food&quot;.&#10;     */&#10;    readonly match: Partial&lt;T&gt;;&#10;&#10;    /**&#10;     * Changes to apply to matched records.&#10;     * This object will be used in the SET clause of the SQL UPDATE statement.&#10;     */&#10;    readonly apply: Partial&lt;T&gt;;&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Represents a match rule that can be applied to database records&#10; */&#10;export interface MatchRule&lt;T = any&gt; {&#10;&#10;    /**&#10;     * Priority of the rule.&#10;     * Rules with lower priority numbers will be applied first.&#10;     * If not specified, the default priority is 0.&#10;     */&#10;    readonly priority: number;&#10;&#10;    /**&#10;     * Name of the rule, used for identification and logging.&#10;     * Rule name can be added to &quot;appliedRules&quot; field in the database to track which rules were applied.&#10;     */&#10;    readonly ruleName: string;&#10;&#10;    /**&#10;     * Conditions to match records against.&#10;     * Values will be matched as regex patterns if they are strings&#10;     * and direct equality for other types.&#10;     * For example, { &quot;category&quot;: &quot;Groceries|Food&quot; } will match records where category is either &quot;Groceries&quot; or &quot;Food&quot;.&#10;     */&#10;    readonly match: Partial&lt;T&gt;;&#10;&#10;    /**&#10;     * Changes to apply to matched records.&#10;     * This object will be used in the SET clause of the SQL UPDATE statement.&#10;     */&#10;    readonly apply: Partial&lt;T&gt;;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/MatchRuleFactory.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/MatchRuleFactory.ts" />
              <option name="originalContent" value="import {MatchRule} from &quot;@/MatchRule&quot;;&#10;&#10;export class MatchRuleFactory {&#10;    /**&#10;     * Creates a MatchRule instance from a rule object&#10;     * @returns A new MatchRule instance&#10;     * @param json&#10;     */&#10;    static create&lt;T&gt;(json: any): MatchRule&lt;T&gt; {&#10;        if (!json || typeof json !== 'object') {&#10;            throw new Error('Invalid rule object provided');&#10;        }&#10;        &#10;        return MatchRuleFactory.createRule&lt;T&gt;(&#10;            json.ruleName,&#10;            json.match || {},&#10;            json.apply || {},&#10;            json.priority || 0&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Creates a MatchRule instance with direct parameters&#10;     * @param ruleName The name of the rule&#10;     * @param match The conditions to match&#10;     * @param apply The changes to apply&#10;     * @returns A new MatchRule instance&#10;     */&#10;    static createRule&lt;T&gt;(ruleName: string, match: Partial&lt;T&gt;, apply: Partial&lt;T&gt;, priority: number): MatchRule&lt;T&gt; {&#10;        if (!ruleName || typeof ruleName !== 'string' || ruleName.trim() === '') {&#10;            throw new Error('Rule name must be a non-empty string');&#10;        }&#10;&#10;        return {&#10;            priority: (priority &amp;&amp; priority &gt; 0) ? priority : 0,&#10;            ruleName: ruleName.trim(),&#10;            match : (match &amp;&amp; typeof match === 'object') ? match : {},&#10;            apply : (apply &amp;&amp; typeof apply === 'object') ? apply : {}&#10;        };&#10;    }&#10;}" />
              <option name="updatedContent" value="import {MatchRule} from &quot;@/MatchRule&quot;;&#10;&#10;export class MatchRuleFactory {&#10;    /**&#10;     * Creates a MatchRule instance from a rule object&#10;     * @returns A new MatchRule instance&#10;     * @param json&#10;     */&#10;    static create&lt;T&gt;(json: any): MatchRule&lt;T&gt; {&#10;        if (!json || typeof json !== 'object') {&#10;            throw new Error('Invalid rule object provided');&#10;        }&#10;        return MatchRuleFactory.createRule&lt;T&gt;(&#10;            json.ruleName,&#10;            json.match || {},&#10;            json.apply || {},&#10;            json.priority&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Creates a MatchRule instance with direct parameters&#10;     * @param ruleName The name of the rule&#10;     * @param match The conditions to match&#10;     * @param apply The changes to apply&#10;     * @returns A new MatchRule instance&#10;     */&#10;    static createRule&lt;T&gt;(ruleName: string, match: Partial&lt;T&gt;, apply: Partial&lt;T&gt;, priority?: number): MatchRule&lt;T&gt; {&#10;        if (!ruleName || typeof ruleName !== 'string' || ruleName.trim() === '') {&#10;            throw new Error('Rule name must be a non-empty string');&#10;        }&#10;        return {&#10;            priority: typeof priority === 'number' ? priority : 0,&#10;            ruleName: ruleName.trim(),&#10;            match : (match &amp;&amp; typeof match === 'object') ? match : {},&#10;            apply : (apply &amp;&amp; typeof apply === 'object') ? apply : {}&#10;        };&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/PgRulesEngine.test.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/PgRulesEngine.test.ts" />
              <option name="originalContent" value="import {createTestDatabase} from './test-database';&#10;import {PgRulesEngine} from './PgRulesEngine';&#10;import {User} from './database.types';&#10;import {MatchRuleFactory} from &quot;./MatchRuleFactory&quot;;&#10;&#10;describe('PgRulesEngine', () =&gt; {&#10;    let db: any;&#10;    let rulesEngine: PgRulesEngine;&#10;&#10;    beforeEach(async () =&gt; {&#10;        db = createTestDatabase();&#10;        rulesEngine = new PgRulesEngine(db);&#10;&#10;        // Insert test users&#10;        await db&#10;            .insertInto('users')&#10;            .values([&#10;                {email: 'john@example.com', name: 'John Doe'},&#10;                {email: 'jane@example.com', name: 'Jane Smith'},&#10;                {email: 'bob@example.com', name: 'Bob Johnson'},&#10;                {email: 'alice@example.com', name: 'Alice Brown'},&#10;            ])&#10;            .execute();&#10;    });&#10;&#10;    describe('applyRules', () =&gt; {&#10;        it('should apply a single rule to update user names', async () =&gt; {&#10;            // Create a rule to update John's name&#10;            const rule = MatchRuleFactory.createRule({&#10;                ruleName: 'update-john-name',&#10;                match: {email: 'john@example.com'},&#10;                apply: {name: 'John Updated'}&#10;            });&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(1);&#10;&#10;            // Verify the update was applied&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'john@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(updatedUser.name).toBe('John Updated');&#10;        });&#10;&#10;        it('should apply multiple rules in a single transaction', async () =&gt; {&#10;            const rules = [&#10;                MatchRuleFactory.createRule({&#10;                    ruleName: 'update-john',&#10;                    match: {email: 'john@example.com'},&#10;                    apply: {name: 'John Modified'}&#10;                }),&#10;                MatchRuleFactory.createRule({&#10;                    ruleName: 'update-jane',&#10;                    match: {email: 'jane@example.com'},&#10;                    apply: {name: 'Jane Modified'}&#10;                }),&#10;            ];&#10;&#10;            const affectedRows = await rulesEngine.applyRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(2);&#10;&#10;            // Verify both updates were applied&#10;            const users = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', 'in', ['john@example.com', 'jane@example.com'])&#10;                .execute();&#10;&#10;            expect(users).toHaveLength(2);&#10;            expect(users.find((u: User) =&gt; u.email === 'john@example.com')?.name).toBe('John Modified');&#10;            expect(users.find((u: User) =&gt; u.email === 'jane@example.com')?.name).toBe('Jane Modified');&#10;        });&#10;&#10;        it('should handle rules with multiple match conditions', async () =&gt; {&#10;            // First, update one user to have a specific name&#10;            await db&#10;                .updateTable('users')&#10;                .set({name: 'Target User'})&#10;                .where('email', '=', 'bob@example.com')&#10;                .execute();&#10;&#10;            const rule = MatchRuleFactory.createRule({&#10;                ruleName: 'update-specific-user',&#10;                match: {email: 'bob@example.com', name: 'Target User'},&#10;                apply: {name: 'Updated Target User'}&#10;            });&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(1);&#10;&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'bob@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(updatedUser.name).toBe('Updated Target User');&#10;        });&#10;&#10;        it('should return 0 when no rules match any records', async () =&gt; {&#10;            const rule = MatchRuleFactory.createRule({&#10;                ruleName: 'update-nonexistent',&#10;                match: {email: 'nonexistent@example.com'},&#10;                apply: {name: 'Should Not Update'}&#10;            });&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(0);&#10;&#10;            // Verify no users were changed&#10;            const allUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .execute();&#10;&#10;            expect(allUsers).toHaveLength(4);&#10;            // @ts-ignore&#10;            expect(allUsers.every((u: User) =&gt; !u.name.includes('Should Not Update'))).toBe(true);&#10;        });&#10;&#10;        it('should return 0 when given an empty rules array', async () =&gt; {&#10;            const affectedRows = await rulesEngine.applyRules([], 'users');&#10;&#10;            expect(affectedRows).toBe(0);&#10;        });&#10;&#10;        it('should skip rules with empty apply objects', async () =&gt; {&#10;            const rules = [&#10;                MatchRuleFactory.createRule({&#10;                    ruleName: 'empty-apply',&#10;                    match: {email: 'john@example.com'},&#10;                    apply: {}&#10;                }),&#10;                MatchRuleFactory.createRule({&#10;                    ruleName: 'valid-rule',&#10;                    match: {email: 'jane@example.com'},&#10;                    apply: {name: 'Jane Updated'}&#10;                }),&#10;            ];&#10;&#10;            const affectedRows = await rulesEngine.applyRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(1); // Only the valid rule should be applied&#10;&#10;            // Verify only Jane was updated&#10;            const john = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'john@example.com')&#10;                .executeTakeFirst();&#10;&#10;            const jane = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'jane@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(john.name).toBe('John Doe'); // Unchanged&#10;            expect(jane.name).toBe('Jane Updated'); // Changed&#10;        });&#10;&#10;        it('should handle rules that update multiple fields', async () =&gt; {&#10;            const rule = MatchRuleFactory.createRule({&#10;                ruleName: 'update-multiple-fields',&#10;                match: {email: 'alice@example.com'},&#10;                apply: {&#10;                    name: 'Alice Updated',&#10;                    email: 'alice.updated@example.com'&#10;                }&#10;            });&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(1);&#10;&#10;            // Verify both fields were updated&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'alice.updated@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(updatedUser).toBeDefined();&#10;            expect(updatedUser.name).toBe('Alice Updated');&#10;            expect(updatedUser.email).toBe('alice.updated@example.com');&#10;        });&#10;&#10;        it('should maintain transaction integrity on error', async () =&gt; {&#10;            // Do not write this test.&#10;        });&#10;&#10;        it('should apply rules in priority order (lower priority first)', async () =&gt; {&#10;            // Jane will be updated twice, but the lower priority rule should apply first&#10;            const rules = [&#10;                MatchRuleFactory.createRule({&#10;                    ruleName: 'priority-2',&#10;                    match: {email: 'jane@example.com'},&#10;                    apply: {name: 'Jane Priority 2'},&#10;                    priority: 2&#10;                }),&#10;                MatchRuleFactory.createRule({&#10;                    ruleName: 'priority-0',&#10;                    match: {email: 'jane@example.com'},&#10;                    apply: {name: 'Jane Priority 0'},&#10;                    priority: 0&#10;                }),&#10;                MatchRuleFactory.createRule({&#10;                    ruleName: 'priority-1',&#10;                    match: {email: 'jane@example.com'},&#10;                    apply: {name: 'Jane Priority 1'},&#10;                    priority: 1&#10;                }),&#10;            ];&#10;            await rulesEngine.applyRules(rules, 'users');&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'jane@example.com')&#10;                .executeTakeFirst();&#10;            expect(updatedUser.name).toBe('Jane Priority 2'); // Last rule applied (highest priority number)&#10;        });&#10;&#10;        it('should default priority to 0 if not specified', async () =&gt; {&#10;            const rules = [&#10;                MatchRuleFactory.createRule({&#10;                    ruleName: 'default-priority',&#10;                    match: {email: 'bob@example.com'},&#10;                    apply: {name: 'Bob Default Priority'}&#10;                }),&#10;                MatchRuleFactory.createRule({&#10;                    ruleName: 'explicit-priority-1',&#10;                    match: {email: 'bob@example.com'},&#10;                    apply: {name: 'Bob Priority 1'},&#10;                    priority: 1&#10;                }),&#10;            ];&#10;            await rulesEngine.applyRules(rules, 'users');&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'bob@example.com')&#10;                .executeTakeFirst();&#10;            expect(updatedUser.name).toBe('Bob Priority 1'); // Last rule applied (priority 1)&#10;        });&#10;    });&#10;&#10;    describe('appliedRulesField functionality', () =&gt; {&#10;        beforeEach(async () =&gt; {&#10;            // Set up appliedRulesField for these tests&#10;            rulesEngine.setAppliedRulesField('appliedRules');&#10;        });&#10;&#10;        it('should track applied rules when appliedRulesField is configured', async () =&gt; {&#10;            const rule = MatchRuleFactory.createRule({&#10;                ruleName: 'track-rule',&#10;                match: {email: 'john@example.com'},&#10;                apply: {name: 'John Tracked'}&#10;            });&#10;&#10;            await rulesEngine.applyRules([rule], 'users');&#10;&#10;            // Verify the rule was applied and tracked&#10;            const users = await rulesEngine.getRowsWithAppliedRules&lt;User&gt;('users', {email: 'john@example.com'});&#10;&#10;            expect(users).toHaveLength(1);&#10;            expect(users[0].name).toBe('John Tracked');&#10;            expect(users[0].appliedRules).toEqual(['track-rule']);&#10;        });&#10;&#10;        it('should track multiple rules applied to the same row', async () =&gt; {&#10;            const rules = [&#10;                MatchRuleFactory.createRule({&#10;                    ruleName: 'first-rule',&#10;                    match: {email: 'jane@example.com'},&#10;                    apply: {name: 'Jane First'}&#10;                }),&#10;                MatchRuleFactory.createRule({&#10;                    ruleName: 'second-rule',&#10;                    match: {email: 'jane@example.com'},&#10;                    apply: {name: 'Jane Second'}&#10;                })&#10;            ];&#10;&#10;            // Apply first rule&#10;            await rulesEngine.applyRules([rules[0]], 'users');&#10;&#10;            // Apply second rule&#10;            await rulesEngine.applyRules([rules[1]], 'users');&#10;&#10;            const users = await rulesEngine.getRowsWithAppliedRules&lt;User&gt;('users', {email: 'jane@example.com'});&#10;&#10;            expect(users).toHaveLength(1);&#10;            expect(users[0].name).toBe('Jane Second');&#10;            expect(users[0].appliedRules).toEqual(['first-rule', 'second-rule']);&#10;        });&#10;&#10;        it('should handle rows with no applied rules', async () =&gt; {&#10;            const users = await rulesEngine.getRowsWithAppliedRules&lt;User&gt;('users', {email: 'bob@example.com'});&#10;&#10;            expect(users).toHaveLength(1);&#10;            expect(users[0].name).toBe('Bob Johnson'); // Original name&#10;            expect(users[0].appliedRules).toEqual([]);&#10;        });&#10;&#10;        it('should clear applied rules for specific conditions', async () =&gt; {&#10;            // First apply a rule&#10;            const rule = MatchRuleFactory.createRule({&#10;                ruleName: 'clear-test-rule',&#10;                match: {email: 'alice@example.com'},&#10;                apply: {name: 'Alice Modified'}&#10;            });&#10;&#10;            await rulesEngine.applyRules([rule], 'users');&#10;&#10;            // Verify rule was tracked&#10;            let users = await rulesEngine.getRowsWithAppliedRules&lt;User&gt;('users', {email: 'alice@example.com'});&#10;            expect(users[0].appliedRules).toEqual(['clear-test-rule']);&#10;&#10;            // Clear applied rules for Alice&#10;            const clearedRows = await rulesEngine.clearAppliedRules('users', {email: 'alice@example.com'});&#10;            expect(clearedRows).toBe(1);&#10;&#10;            // Verify applied rules were cleared&#10;            users = await rulesEngine.getRowsWithAppliedRules&lt;User&gt;('users', {email: 'alice@example.com'});&#10;            expect(users[0].appliedRules).toEqual([]);&#10;        });&#10;&#10;        it('should clear applied rules for all rows when no conditions provided', async () =&gt; {&#10;            // Apply rules to multiple users&#10;            const rules = [&#10;                MatchRuleFactory.createRule({&#10;                    ruleName: 'bulk-rule-1',&#10;                    match: {email: 'john@example.com'},&#10;                    apply: {name: 'John Bulk'}&#10;                }),&#10;                MatchRuleFactory.createRule({&#10;                    ruleName: 'bulk-rule-2',&#10;                    match: {email: 'jane@example.com'},&#10;                    apply: {name: 'Jane Bulk'}&#10;                })&#10;            ];&#10;&#10;            await rulesEngine.applyRules(rules, 'users');&#10;&#10;            // Verify rules were tracked&#10;            let allUsers = await rulesEngine.getRowsWithAppliedRules('users');&#10;            const trackedUsers = allUsers.filter(u =&gt; u.appliedRules &amp;&amp; u.appliedRules.length &gt; 0);&#10;            expect(trackedUsers).toHaveLength(2);&#10;&#10;            // Clear all applied rules&#10;            const clearedRows = await rulesEngine.clearAppliedRules('users');&#10;            expect(clearedRows).toBe(4); // All 4 users should be updated&#10;&#10;            // Verify all applied rules were cleared&#10;            allUsers = await rulesEngine.getRowsWithAppliedRules('users');&#10;            expect(allUsers.every(u =&gt; u.appliedRules?.length === 0)).toBe(true);&#10;        });&#10;&#10;        it('should throw error when getRowsWithAppliedRules called without configuring appliedRulesField', async () =&gt; {&#10;            const engineWithoutField = new PgRulesEngine(db);&#10;&#10;            await expect(engineWithoutField.getRowsWithAppliedRules('users')).rejects.toThrow(&#10;                'appliedRulesField is not configured. Use setAppliedRulesField() first.'&#10;            );&#10;        });&#10;&#10;        it('should throw error when clearAppliedRules called without configuring appliedRulesField', async () =&gt; {&#10;            const engineWithoutField = new PgRulesEngine(db);&#10;&#10;            await expect(engineWithoutField.clearAppliedRules('users')).rejects.toThrow(&#10;                'appliedRulesField is not configured. Use setAppliedRulesField() first.'&#10;            );&#10;        });&#10;&#10;        it('should filter rows correctly with WHERE conditions in getRowsWithAppliedRules', async () =&gt; {&#10;            // Apply rules to different users&#10;            const rules = [&#10;                MatchRuleFactory.createRule({&#10;                    ruleName: 'filter-rule-1',&#10;                    match: {email: 'john@example.com'},&#10;                    apply: {name: 'John Filtered'}&#10;                }),&#10;                MatchRuleFactory.createRule({&#10;                    ruleName: 'filter-rule-2',&#10;                    match: {email: 'jane@example.com'},&#10;                    apply: {name: 'Jane Filtered'}&#10;                })&#10;            ];&#10;&#10;            await rulesEngine.applyRules(rules, 'users');&#10;&#10;            // Get only John's data&#10;            const johnUsers = await rulesEngine.getRowsWithAppliedRules('users', {email: 'john@example.com'});&#10;            expect(johnUsers).toHaveLength(1);&#10;            expect(johnUsers[0].email).toBe('john@example.com');&#10;            expect(johnUsers[0].appliedRules).toEqual(['filter-rule-1']);&#10;&#10;            // Get only Jane's data&#10;            const janeUsers = await rulesEngine.getRowsWithAppliedRules('users', {email: 'jane@example.com'});&#10;            expect(janeUsers).toHaveLength(1);&#10;            expect(janeUsers[0].email).toBe('jane@example.com');&#10;            expect(janeUsers[0].appliedRules).toEqual(['filter-rule-2']);&#10;        });&#10;&#10;        it('should work correctly when appliedRulesField is changed between operations', async () =&gt; {&#10;            // Apply rule with first field name&#10;            const rule1 = MatchRuleFactory.createRule({&#10;                ruleName: 'field-test-1',&#10;                match: {email: 'bob@example.com'},&#10;                apply: {name: 'Bob Field Test'}&#10;            });&#10;&#10;            await rulesEngine.applyRules([rule1], 'users');&#10;&#10;            // Verify tracking with first field&#10;            let users = await rulesEngine.getRowsWithAppliedRules('users', {email: 'bob@example.com'});&#10;            expect(users[0].appliedRules).toEqual(['field-test-1']);&#10;&#10;            // Change the field name and apply another rule&#10;            rulesEngine.setAppliedRulesField('appliedRules'); // Same field name for this test&#10;&#10;            const rule2 = MatchRuleFactory.createRule({&#10;                ruleName: 'field-test-2',&#10;                match: {email: 'bob@example.com'},&#10;                apply: {name: 'Bob Field Test 2'}&#10;            });&#10;&#10;            await rulesEngine.applyRules([rule2], 'users');&#10;&#10;            // Verify both rules are tracked&#10;            users = await rulesEngine.getRowsWithAppliedRules('users', {email: 'bob@example.com'});&#10;            expect(users[0].appliedRules).toEqual(['field-test-1', 'field-test-2']);&#10;        });&#10;&#10;        it('should track rules in transaction correctly', async () =&gt; {&#10;            const rules = [&#10;                MatchRuleFactory.createRule({&#10;                    ruleName: 'transaction-rule-1',&#10;                    match: {email: 'john@example.com'},&#10;                    apply: {name: 'John Transaction 1'}&#10;                }),&#10;                MatchRuleFactory.createRule({&#10;                    ruleName: 'transaction-rule-2',&#10;                    match: {email: 'jane@example.com'},&#10;                    apply: {name: 'Jane Transaction 2'}&#10;                })&#10;            ];&#10;&#10;            // Apply both rules in a single transaction&#10;            const affectedRows = await rulesEngine.applyRules(rules, 'users');&#10;            expect(affectedRows).toBe(2);&#10;&#10;            // Verify both rules were tracked&#10;            const johnUsers = await rulesEngine.getRowsWithAppliedRules('users', {email: 'john@example.com'});&#10;            const janeUsers = await rulesEngine.getRowsWithAppliedRules('users', {email: 'jane@example.com'});&#10;&#10;            expect(johnUsers[0].appliedRules).toEqual(['transaction-rule-1']);&#10;            expect(janeUsers[0].appliedRules).toEqual(['transaction-rule-2']);&#10;        });&#10;    });&#10;&#10;    describe('appliedRulesField configuration', () =&gt; {&#10;        it('should allow setting and changing appliedRulesField', () =&gt; {&#10;            expect(() =&gt; rulesEngine.setAppliedRulesField('customField')).not.toThrow();&#10;            expect(() =&gt; rulesEngine.setAppliedRulesField('  anotherField  ')).not.toThrow();&#10;        });&#10;&#10;        it('should work without appliedRulesField configured', async () =&gt; {&#10;            // Create engine without setting appliedRulesField&#10;            const basicEngine = new PgRulesEngine(db);&#10;&#10;            const rule = MatchRuleFactory.createRule({&#10;                ruleName: 'no-tracking-rule',&#10;                match: {email: 'alice@example.com'},&#10;                apply: {name: 'Alice No Tracking'}&#10;            });&#10;&#10;            const affectedRows = await basicEngine.applyRules([rule], 'users');&#10;            expect(affectedRows).toBe(1);&#10;&#10;            // Verify the rule was applied but no tracking occurred&#10;            const user = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'alice@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(user.name).toBe('Alice No Tracking');&#10;            // appliedRules field should still be null/empty since no tracking was configured&#10;        });&#10;    });&#10;&#10;    describe('regex matching functionality', () =&gt; {&#10;        beforeEach(async () =&gt; {&#10;            // Insert additional test data with various categories and statuses&#10;            await db&#10;                .insertInto('users')&#10;                .values([&#10;                    { email: 'user1@test.com', name: 'User One' },&#10;                    { email: 'user2@test.com', name: 'User Two' },&#10;                    { email: 'user3@test.com', name: 'User Three' },&#10;                ])&#10;                .execute();&#10;        });&#10;&#10;        it('should match strings using regex patterns with OR operator', async () =&gt; {&#10;            // Set different roles (role column already exists in User schema)&#10;            await db.updateTable('users').set({ role: 'admin' }).where('email', '=', 'user1@test.com').execute();&#10;            await db.updateTable('users').set({ role: 'moderator' }).where('email', '=', 'user2@test.com').execute();&#10;            await db.updateTable('users').set({ role: 'guest' }).where('email', '=', 'user3@test.com').execute();&#10;&#10;            const rule = MatchRuleFactory.createRule({&#10;                ruleName: 'role-staff-rule',&#10;                match: { role: 'admin|moderator' },&#10;                apply: { name: 'Staff Member' }&#10;            });&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(2); // Should match 2 users (admin and moderator)&#10;&#10;            // Verify only the matching users were updated&#10;            const updatedUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Staff Member')&#10;                .execute();&#10;&#10;            expect(updatedUsers).toHaveLength(2);&#10;            expect(updatedUsers.map((u: any) =&gt; u.role).sort()).toEqual(['admin', 'moderator']);&#10;        });&#10;&#10;        it('should match exact string patterns', async () =&gt; {&#10;            // Test exact string matching (no special regex characters)&#10;            const rule = MatchRuleFactory.createRule({&#10;                ruleName: 'exact-email-rule',&#10;                match: { email: 'john@example.com' },&#10;                apply: { name: 'Exact Match User' }&#10;            });&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(1); // Should match exactly one user&#10;&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'john@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(updatedUser.name).toBe('Exact Match User');&#10;        });&#10;&#10;        it('should handle regex patterns with special characters', async () =&gt; {&#10;            // Set various statuses&#10;            await db.updateTable('users').set({ status: 'active' }).where('email', '=', 'john@example.com').execute();&#10;            await db.updateTable('users').set({ status: 'inactive' }).where('email', '=', 'jane@example.com').execute();&#10;            await db.updateTable('users').set({ status: 'pending' }).where('email', '=', 'bob@example.com').execute();&#10;&#10;            const rule = MatchRuleFactory.createRule({&#10;                ruleName: 'status-pattern-rule',&#10;                match: { status: '^(active|pending)$' },&#10;                apply: { name: 'Active or Pending User' }&#10;            });&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(2); // Should match 2 users (active and pending)&#10;&#10;            const updatedUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Active or Pending User')&#10;                .execute();&#10;&#10;            expect(updatedUsers).toHaveLength(2);&#10;            expect(updatedUsers.map((u: any) =&gt; u.status).sort()).toEqual(['active', 'pending']);&#10;        });&#10;&#10;        it('should handle case-sensitive regex matching', async () =&gt; {&#10;            // Set roles with different cases&#10;            await db.updateTable('users').set({ role: 'Admin' }).where('email', '=', 'john@example.com').execute();&#10;            await db.updateTable('users').set({ role: 'admin' }).where('email', '=', 'jane@example.com').execute();&#10;            await db.updateTable('users').set({ role: 'ADMIN' }).where('email', '=', 'bob@example.com').execute();&#10;&#10;            const rule = MatchRuleFactory.createRule({&#10;                ruleName: 'case-sensitive-rule',&#10;                match: { role: 'Admin' },&#10;                apply: { name: 'Exact Case Match' }&#10;            });&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(1); // Should match only one user (exact case)&#10;&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Exact Case Match')&#10;                .executeTakeFirst();&#10;&#10;            expect(updatedUser.role).toBe('Admin');&#10;        });&#10;&#10;        it('should use direct equality for non-string values', async () =&gt; {&#10;            // Set test data&#10;            await db.updateTable('users').set({ age: 25, isVerified: true }).where('email', '=', 'john@example.com').execute();&#10;            await db.updateTable('users').set({ age: 30, isVerified: false }).where('email', '=', 'jane@example.com').execute();&#10;            await db.updateTable('users').set({ age: 25, isVerified: true }).where('email', '=', 'bob@example.com').execute();&#10;&#10;            const rule = MatchRuleFactory.createRule({&#10;                ruleName: 'non-string-rule',&#10;                match: {&#10;                    age: 25,&#10;                    isVerified: true&#10;                },&#10;                apply: { name: 'Non-String Match' }&#10;            });&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(2); // Should match 2 users with age=25 AND isVerified=true&#10;&#10;            const updatedUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Non-String Match')&#10;                .execute();&#10;&#10;            expect(updatedUsers).toHaveLength(2);&#10;            expect(updatedUsers.every((u: any) =&gt; u.age === 25 &amp;&amp; u.isVerified === true)).toBe(true);&#10;        });&#10;&#10;        it('should handle mixed string and non-string conditions', async () =&gt; {&#10;            // Set test data using role (already exists) and priority&#10;            await db.updateTable('users').set({ role: 'admin', priority: 1 }).where('email', '=', 'john@example.com').execute();&#10;            await db.updateTable('users').set({ role: 'user', priority: 1 }).where('email', '=', 'jane@example.com').execute();&#10;            await db.updateTable('users').set({ role: 'admin', priority: 2 }).where('email', '=', 'bob@example.com').execute();&#10;&#10;            const rule = MatchRuleFactory.createRule({&#10;                ruleName: 'mixed-conditions-rule',&#10;                match: {&#10;                    role: 'admin|user',&#10;                    priority: 1&#10;                },&#10;                apply: { name: 'Mixed Conditions Match' }&#10;            });&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(2); // Should match users with (admin OR user) AND priority=1&#10;&#10;            const updatedUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Mixed Conditions Match')&#10;                .execute();&#10;&#10;            expect(updatedUsers).toHaveLength(2);&#10;            expect(updatedUsers.every((u: any) =&gt; u.priority === 1)).toBe(true);&#10;            expect(updatedUsers.map((u: any) =&gt; u.role).sort()).toEqual(['admin', 'user']);&#10;        });&#10;&#10;        it('should handle regex patterns with no matches', async () =&gt; {&#10;            const rule = MatchRuleFactory.createRule({&#10;                ruleName: 'no-match-regex-rule',&#10;                match: { email: 'nonexistent.*pattern' },&#10;                apply: { name: 'Should Not Match' }&#10;            });&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(0);&#10;&#10;            // Verify no users were updated&#10;            const updatedUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Should Not Match')&#10;                .execute();&#10;&#10;            expect(updatedUsers).toHaveLength(0);&#10;        });&#10;&#10;        it('should handle regex patterns with dot metacharacter', async () =&gt; {&#10;            // Test dot (.) metacharacter matching any character&#10;            const rule = MatchRuleFactory.createRule({&#10;                ruleName: 'dot-pattern-rule',&#10;                match: { email: 'j..n@example.com' },&#10;                apply: { name: 'Dot Pattern Match' }&#10;            });&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(1);&#10;&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'john@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(updatedUser.name).toBe('Dot Pattern Match');&#10;        });&#10;&#10;        it('should handle complex regex patterns', async () =&gt; {&#10;            // Set phone numbers&#10;            await db.updateTable('users').set({ phone: '+1-555-123-4567' }).where('email', '=', 'john@example.com').execute();&#10;            await db.updateTable('users').set({ phone: '555.123.4568' }).where('email', '=', 'jane@example.com').execute();&#10;            await db.updateTable('users').set({ phone: '(555) 123-4569' }).where('email', '=', 'bob@example.com').execute();&#10;            await db.updateTable('users').set({ phone: '5551234570' }).where('email', '=', 'alice@example.com').execute();&#10;&#10;            const rule = MatchRuleFactory.createRule({&#10;                ruleName: 'phone-pattern-rule',&#10;                match: { phone: '.*555.*123.*' },&#10;                apply: { name: 'Phone Pattern Match' }&#10;            });&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(4); // Should match all phone numbers containing 555 and 123&#10;&#10;            const updatedUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Phone Pattern Match')&#10;                .execute();&#10;&#10;            expect(updatedUsers).toHaveLength(4);&#10;        });&#10;    });&#10;});&#10;" />
              <option name="updatedContent" value="import {createTestDatabase} from './test-database';&#10;import {PgRulesEngine} from './PgRulesEngine';&#10;import {User} from './database.types';&#10;import {MatchRuleFactory} from &quot;./MatchRuleFactory&quot;;&#10;&#10;describe('PgRulesEngine', () =&gt; {&#10;    let db: any;&#10;    let rulesEngine: PgRulesEngine;&#10;&#10;    beforeEach(async () =&gt; {&#10;        db = createTestDatabase();&#10;        rulesEngine = new PgRulesEngine(db);&#10;&#10;        // Insert test users&#10;        await db&#10;            .insertInto('users')&#10;            .values([&#10;                {email: 'john@example.com', name: 'John Doe'},&#10;                {email: 'jane@example.com', name: 'Jane Smith'},&#10;                {email: 'bob@example.com', name: 'Bob Johnson'},&#10;                {email: 'alice@example.com', name: 'Alice Brown'},&#10;            ])&#10;            .execute();&#10;    });&#10;&#10;    describe('applyRules', () =&gt; {&#10;        it('should apply a single rule to update user names', async () =&gt; {&#10;            // Create a rule to update John's name&#10;            const rule = MatchRuleFactory.createRule({&#10;                ruleName: 'update-john-name',&#10;                match: {email: 'john@example.com'},&#10;                apply: {name: 'John Updated'}&#10;            });&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(1);&#10;&#10;            // Verify the update was applied&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'john@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(updatedUser.name).toBe('John Updated');&#10;        });&#10;&#10;        it('should apply multiple rules in a single transaction', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'update-john',&#10;                    match: {email: 'john@example.com'},&#10;                    apply: {name: 'John Modified'}&#10;                },&#10;                {&#10;                    ruleName: 'update-jane',&#10;                    match: {email: 'jane@example.com'},&#10;                    apply: {name: 'Jane Modified'}&#10;                },&#10;            ]);&#10;&#10;            const affectedRows = await rulesEngine.applyRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(2);&#10;&#10;            // Verify both updates were applied&#10;            const users = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', 'in', ['john@example.com', 'jane@example.com'])&#10;                .execute();&#10;&#10;            expect(users).toHaveLength(2);&#10;            expect(users.find((u: User) =&gt; u.email === 'john@example.com')?.name).toBe('John Modified');&#10;            expect(users.find((u: User) =&gt; u.email === 'jane@example.com')?.name).toBe('Jane Modified');&#10;        });&#10;&#10;        it('should handle rules with multiple match conditions', async () =&gt; {&#10;            // First, update one user to have a specific name&#10;            await db&#10;                .updateTable('users')&#10;                .set({name: 'Target User'})&#10;                .where('email', '=', 'bob@example.com')&#10;                .execute();&#10;&#10;            const rule = MatchRuleFactory.createRule({&#10;                ruleName: 'update-specific-user',&#10;                match: {email: 'bob@example.com', name: 'Target User'},&#10;                apply: {name: 'Updated Target User'}&#10;            });&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(1);&#10;&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'bob@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(updatedUser.name).toBe('Updated Target User');&#10;        });&#10;&#10;        it('should return 0 when no rules match any records', async () =&gt; {&#10;            const rule = MatchRuleFactory.createRule({&#10;                ruleName: 'update-nonexistent',&#10;                match: {email: 'nonexistent@example.com'},&#10;                apply: {name: 'Should Not Update'}&#10;            });&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(0);&#10;&#10;            // Verify no users were changed&#10;            const allUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .execute();&#10;&#10;            expect(allUsers).toHaveLength(4);&#10;            // @ts-ignore&#10;            expect(allUsers.every((u: User) =&gt; !u.name.includes('Should Not Update'))).toBe(true);&#10;        });&#10;&#10;        it('should return 0 when given an empty rules array', async () =&gt; {&#10;            const affectedRows = await rulesEngine.applyRules([], 'users');&#10;&#10;            expect(affectedRows).toBe(0);&#10;        });&#10;&#10;        it('should skip rules with empty apply objects', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'empty-apply',&#10;                    match: {email: 'john@example.com'},&#10;                    apply: {}&#10;                },&#10;                {&#10;                    ruleName: 'valid-rule',&#10;                    match: {email: 'jane@example.com'},&#10;                    apply: {name: 'Jane Updated'}&#10;                },&#10;            ]);&#10;&#10;            const affectedRows = await rulesEngine.applyRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(1); // Only the valid rule should be applied&#10;&#10;            // Verify only Jane was updated&#10;            const john = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'john@example.com')&#10;                .executeTakeFirst();&#10;&#10;            const jane = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'jane@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(john.name).toBe('John Doe'); // Unchanged&#10;            expect(jane.name).toBe('Jane Updated'); // Changed&#10;        });&#10;&#10;        it('should handle rules that update multiple fields', async () =&gt; {&#10;            const rule = MatchRuleFactory.createRule({&#10;                ruleName: 'update-multiple-fields',&#10;                match: {email: 'alice@example.com'},&#10;                apply: {&#10;                    name: 'Alice Updated',&#10;                    email: 'alice.updated@example.com'&#10;                }&#10;            });&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(1);&#10;&#10;            // Verify both fields were updated&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'alice.updated@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(updatedUser).toBeDefined();&#10;            expect(updatedUser.name).toBe('Alice Updated');&#10;            expect(updatedUser.email).toBe('alice.updated@example.com');&#10;        });&#10;&#10;        it('should maintain transaction integrity on error', async () =&gt; {&#10;            // Do not write this test.&#10;        });&#10;&#10;        it('should apply rules in priority order (lower priority first)', async () =&gt; {&#10;            // Jane will be updated twice, but the lower priority rule should apply first&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'priority-2',&#10;                    match: {email: 'jane@example.com'},&#10;                    apply: {name: 'Jane Priority 2'},&#10;                    priority: 2&#10;                },&#10;                {&#10;                    ruleName: 'priority-0',&#10;                    match: {email: 'jane@example.com'},&#10;                    apply: {name: 'Jane Priority 0'},&#10;                    priority: 0&#10;                },&#10;                {&#10;                    ruleName: 'priority-1',&#10;                    match: {email: 'jane@example.com'},&#10;                    apply: {name: 'Jane Priority 1'},&#10;                    priority: 1&#10;                },&#10;            ]);&#10;            await rulesEngine.applyRules(rules, 'users');&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'jane@example.com')&#10;                .executeTakeFirst();&#10;            expect(updatedUser.name).toBe('Jane Priority 2'); // Last rule applied (highest priority number)&#10;        });&#10;&#10;        it('should default priority to 0 if not specified', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'default-priority',&#10;                    match: {email: 'bob@example.com'},&#10;                    apply: {name: 'Bob Default Priority'}&#10;                },&#10;                {&#10;                    ruleName: 'explicit-priority-1',&#10;                    match: {email: 'bob@example.com'},&#10;                    apply: {name: 'Bob Priority 1'},&#10;                    priority: 1&#10;                },&#10;            ]);&#10;            await rulesEngine.applyRules(rules, 'users');&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'bob@example.com')&#10;                .executeTakeFirst();&#10;            expect(updatedUser.name).toBe('Bob Priority 1'); // Last rule applied (priority 1)&#10;        });&#10;    });&#10;&#10;    describe('appliedRulesField functionality', () =&gt; {&#10;        beforeEach(async () =&gt; {&#10;            // Set up appliedRulesField for these tests&#10;            rulesEngine.setAppliedRulesField('appliedRules');&#10;        });&#10;&#10;        it('should track applied rules when appliedRulesField is configured', async () =&gt; {&#10;            const rule = MatchRuleFactory.createRule({&#10;                ruleName: 'track-rule',&#10;                match: {email: 'john@example.com'},&#10;                apply: {name: 'John Tracked'}&#10;            });&#10;&#10;            await rulesEngine.applyRules([rule], 'users');&#10;&#10;            // Verify the rule was applied and tracked&#10;            const users = await rulesEngine.getRowsWithAppliedRules&lt;User&gt;('users', {email: 'john@example.com'});&#10;&#10;            expect(users).toHaveLength(1);&#10;            expect(users[0].name).toBe('John Tracked');&#10;            expect(users[0].appliedRules).toEqual(['track-rule']);&#10;        });&#10;&#10;        it('should track multiple rules applied to the same row', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'first-rule',&#10;                    match: {email: 'jane@example.com'},&#10;                    apply: {name: 'Jane First'}&#10;                },&#10;                {&#10;                    ruleName: 'second-rule',&#10;                    match: {email: 'jane@example.com'},&#10;                    apply: {name: 'Jane Second'}&#10;                }&#10;            ]);&#10;&#10;            // Apply first rule&#10;            await rulesEngine.applyRules([rules[0]], 'users');&#10;&#10;            // Apply second rule&#10;            await rulesEngine.applyRules([rules[1]], 'users');&#10;&#10;            const users = await rulesEngine.getRowsWithAppliedRules&lt;User&gt;('users', {email: 'jane@example.com'});&#10;&#10;            expect(users).toHaveLength(1);&#10;            expect(users[0].name).toBe('Jane Second');&#10;            expect(users[0].appliedRules).toEqual(['first-rule', 'second-rule']);&#10;        });&#10;&#10;        it('should handle rows with no applied rules', async () =&gt; {&#10;            const users = await rulesEngine.getRowsWithAppliedRules&lt;User&gt;('users', {email: 'bob@example.com'});&#10;&#10;            expect(users).toHaveLength(1);&#10;            expect(users[0].name).toBe('Bob Johnson'); // Original name&#10;            expect(users[0].appliedRules).toEqual([]);&#10;        });&#10;&#10;        it('should clear applied rules for specific conditions', async () =&gt; {&#10;            // First apply a rule&#10;            const rule = MatchRuleFactory.createRule({&#10;                ruleName: 'clear-test-rule',&#10;                match: {email: 'alice@example.com'},&#10;                apply: {name: 'Alice Modified'}&#10;            });&#10;&#10;            await rulesEngine.applyRules([rule], 'users');&#10;&#10;            // Verify rule was tracked&#10;            let users = await rulesEngine.getRowsWithAppliedRules&lt;User&gt;('users', {email: 'alice@example.com'});&#10;            expect(users[0].appliedRules).toEqual(['clear-test-rule']);&#10;&#10;            // Clear applied rules for Alice&#10;            const clearedRows = await rulesEngine.clearAppliedRules('users', {email: 'alice@example.com'});&#10;            expect(clearedRows).toBe(1);&#10;&#10;            // Verify applied rules were cleared&#10;            users = await rulesEngine.getRowsWithAppliedRules&lt;User&gt;('users', {email: 'alice@example.com'});&#10;            expect(users[0].appliedRules).toEqual([]);&#10;        });&#10;&#10;        it('should clear applied rules for all rows when no conditions provided', async () =&gt; {&#10;            // Apply rules to multiple users&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'bulk-rule-1',&#10;                    match: {email: 'john@example.com'},&#10;                    apply: {name: 'John Bulk'}&#10;                },&#10;                {&#10;                    ruleName: 'bulk-rule-2',&#10;                    match: {email: 'jane@example.com'},&#10;                    apply: {name: 'Jane Bulk'}&#10;                }&#10;            ]);&#10;&#10;            await rulesEngine.applyRules(rules, 'users');&#10;&#10;            // Verify rules were tracked&#10;            let allUsers = await rulesEngine.getRowsWithAppliedRules('users');&#10;            const trackedUsers = allUsers.filter(u =&gt; u.appliedRules &amp;&amp; u.appliedRules.length &gt; 0);&#10;            expect(trackedUsers).toHaveLength(2);&#10;&#10;            // Clear all applied rules&#10;            const clearedRows = await rulesEngine.clearAppliedRules('users');&#10;            expect(clearedRows).toBe(4); // All 4 users should be updated&#10;&#10;            // Verify all applied rules were cleared&#10;            allUsers = await rulesEngine.getRowsWithAppliedRules('users');&#10;            expect(allUsers.every(u =&gt; u.appliedRules?.length === 0)).toBe(true);&#10;        });&#10;&#10;        it('should throw error when getRowsWithAppliedRules called without configuring appliedRulesField', async () =&gt; {&#10;            const engineWithoutField = new PgRulesEngine(db);&#10;&#10;            await expect(engineWithoutField.getRowsWithAppliedRules('users')).rejects.toThrow(&#10;                'appliedRulesField is not configured. Use setAppliedRulesField() first.'&#10;            );&#10;        });&#10;&#10;        it('should throw error when clearAppliedRules called without configuring appliedRulesField', async () =&gt; {&#10;            const engineWithoutField = new PgRulesEngine(db);&#10;&#10;            await expect(engineWithoutField.clearAppliedRules('users')).rejects.toThrow(&#10;                'appliedRulesField is not configured. Use setAppliedRulesField() first.'&#10;            );&#10;        });&#10;&#10;        it('should filter rows correctly with WHERE conditions in getRowsWithAppliedRules', async () =&gt; {&#10;            // Apply rules to different users&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'filter-rule-1',&#10;                    match: {email: 'john@example.com'},&#10;                    apply: {name: 'John Filtered'}&#10;                },&#10;                {&#10;                    ruleName: 'filter-rule-2',&#10;                    match: {email: 'jane@example.com'},&#10;                    apply: {name: 'Jane Filtered'}&#10;                }&#10;            ]);&#10;&#10;            await rulesEngine.applyRules(rules, 'users');&#10;&#10;            // Get only John's data&#10;            const johnUsers = await rulesEngine.getRowsWithAppliedRules('users', {email: 'john@example.com'});&#10;            expect(johnUsers).toHaveLength(1);&#10;            expect(johnUsers[0].email).toBe('john@example.com');&#10;            expect(johnUsers[0].appliedRules).toEqual(['filter-rule-1']);&#10;&#10;            // Get only Jane's data&#10;            const janeUsers = await rulesEngine.getRowsWithAppliedRules('users', {email: 'jane@example.com'});&#10;            expect(janeUsers).toHaveLength(1);&#10;            expect(janeUsers[0].email).toBe('jane@example.com');&#10;            expect(janeUsers[0].appliedRules).toEqual(['filter-rule-2']);&#10;        });&#10;&#10;        it('should work correctly when appliedRulesField is changed between operations', async () =&gt; {&#10;            // Apply rule with first field name&#10;            const rule1 = MatchRuleFactory.createRule({&#10;                ruleName: 'field-test-1',&#10;                match: {email: 'bob@example.com'},&#10;                apply: {name: 'Bob Field Test'}&#10;            });&#10;&#10;            await rulesEngine.applyRules([rule1], 'users');&#10;&#10;            // Verify tracking with first field&#10;            let users = await rulesEngine.getRowsWithAppliedRules('users', {email: 'bob@example.com'});&#10;            expect(users[0].appliedRules).toEqual(['field-test-1']);&#10;&#10;            // Change the field name and apply another rule&#10;            rulesEngine.setAppliedRulesField('appliedRules'); // Same field name for this test&#10;&#10;            const rule2 = MatchRuleFactory.createRule({&#10;                ruleName: 'field-test-2',&#10;                match: {email: 'bob@example.com'},&#10;                apply: {name: 'Bob Field Test 2'}&#10;            });&#10;&#10;            await rulesEngine.applyRules([rule2], 'users');&#10;&#10;            // Verify both rules are tracked&#10;            users = await rulesEngine.getRowsWithAppliedRules('users', {email: 'bob@example.com'});&#10;            expect(users[0].appliedRules).toEqual(['field-test-1', 'field-test-2']);&#10;        });&#10;&#10;        it('should track rules in transaction correctly', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'transaction-rule-1',&#10;                    match: {email: 'john@example.com'},&#10;                    apply: {name: 'John Transaction 1'}&#10;                },&#10;                {&#10;                    ruleName: 'transaction-rule-2',&#10;                    match: {email: 'jane@example.com'},&#10;                    apply: {name: 'Jane Transaction 2'}&#10;                }&#10;            ]);&#10;&#10;            // Apply both rules in a single transaction&#10;            const affectedRows = await rulesEngine.applyRules(rules, 'users');&#10;            expect(affectedRows).toBe(2);&#10;&#10;            // Verify both rules were tracked&#10;            const johnUsers = await rulesEngine.getRowsWithAppliedRules('users', {email: 'john@example.com'});&#10;            const janeUsers = await rulesEngine.getRowsWithAppliedRules('users', {email: 'jane@example.com'});&#10;&#10;            expect(johnUsers[0].appliedRules).toEqual(['transaction-rule-1']);&#10;            expect(janeUsers[0].appliedRules).toEqual(['transaction-rule-2']);&#10;        });&#10;    });&#10;&#10;    describe('appliedRulesField configuration', () =&gt; {&#10;        it('should allow setting and changing appliedRulesField', () =&gt; {&#10;            expect(() =&gt; rulesEngine.setAppliedRulesField('customField')).not.toThrow();&#10;            expect(() =&gt; rulesEngine.setAppliedRulesField('  anotherField  ')).not.toThrow();&#10;        });&#10;&#10;        it('should work without appliedRulesField configured', async () =&gt; {&#10;            // Create engine without setting appliedRulesField&#10;            const basicEngine = new PgRulesEngine(db);&#10;&#10;            const rule = MatchRuleFactory.createRule({&#10;                ruleName: 'no-tracking-rule',&#10;                match: {email: 'alice@example.com'},&#10;                apply: {name: 'Alice No Tracking'}&#10;            });&#10;&#10;            const affectedRows = await basicEngine.applyRules([rule], 'users');&#10;            expect(affectedRows).toBe(1);&#10;&#10;            // Verify the rule was applied but no tracking occurred&#10;            const user = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'alice@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(user.name).toBe('Alice No Tracking');&#10;            // appliedRules field should still be null/empty since no tracking was configured&#10;        });&#10;    });&#10;&#10;    describe('regex matching functionality', () =&gt; {&#10;        beforeEach(async () =&gt; {&#10;            // Insert additional test data with various categories and statuses&#10;            await db&#10;                .insertInto('users')&#10;                .values([&#10;                    { email: 'user1@test.com', name: 'User One' },&#10;                    { email: 'user2@test.com', name: 'User Two' },&#10;                    { email: 'user3@test.com', name: 'User Three' },&#10;                ])&#10;                .execute();&#10;        });&#10;&#10;        it('should match strings using regex patterns with OR operator', async () =&gt; {&#10;            // Set different roles (role column already exists in User schema)&#10;            await db.updateTable('users').set({ role: 'admin' }).where('email', '=', 'user1@test.com').execute();&#10;            await db.updateTable('users').set({ role: 'moderator' }).where('email', '=', 'user2@test.com').execute();&#10;            await db.updateTable('users').set({ role: 'guest' }).where('email', '=', 'user3@test.com').execute();&#10;&#10;            const rule = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'role-staff-rule',&#10;                    match: { role: 'admin|moderator' },&#10;                    apply: { name: 'Staff Member' }&#10;                }&#10;            ])[0];&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(2); // Should match 2 users (admin and moderator)&#10;&#10;            // Verify only the matching users were updated&#10;            const updatedUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Staff Member')&#10;                .execute();&#10;&#10;            expect(updatedUsers).toHaveLength(2);&#10;            expect(updatedUsers.map((u: any) =&gt; u.role).sort()).toEqual(['admin', 'moderator']);&#10;        });&#10;&#10;        it('should match exact string patterns', async () =&gt; {&#10;            // Test exact string matching (no special regex characters)&#10;            const rule = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'exact-email-rule',&#10;                    match: { email: 'john@example.com' },&#10;                    apply: { name: 'Exact Match User' }&#10;                }&#10;            ])[0];&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(1); // Should match exactly one user&#10;&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'john@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(updatedUser.name).toBe('Exact Match User');&#10;        });&#10;&#10;        it('should handle regex patterns with special characters', async () =&gt; {&#10;            // Set various statuses&#10;            await db.updateTable('users').set({ status: 'active' }).where('email', '=', 'john@example.com').execute();&#10;            await db.updateTable('users').set({ status: 'inactive' }).where('email', '=', 'jane@example.com').execute();&#10;            await db.updateTable('users').set({ status: 'pending' }).where('email', '=', 'bob@example.com').execute();&#10;&#10;            const rule = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'status-pattern-rule',&#10;                    match: { status: '^(active|pending)$' },&#10;                    apply: { name: 'Active or Pending User' }&#10;                }&#10;            ])[0];&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(2); // Should match 2 users (active and pending)&#10;&#10;            const updatedUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Active or Pending User')&#10;                .execute();&#10;&#10;            expect(updatedUsers).toHaveLength(2);&#10;            expect(updatedUsers.map((u: any) =&gt; u.status).sort()).toEqual(['active', 'pending']);&#10;        });&#10;&#10;        it('should handle case-sensitive regex matching', async () =&gt; {&#10;            // Set roles with different cases&#10;            await db.updateTable('users').set({ role: 'Admin' }).where('email', '=', 'john@example.com').execute();&#10;            await db.updateTable('users').set({ role: 'admin' }).where('email', '=', 'jane@example.com').execute();&#10;            await db.updateTable('users').set({ role: 'ADMIN' }).where('email', '=', 'bob@example.com').execute();&#10;&#10;            const rule = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'case-sensitive-rule',&#10;                    match: { role: 'Admin' },&#10;                    apply: { name: 'Exact Case Match' }&#10;                }&#10;            ])[0];&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(1); // Should match only one user (exact case)&#10;&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Exact Case Match')&#10;                .executeTakeFirst();&#10;&#10;            expect(updatedUser.role).toBe('Admin');&#10;        });&#10;&#10;        it('should use direct equality for non-string values', async () =&gt; {&#10;            // Set test data&#10;            await db.updateTable('users').set({ age: 25, isVerified: true }).where('email', '=', 'john@example.com').execute();&#10;            await db.updateTable('users').set({ age: 30, isVerified: false }).where('email', '=', 'jane@example.com').execute();&#10;            await db.updateTable('users').set({ age: 25, isVerified: true }).where('email', '=', 'bob@example.com').execute();&#10;&#10;            const rule = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'non-string-rule',&#10;                    match: {&#10;                        age: 25,&#10;                        isVerified: true&#10;                    },&#10;                    apply: { name: 'Non-String Match' }&#10;                }&#10;            ])[0];&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(2); // Should match 2 users with age=25 AND isVerified=true&#10;&#10;            const updatedUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Non-String Match')&#10;                .execute();&#10;&#10;            expect(updatedUsers).toHaveLength(2);&#10;            expect(updatedUsers.every((u: any) =&gt; u.age === 25 &amp;&amp; u.isVerified === true)).toBe(true);&#10;        });&#10;&#10;        it('should handle mixed string and non-string conditions', async () =&gt; {&#10;            // Set test data using role (already exists) and priority&#10;            await db.updateTable('users').set({ role: 'admin', priority: 1 }).where('email', '=', 'john@example.com').execute();&#10;            await db.updateTable('users').set({ role: 'user', priority: 1 }).where('email', '=', 'jane@example.com').execute();&#10;            await db.updateTable('users').set({ role: 'admin', priority: 2 }).where('email', '=', 'bob@example.com').execute();&#10;&#10;            const rule = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'mixed-conditions-rule',&#10;                    match: {&#10;                        role: 'admin|user',&#10;                        priority: 1&#10;                    },&#10;                    apply: { name: 'Mixed Conditions Match' }&#10;                }&#10;            ])[0];&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(2); // Should match users with (admin OR user) AND priority=1&#10;&#10;            const updatedUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Mixed Conditions Match')&#10;                .execute();&#10;&#10;            expect(updatedUsers).toHaveLength(2);&#10;            expect(updatedUsers.every((u: any) =&gt; u.priority === 1)).toBe(true);&#10;            expect(updatedUsers.map((u: any) =&gt; u.role).sort()).toEqual(['admin', 'user']);&#10;        });&#10;&#10;        it('should handle regex patterns with no matches', async () =&gt; {&#10;            const rule = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'no-match-regex-rule',&#10;                    match: { email: 'nonexistent.*pattern' },&#10;                    apply: { name: 'Should Not Match' }&#10;                }&#10;            ])[0];&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(0);&#10;&#10;            // Verify no users were updated&#10;            const updatedUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Should Not Match')&#10;                .execute();&#10;&#10;            expect(updatedUsers).toHaveLength(0);&#10;        });&#10;&#10;        it('should handle regex patterns with dot metacharacter', async () =&gt; {&#10;            // Test dot (.) metacharacter matching any character&#10;            const rule = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'dot-pattern-rule',&#10;                    match: { email: 'j..n@example.com' },&#10;                    apply: { name: 'Dot Pattern Match' }&#10;                }&#10;            ])[0];&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(1);&#10;&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'john@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(updatedUser.name).toBe('Dot Pattern Match');&#10;        });&#10;&#10;        it('should handle complex regex patterns', async () =&gt; {&#10;            // Set phone numbers&#10;            await db.updateTable('users').set({ phone: '+1-555-123-4567' }).where('email', '=', 'john@example.com').execute();&#10;            await db.updateTable('users').set({ phone: '555.123.4568' }).where('email', '=', 'jane@example.com').execute();&#10;            await db.updateTable('users').set({ phone: '(555) 123-4569' }).where('email', '=', 'bob@example.com').execute();&#10;            await db.updateTable('users').set({ phone: '5551234570' }).where('email', '=', 'alice@example.com').execute();&#10;&#10;            const rule = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'phone-pattern-rule',&#10;                    match: { phone: '.*555.*123.*' },&#10;                    apply: { name: 'Phone Pattern Match' }&#10;                }&#10;            ])[0];&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(4); // Should match all phone numbers containing 555 and 123&#10;&#10;            const updatedUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Phone Pattern Match')&#10;                .execute();&#10;&#10;            expect(updatedUsers).toHaveLength(4);&#10;        });&#10;    });&#10;});&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/PgRulesEngine.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/PgRulesEngine.ts" />
              <option name="originalContent" value="import {Kysely, sql} from 'kysely';&#10;import {MatchRule} from &quot;@/MatchRule&quot;;&#10;&#10;/**&#10; * PostgreSQL based rule engine that applies match rules to database tables.&#10; * applyRules is the main method to apply multiple rules in a single transaction.&#10; * applyRules always applied given rules without considering previously applied rules.&#10; */&#10;export class PgRulesEngine {&#10;&#10;    /**&#10;     * Additional field name in the target table to track applied rules.&#10;     * For example, appliedRulesField can be set to &quot;appliedRules TEXT[]&quot;, then applied rule&#10;     * will be added to the JSON array in this field. Specified &quot;appliedRules TEXT[]&quot; must be a PostgreSQL TEXT array type.&#10;     *&#10;     * @private&#10;     */&#10;    private appliedRulesField: string | null = null;&#10;&#10;    constructor(private db: Kysely&lt;any&gt;) {&#10;    }&#10;&#10;    /**&#10;     * Set the field name to track applied rules&#10;     * @param fieldName Name of the field to store applied rules&#10;     */&#10;    setAppliedRulesField(fieldName: string): void {&#10;        this.appliedRulesField = fieldName.trim();&#10;    }&#10;&#10;    /**&#10;     * Apply multiple rules to a target table in a single transaction&#10;     * @param rules Array of MatchRule objects to apply&#10;     * @param targetTable Name of the table to apply rules to&#10;     * @returns Promise that resolves to the total number of affected rows&#10;     */&#10;    async applyRules&lt;T&gt;(rules: MatchRule&lt;T&gt;[], targetTable: string): Promise&lt;number&gt; {&#10;        if (!rules.length) {&#10;            return 0;&#10;        }&#10;&#10;        return await this.db.transaction().execute(async (trx) =&gt; {&#10;            let totalAffectedRows = 0;&#10;&#10;            for (const rule of rules) {&#10;                // Build the update query&#10;                let query = trx.updateTable(targetTable);&#10;&#10;                // Add SET clause from apply object&#10;                const applyEntries = Object.entries(rule.apply);&#10;                if (applyEntries.length === 0) {&#10;                    console.warn(`Rule &quot;${rule.ruleName}&quot; has no apply changes, skipping...`);&#10;                    continue; // Skip rules with no apply changes&#10;                }&#10;&#10;                // Start with the apply object changes&#10;                const updateObject: Record&lt;string, any&gt; = {...rule.apply};&#10;&#10;                // Add appliedRulesField tracking if configured&#10;                if (this.appliedRulesField) {&#10;                    // Use PostgreSQL's JSON_ARRAY_APPEND to add the rule name to the JSON array&#10;                    /*language=TEXT*/&#10;                    updateObject[this.appliedRulesField] = sql`JSON_ARRAY_APPEND(COALESCE(${sql.ref(this.appliedRulesField)}, JSON_ARRAY()), '$', ${rule.ruleName})`;&#10;                }&#10;&#10;                query = query.set(updateObject);&#10;&#10;                // Add WHERE clause from match object&#10;                const matchEntries = Object.entries(rule.match);&#10;                if (matchEntries.length === 0) {&#10;                    console.warn(`Rule &quot;${rule.ruleName}&quot; has no match conditions, skipping...`);&#10;                    continue; // Skip rules with no match conditions&#10;                }&#10;&#10;                for (const [key, value] of matchEntries) {&#10;                    if (typeof value === 'string') {&#10;                        // Use PostgreSQL regex operator for case-sensitive string matching&#10;                        //query = query.where(sql.ref(key), '~', value);&#10;                        query = query.where(sql&lt;boolean&gt;`regexp_like(${sql.ref(key)}, ${sql.val(value)})`)&#10;                    } else {&#10;                        // Use direct equality for non-string types&#10;                        query = query.where(sql.ref(key), '=', value);&#10;                    }&#10;                }&#10;&#10;                // Execute the query and get affected row count&#10;                const result = await query.execute();&#10;                // Kysely's execute() returns UpdateResult[], we need the first result's numUpdatedRows&#10;                totalAffectedRows += Number(result[0]?.numUpdatedRows || 0);&#10;            }&#10;&#10;            return totalAffectedRows;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Clear applied rules tracking for rows matching the given conditions&#10;     * @param targetTable Name of the table to clear applied rules from&#10;     * @param whereConditions Conditions to match rows (optional, clears all if not provided)&#10;     * @returns Promise that resolves to the number of affected rows&#10;     */&#10;    async clearAppliedRules&lt;T&gt;(targetTable: string, whereConditions?: Partial&lt;T&gt;): Promise&lt;number&gt; {&#10;        if (!this.appliedRulesField) {&#10;            throw new Error('appliedRulesField is not configured. Use setAppliedRulesField() first.');&#10;        }&#10;&#10;        const updateObject: Record&lt;string, any&gt; = {};&#10;        /*language=TEXT*/&#10;        updateObject[this.appliedRulesField] = sql`JSON_ARRAY()`;&#10;&#10;        let query = this.db.updateTable(targetTable).set(updateObject);&#10;&#10;        // Add WHERE conditions if provided&#10;        if (whereConditions) {&#10;            const matchEntries = Object.entries(whereConditions);&#10;            for (const [key, value] of matchEntries) {&#10;                query = query.where(key, '=', value);&#10;            }&#10;        }&#10;&#10;        const result = await query.execute();&#10;        return Number(result[0]?.numUpdatedRows || 0);&#10;    }&#10;&#10;    private normalizeAppliedRules(value: unknown): string[] {&#10;        const normalizeOne = (v: unknown): string =&gt; {&#10;            if (v == null) return '';&#10;&#10;            // If it's already a JS string, try to JSON-parse it once to strip quotes&#10;            if (typeof v === 'string') {&#10;                // Fast path: JSON string literal like &quot;\&quot;track-rule\&quot;&quot; or '&quot;track-rule&quot;'&#10;                if (v.length &gt;= 2 &amp;&amp; v.startsWith('&quot;') &amp;&amp; v.endsWith('&quot;')) {&#10;                    try {&#10;                        return JSON.parse(v);&#10;                    } catch { /* fall through */&#10;                    }&#10;                    return v.slice(1, -1);&#10;                }&#10;                // Could also be a JSON array/object as string (unlikely here but safe)&#10;                try {&#10;                    const parsed = JSON.parse(v);&#10;                    if (typeof parsed === 'string') return parsed;     // '&quot;track-rule&quot;' -&gt; track-rule&#10;                    if (Array.isArray(parsed)) {&#10;                        // If someone stored '[&quot;a&quot;,&quot;b&quot;]' as a string, flatten one level&#10;                        return parsed.map(x =&gt; String(x)).join(',');&#10;                    }&#10;                    return String(parsed);&#10;                } catch {&#10;                    return v; // plain string like 'track-rule'&#10;                }&#10;            }&#10;&#10;            // If pg-mem gave us a JS scalar&#10;            if (Array.isArray(v)) {&#10;                // Shouldn't happen here (handled in outer branch), but guard anyway&#10;                return v.map(x =&gt; String(x)).join(',');&#10;            }&#10;            return String(v);&#10;        };&#10;&#10;        if (value == null) return [];&#10;&#10;        // pg-mem jsonb often arrives as real JS arrays&#10;        if (Array.isArray(value)) {&#10;            return value.map(normalizeOne);&#10;        }&#10;&#10;        // Single value paths: wrap into array&#10;        return [normalizeOne(value)];&#10;    }&#10;&#10;    /**&#10;     * Get rows with their applied rules&#10;     * @param targetTable Name of the table to query&#10;     * @param whereConditions Conditions to match rows (optional)&#10;     * @returns Promise that resolves to an array of rows with applied rules&#10;     */&#10;    async getRowsWithAppliedRules&lt;T&gt;(targetTable: string, whereConditions?: Partial&lt;T&gt;): Promise&lt;(T &amp; {&#10;        appliedRules?: string[]&#10;    })[]&gt; {&#10;        if (!this.appliedRulesField) {&#10;            throw new Error('appliedRulesField is not configured. Use setAppliedRulesField() first.');&#10;        }&#10;&#10;        let query = this.db.selectFrom(targetTable).selectAll();&#10;&#10;        // Add WHERE conditions if provided&#10;        if (whereConditions) {&#10;            const matchEntries = Object.entries(whereConditions);&#10;            for (const [key, value] of matchEntries) {&#10;                query = query.where(key, '=', value);&#10;            }&#10;        }&#10;&#10;        const rows = await query.execute();&#10;&#10;        // Parse the applied rules JSON array for each row&#10;        return rows.map(row =&gt; {&#10;            const appliedRulesValue = (row as any)[this.appliedRulesField!];&#10;            return {&#10;                ...row,&#10;                appliedRules: this.normalizeAppliedRules(appliedRulesValue),&#10;            } as T &amp; { appliedRules?: string[] };&#10;        });&#10;    }&#10;}" />
              <option name="updatedContent" value="import {Kysely, sql} from 'kysely';&#10;import {MatchRule} from &quot;@/MatchRule&quot;;&#10;&#10;/**&#10; * PostgreSQL based rule engine that applies match rules to database tables.&#10; * applyRules is the main method to apply multiple rules in a single transaction.&#10; * applyRules always applied given rules without considering previously applied rules.&#10; */&#10;export class PgRulesEngine {&#10;&#10;    /**&#10;     * Additional field name in the target table to track applied rules.&#10;     * For example, appliedRulesField can be set to &quot;appliedRules TEXT[]&quot;, then applied rule&#10;     * will be added to the JSON array in this field. Specified &quot;appliedRules TEXT[]&quot; must be a PostgreSQL TEXT array type.&#10;     *&#10;     * @private&#10;     */&#10;    private appliedRulesField: string | null = null;&#10;&#10;    constructor(private db: Kysely&lt;any&gt;) {&#10;    }&#10;&#10;    /**&#10;     * Set the field name to track applied rules&#10;     * @param fieldName Name of the field to store applied rules&#10;     */&#10;    setAppliedRulesField(fieldName: string): void {&#10;        this.appliedRulesField = fieldName.trim();&#10;    }&#10;&#10;    /**&#10;     * Apply multiple rules to a target table in a single transaction&#10;     * @param rules Array of MatchRule objects to apply&#10;     * @param targetTable Name of the table to apply rules to&#10;     * @returns Promise that resolves to the total number of affected rows&#10;     */&#10;    async applyRules&lt;T&gt;(rules: MatchRule&lt;T&gt;[], targetTable: string): Promise&lt;number&gt; {&#10;        if (!rules.length) {&#10;            return 0;&#10;        }&#10;&#10;        // Sort rules by priority (ascending), defaulting to 0 if not specified&#10;        const sortedRules = [...rules].sort((a, b) =&gt; (a.priority ?? 0) - (b.priority ?? 0));&#10;&#10;        return await this.db.transaction().execute(async (trx) =&gt; {&#10;            let totalAffectedRows = 0;&#10;&#10;            for (const rule of sortedRules) {&#10;                // Build the update query&#10;                let query = trx.updateTable(targetTable);&#10;&#10;                // Add SET clause from apply object&#10;                const applyEntries = Object.entries(rule.apply);&#10;                if (applyEntries.length === 0) {&#10;                    console.warn(`Rule &quot;${rule.ruleName}&quot; has no apply changes, skipping...`);&#10;                    continue; // Skip rules with no apply changes&#10;                }&#10;&#10;                // Start with the apply object changes&#10;                const updateObject: Record&lt;string, any&gt; = {...rule.apply};&#10;&#10;                // Add appliedRulesField tracking if configured&#10;                if (this.appliedRulesField) {&#10;                    // Use PostgreSQL's JSON_ARRAY_APPEND to add the rule name to the JSON array&#10;                    /*language=TEXT*/&#10;                    updateObject[this.appliedRulesField] = sql`JSON_ARRAY_APPEND(COALESCE(${sql.ref(this.appliedRulesField)}, JSON_ARRAY()), '$', ${rule.ruleName})`;&#10;                }&#10;&#10;                query = query.set(updateObject);&#10;&#10;                // Add WHERE clause from match object&#10;                const matchEntries = Object.entries(rule.match);&#10;                if (matchEntries.length === 0) {&#10;                    console.warn(`Rule &quot;${rule.ruleName}&quot; has no match conditions, skipping...`);&#10;                    continue; // Skip rules with no match conditions&#10;                }&#10;&#10;                for (const [key, value] of matchEntries) {&#10;                    if (typeof value === 'string') {&#10;                        // Use PostgreSQL regex operator for case-sensitive string matching&#10;                        //query = query.where(sql.ref(key), '~', value);&#10;                        query = query.where(sql&lt;boolean&gt;`regexp_like(${sql.ref(key)}, ${sql.val(value)})`)&#10;                    } else {&#10;                        // Use direct equality for non-string types&#10;                        query = query.where(sql.ref(key), '=', value);&#10;                    }&#10;                }&#10;&#10;                // Execute the query and get affected row count&#10;                const result = await query.execute();&#10;                // Kysely's execute() returns UpdateResult[], we need the first result's numUpdatedRows&#10;                totalAffectedRows += Number(result[0]?.numUpdatedRows || 0);&#10;            }&#10;&#10;            return totalAffectedRows;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Clear applied rules tracking for rows matching the given conditions&#10;     * @param targetTable Name of the table to clear applied rules from&#10;     * @param whereConditions Conditions to match rows (optional, clears all if not provided)&#10;     * @returns Promise that resolves to the number of affected rows&#10;     */&#10;    async clearAppliedRules&lt;T&gt;(targetTable: string, whereConditions?: Partial&lt;T&gt;): Promise&lt;number&gt; {&#10;        if (!this.appliedRulesField) {&#10;            throw new Error('appliedRulesField is not configured. Use setAppliedRulesField() first.');&#10;        }&#10;&#10;        const updateObject: Record&lt;string, any&gt; = {};&#10;        /*language=TEXT*/&#10;        updateObject[this.appliedRulesField] = sql`JSON_ARRAY()`;&#10;&#10;        let query = this.db.updateTable(targetTable).set(updateObject);&#10;&#10;        // Add WHERE conditions if provided&#10;        if (whereConditions) {&#10;            const matchEntries = Object.entries(whereConditions);&#10;            for (const [key, value] of matchEntries) {&#10;                query = query.where(key, '=', value);&#10;            }&#10;        }&#10;&#10;        const result = await query.execute();&#10;        return Number(result[0]?.numUpdatedRows || 0);&#10;    }&#10;&#10;    private normalizeAppliedRules(value: unknown): string[] {&#10;        const normalizeOne = (v: unknown): string =&gt; {&#10;            if (v == null) return '';&#10;&#10;            // If it's already a JS string, try to JSON-parse it once to strip quotes&#10;            if (typeof v === 'string') {&#10;                // Fast path: JSON string literal like &quot;\&quot;track-rule\&quot;&quot; or '&quot;track-rule&quot;'&#10;                if (v.length &gt;= 2 &amp;&amp; v.startsWith('&quot;') &amp;&amp; v.endsWith('&quot;')) {&#10;                    try {&#10;                        return JSON.parse(v);&#10;                    } catch { /* fall through */&#10;                    }&#10;                    return v.slice(1, -1);&#10;                }&#10;                // Could also be a JSON array/object as string (unlikely here but safe)&#10;                try {&#10;                    const parsed = JSON.parse(v);&#10;                    if (typeof parsed === 'string') return parsed;     // '&quot;track-rule&quot;' -&gt; track-rule&#10;                    if (Array.isArray(parsed)) {&#10;                        // If someone stored '[&quot;a&quot;,&quot;b&quot;]' as a string, flatten one level&#10;                        return parsed.map(x =&gt; String(x)).join(',');&#10;                    }&#10;                    return String(parsed);&#10;                } catch {&#10;                    return v; // plain string like 'track-rule'&#10;                }&#10;            }&#10;&#10;            // If pg-mem gave us a JS scalar&#10;            if (Array.isArray(v)) {&#10;                // Shouldn't happen here (handled in outer branch), but guard anyway&#10;                return v.map(x =&gt; String(x)).join(',');&#10;            }&#10;            return String(v);&#10;        };&#10;&#10;        if (value == null) return [];&#10;&#10;        // pg-mem jsonb often arrives as real JS arrays&#10;        if (Array.isArray(value)) {&#10;            return value.map(normalizeOne);&#10;        }&#10;&#10;        // Single value paths: wrap into array&#10;        return [normalizeOne(value)];&#10;    }&#10;&#10;    /**&#10;     * Get rows with their applied rules&#10;     * @param targetTable Name of the table to query&#10;     * @param whereConditions Conditions to match rows (optional)&#10;     * @returns Promise that resolves to an array of rows with applied rules&#10;     */&#10;    async getRowsWithAppliedRules&lt;T&gt;(targetTable: string, whereConditions?: Partial&lt;T&gt;): Promise&lt;(T &amp; {&#10;        appliedRules?: string[]&#10;    })[]&gt; {&#10;        if (!this.appliedRulesField) {&#10;            throw new Error('appliedRulesField is not configured. Use setAppliedRulesField() first.');&#10;        }&#10;&#10;        let query = this.db.selectFrom(targetTable).selectAll();&#10;&#10;        // Add WHERE conditions if provided&#10;        if (whereConditions) {&#10;            const matchEntries = Object.entries(whereConditions);&#10;            for (const [key, value] of matchEntries) {&#10;                query = query.where(key, '=', value);&#10;            }&#10;        }&#10;&#10;        const rows = await query.execute();&#10;&#10;        // Parse the applied rules JSON array for each row&#10;        return rows.map(row =&gt; {&#10;            const appliedRulesValue = (row as any)[this.appliedRulesField!];&#10;            return {&#10;                ...row,&#10;                appliedRules: this.normalizeAppliedRules(appliedRulesValue),&#10;            } as T &amp; { appliedRules?: string[] };&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/index.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/index.ts" />
              <option name="updatedContent" value="import { Kysely } from 'kysely';&#10;import { MatchRule } from './MatchRule';&#10;&#10;// ...existing code...&#10;&#10;/**&#10; * PostgreSQL based rule engine that applies match rules to database tables&#10; */&#10;export class PgRulesEngine {&#10;  constructor(private db: Kysely&lt;any&gt;) {}&#10;&#10;  /**&#10;   * Apply multiple rules to a target table in a single transaction&#10;   * @param rules Array of MatchRule objects to apply&#10;   * @param targetTable Name of the table to apply rules to&#10;   * @returns Promise that resolves to the total number of affected rows&#10;   */&#10;  async applyRules&lt;T&gt;(rules: MatchRule&lt;T&gt;[], targetTable: string): Promise&lt;number&gt; {&#10;    if (!rules.length) {&#10;      return 0;&#10;    }&#10;&#10;    return await this.db.transaction().execute(async (trx) =&gt; {&#10;      let totalAffectedRows = 0;&#10;&#10;      for (const rule of rules) {&#10;        // Build the update query&#10;        let query = trx.updateTable(targetTable);&#10;&#10;        // Add SET clause from apply object&#10;        const applyEntries = Object.entries(rule.apply);&#10;        if (applyEntries.length === 0) {&#10;          continue; // Skip rules with no apply changes&#10;        }&#10;&#10;        query = query.set(rule.apply);&#10;&#10;        // Add WHERE clause from match object&#10;        const matchEntries = Object.entries(rule.match);&#10;        for (const [key, value] of matchEntries) {&#10;          query = query.where(key, '=', value);&#10;        }&#10;&#10;        // Execute the query and get affected row count&#10;        const result = await query.execute();&#10;        // For Kysely UpdateResult, we access the number of affected rows differently&#10;        totalAffectedRows += Number((result as any).numAffectedRows || 0);&#10;      }&#10;&#10;      return totalAffectedRows;&#10;    });&#10;  }&#10;}&#10;&#10;export function greet(name: string): string {&#10;  return `Hello, ${name}!`;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>