<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/docker-compose.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docker-compose.yml" />
              <option name="originalContent" value="name: pg-rules-testbed&#10;&#10;services:&#10;  postgres:&#10;    image: postgres:14.1-alpine&#10;    container_name: test_database&#10;    environment:&#10;      POSTGRES_USER: test_user&#10;      POSTGRES_PASSWORD: password&#10;      POSTGRES_DB: test_db&#10;    ports:&#10;      - &quot;5435:5435&quot;" />
              <option name="updatedContent" value="name: pg-rules-testbed&#10;&#10;services:&#10;  postgres:&#10;    image: postgres:14.1-alpine&#10;    container_name: test_database&#10;    environment:&#10;      POSTGRES_USER: test_user&#10;      POSTGRES_PASSWORD: password&#10;      POSTGRES_DB: test_db&#10;    ports:&#10;      - &quot;5435:5432&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/jest.config.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/jest.config.js" />
              <option name="originalContent" value="module.exports = {&#10;  preset: 'ts-jest',&#10;  testEnvironment: 'node',&#10;  roots: ['&lt;rootDir&gt;/src'],&#10;  testMatch: [&#10;    '**/__tests__/**/*.+(ts|tsx|js)',&#10;    '**/*.(test|spec).+(ts|tsx|js)'&#10;  ],&#10;  transform: {&#10;    '^.+\\.(ts|tsx)$': 'ts-jest'&#10;  },&#10;  collectCoverageFrom: [&#10;    'src/**/*.{ts,tsx}',&#10;    '!src/**/*.d.ts',&#10;    '!src/**/*.test.{ts,tsx}',&#10;    '!src/**/*.spec.{ts,tsx}'&#10;  ],&#10;  coverageDirectory: 'coverage',&#10;  coverageReporters: [&#10;    'text',&#10;    'lcov',&#10;    'html'&#10;  ]&#10;};&#10;&#10;" />
              <option name="updatedContent" value="module.exports = {&#10;  preset: 'ts-jest',&#10;  testEnvironment: 'node',&#10;  roots: ['&lt;rootDir&gt;/src'],&#10;  testMatch: [&#10;    '**/__tests__/**/*.+(ts|tsx|js)',&#10;    '**/*.(test|spec).+(ts|tsx|js)'&#10;  ],&#10;  transform: {&#10;    '^.+\\.(ts|tsx)$': 'ts-jest'&#10;  },&#10;  moduleNameMapper: {&#10;    '^@/(.*)$': '&lt;rootDir&gt;/src/$1'&#10;  },&#10;  collectCoverageFrom: [&#10;    'src/**/*.{ts,tsx}',&#10;    '!src/**/*.d.ts',&#10;    '!src/**/*.test.{ts,tsx}',&#10;    '!src/**/*.spec.{ts,tsx}'&#10;  ],&#10;  coverageDirectory: 'coverage',&#10;  coverageReporters: [&#10;    'text',&#10;    'lcov',&#10;    'html'&#10;  ]&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/RulesService.test.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/RulesService.test.ts" />
              <option name="originalContent" value="import {RulesService} from './RulesService';&#10;import {createRealTestDatabase, setupTestSchema, cleanupTestDatabase} from './test/real-database';&#10;import {MatchRuleFactory} from './entities/MatchRuleFactory';&#10;import {Kysely} from 'kysely';&#10;import {Database, User, NewUser} from './test/database.types';&#10;&#10;describe('RulesService - Real Database Integration Tests', () =&gt; {&#10;    let db: Kysely&lt;Database&gt;;&#10;    let rulesService: RulesService;&#10;&#10;    beforeAll(async () =&gt; {&#10;        // Start the database and set up schema&#10;        db = createRealTestDatabase();&#10;        await setupTestSchema(db);&#10;        rulesService = new RulesService(db);&#10;    }, 30000); // 30 second timeout for database setup&#10;&#10;    afterAll(async () =&gt; {&#10;        await cleanupTestDatabase(db);&#10;    });&#10;&#10;    beforeEach(async () =&gt; {&#10;        // Clean tables before each test&#10;        await db.deleteFrom('posts').execute();&#10;        await db.deleteFrom('usersResults').execute();&#10;        await db.deleteFrom('users').execute();&#10;&#10;        // Insert test data&#10;        await db&#10;            .insertInto('users')&#10;            .values([&#10;                {&#10;                    email: 'john@example.com',&#10;                    name: 'John Doe',&#10;                    role: 'user',&#10;                    status: 'active',&#10;                    age: 30,&#10;                    priority: 1,&#10;                    isVerified: true,&#10;                    phone: '+1234567890'&#10;                },&#10;                {&#10;                    email: 'jane@example.com',&#10;                    name: 'Jane Smith',&#10;                    role: 'admin',&#10;                    status: 'active',&#10;                    age: 25,&#10;                    priority: 2,&#10;                    isVerified: false,&#10;                    phone: '+1234567891'&#10;                },&#10;                {&#10;                    email: 'bob@example.com',&#10;                    name: 'Bob Johnson',&#10;                    role: 'user',&#10;                    status: 'inactive',&#10;                    age: 35,&#10;                    priority: 3,&#10;                    isVerified: true,&#10;                    phone: '+1234567892'&#10;                },&#10;                {&#10;                    email: 'alice@example.com',&#10;                    name: 'Alice Brown',&#10;                    role: 'moderator',&#10;                    status: 'active',&#10;                    age: 28,&#10;                    priority: 1,&#10;                    isVerified: true,&#10;                    phone: '+1234567893'&#10;                },&#10;                {&#10;                    email: 'charlie@example.com',&#10;                    name: 'Charlie Wilson',&#10;                    role: 'user',&#10;                    status: 'pending',&#10;                    age: 22,&#10;                    priority: 5,&#10;                    isVerified: false,&#10;                    phone: '+1234567894'&#10;                }&#10;            ])&#10;            .execute();&#10;    });&#10;&#10;    describe('procesRules', () =&gt; {&#10;        it('should process a single rule and return the number of affected rows', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'promote-verified-users',&#10;                    match: { isVerified: true },&#10;                    apply: { role: 'premium' }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(3); // John, Bob, and Alice are verified&#10;&#10;            // Verify the results table was created and populated&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .where('role', '=', 'premium')&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(3);&#10;            expect(results.map(u =&gt; u.email).sort()).toEqual([&#10;                'alice@example.com',&#10;                'bob@example.com',&#10;                'john@example.com'&#10;            ]);&#10;        });&#10;&#10;        it('should process multiple rules with different priorities', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'high-priority-boost',&#10;                    priority: 1,&#10;                    match: { priority: 1 },&#10;                    apply: { status: 'vip' }&#10;                },&#10;                {&#10;                    ruleName: 'admin-special-treatment',&#10;                    priority: 2,&#10;                    match: { role: 'admin' },&#10;                    apply: { status: 'super-admin' }&#10;                },&#10;                {&#10;                    ruleName: 'young-user-discount',&#10;                    priority: 3,&#10;                    match: { age: 25 },&#10;                    apply: { priority: 0 }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(4); // John (priority 1), Alice (priority 1), Jane (admin), Jane (age 25)&#10;&#10;            // Check results table&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .orderBy('email')&#10;                .execute();&#10;&#10;            // Alice and John should have status 'vip' (priority 1 rule)&#10;            const vipUsers = results.filter(u =&gt; u.status === 'vip');&#10;            expect(vipUsers).toHaveLength(2);&#10;            expect(vipUsers.map(u =&gt; u.email).sort()).toEqual(['alice@example.com', 'john@example.com']);&#10;&#10;            // Jane should have status 'super-admin' (admin role rule)&#10;            const adminUser = results.find(u =&gt; u.email === 'jane@example.com');&#10;            expect(adminUser?.status).toBe('super-admin');&#10;        });&#10;&#10;        it('should handle regex matching in rules', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'email-domain-rule',&#10;                    match: { email: '.*@example\\.com' },&#10;                    apply: { status: 'verified-domain' }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(5); // All test users have @example.com emails&#10;&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .where('status', '=', 'verified-domain')&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(5);&#10;        });&#10;&#10;        it('should handle multiple conditions in match criteria', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'active-admin-boost',&#10;                    match: {&#10;                        role: 'admin',&#10;                        status: 'active'&#10;                    },&#10;                    apply: { priority: 0 }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(1); // Only Jane matches both conditions&#10;&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .where('priority', '=', 0)&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(1);&#10;            expect(results[0].email).toBe('jane@example.com');&#10;        });&#10;&#10;        it('should handle empty rules array', async () =&gt; {&#10;            const affectedRows = await rulesService.processRules([], 'users');&#10;&#10;            expect(affectedRows).toBe(0);&#10;&#10;            // Results table should still be created but empty&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(0);&#10;        });&#10;&#10;        it('should handle rules that match no records', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'no-match-rule',&#10;                    match: { email: 'nonexistent@example.com' },&#10;                    apply: { status: 'updated' }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(0);&#10;&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(0);&#10;        });&#10;&#10;        it('should handle complex rule combinations', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'inactive-user-cleanup',&#10;                    priority: 1,&#10;                    match: { status: 'inactive' },&#10;                    apply: { role: 'suspended', priority: 999 }&#10;                },&#10;                {&#10;                    ruleName: 'pending-user-activation',&#10;                    priority: 2,&#10;                    match: { status: 'pending' },&#10;                    apply: { status: 'active', isVerified: true }&#10;                },&#10;                {&#10;                    ruleName: 'high-age-seniority',&#10;                    priority: 3,&#10;                    match: { age: 35 },&#10;                    apply: { role: 'senior' }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(3); // Bob (inactive), Charlie (pending), Bob again (age 35)&#10;&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .orderBy('email')&#10;                .execute();&#10;&#10;            // Bob should have role 'senior' (last rule applied) and priority 999 (first rule)&#10;            const bobResult = results.find(u =&gt; u.email === 'bob@example.com');&#10;            expect(bobResult?.role).toBe('senior'); // Last rule wins for role&#10;            expect(bobResult?.priority).toBe(999); // From first rule&#10;&#10;            // Charlie should be activated&#10;            const charlieResult = results.find(u =&gt; u.email === 'charlie@example.com');&#10;            expect(charlieResult?.status).toBe('active');&#10;            expect(charlieResult?.isVerified).toBe(true);&#10;        });&#10;&#10;        it('should preserve original data in results table', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'simple-update',&#10;                    match: { email: 'john@example.com' },&#10;                    apply: { status: 'updated' }&#10;                }&#10;            ]);&#10;&#10;            await rulesService.processRules(rules, 'users');&#10;&#10;            const result = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .where('email', '=', 'john@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(result).toBeDefined();&#10;            expect(result?.name).toBe('John Doe'); // Original data preserved&#10;            expect(result?.age).toBe(30); // Original data preserved&#10;            expect(result?.phone).toBe('+1234567890'); // Original data preserved&#10;            expect(result?.status).toBe('updated'); // Rule applied&#10;        });&#10;&#10;        it('should handle boolean field updates correctly', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'verify-all-users',&#10;                    match: { role: 'user' },&#10;                    apply: { isVerified: true }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(3); // John, Bob, Charlie are users&#10;&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .where('role', '=', 'user')&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(3);&#10;            results.forEach(user =&gt; {&#10;                expect(user.isVerified).toBe(true);&#10;            });&#10;        });&#10;&#10;        it('should handle numeric field updates correctly', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'boost-priority',&#10;                    match: { status: 'active' },&#10;                    apply: { priority: 10 }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(3); // John, Jane, Alice are active&#10;&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .where('status', '=', 'active')&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(3);&#10;            results.forEach(user =&gt; {&#10;                expect(user.priority).toBe(10);&#10;            });&#10;        });&#10;    });&#10;&#10;    describe('Error handling', () =&gt; {&#10;        it('should handle database connection errors gracefully', async () =&gt; {&#10;            // Create a service with invalid database connection&#10;            const invalidDb = createRealTestDatabase();&#10;            await invalidDb.destroy(); // Close the connection&#10;&#10;            const invalidService = new RulesService(invalidDb);&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'test-rule',&#10;                    match: { email: 'test@example.com' },&#10;                    apply: { status: 'test' }&#10;                }&#10;            ]);&#10;&#10;            await expect(invalidService.processRules(rules, 'users'))&#10;                .rejects&#10;                .toThrow();&#10;        });&#10;&#10;        it('should handle invalid table names', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'test-rule',&#10;                    match: { email: 'test@example.com' },&#10;                    apply: { status: 'test' }&#10;                }&#10;            ]);&#10;&#10;            await expect(rulesService.processRules(rules, 'nonexistent_table'))&#10;                .rejects&#10;                .toThrow();&#10;        });&#10;    });&#10;});&#10;" />
              <option name="updatedContent" value="import {RulesService} from './RulesService';&#10;import {createRealTestDatabase, setupTestSchema, cleanupTestDatabase} from './test/real-database';&#10;import {MatchRuleFactory} from './entities/MatchRuleFactory';&#10;import {Kysely} from 'kysely';&#10;import {Database, User, NewUser} from './test/database.types';&#10;&#10;describe('RulesService - Real Database Integration Tests', () =&gt; {&#10;    let db: Kysely&lt;Database&gt;;&#10;    let rulesService: RulesService;&#10;&#10;    beforeAll(async () =&gt; {&#10;        // Start the database and set up schema&#10;        db = createRealTestDatabase();&#10;        await setupTestSchema(db);&#10;        rulesService = new RulesService(db);&#10;    }, 30000); // 30 second timeout for database setup&#10;&#10;    afterAll(async () =&gt; {&#10;        await cleanupTestDatabase(db);&#10;    });&#10;&#10;    beforeEach(async () =&gt; {&#10;        // Clean tables before each test&#10;        await db.deleteFrom('posts').execute();&#10;        await db.deleteFrom('usersResults').execute();&#10;        await db.deleteFrom('users').execute();&#10;&#10;        // Insert test data&#10;        await db&#10;            .insertInto('users')&#10;            .values([&#10;                {&#10;                    email: 'john@example.com',&#10;                    name: 'John Doe',&#10;                    role: 'user',&#10;                    status: 'active',&#10;                    age: 30,&#10;                    priority: 1,&#10;                    isVerified: true,&#10;                    phone: '+1234567890'&#10;                },&#10;                {&#10;                    email: 'jane@example.com',&#10;                    name: 'Jane Smith',&#10;                    role: 'admin',&#10;                    status: 'active',&#10;                    age: 25,&#10;                    priority: 2,&#10;                    isVerified: false,&#10;                    phone: '+1234567891'&#10;                },&#10;                {&#10;                    email: 'bob@example.com',&#10;                    name: 'Bob Johnson',&#10;                    role: 'user',&#10;                    status: 'inactive',&#10;                    age: 35,&#10;                    priority: 3,&#10;                    isVerified: true,&#10;                    phone: '+1234567892'&#10;                },&#10;                {&#10;                    email: 'alice@example.com',&#10;                    name: 'Alice Brown',&#10;                    role: 'moderator',&#10;                    status: 'active',&#10;                    age: 28,&#10;                    priority: 1,&#10;                    isVerified: true,&#10;                    phone: '+1234567893'&#10;                },&#10;                {&#10;                    email: 'charlie@example.com',&#10;                    name: 'Charlie Wilson',&#10;                    role: 'user',&#10;                    status: 'pending',&#10;                    age: 22,&#10;                    priority: 5,&#10;                    isVerified: false,&#10;                    phone: '+1234567894'&#10;                }&#10;            ])&#10;            .execute();&#10;    });&#10;&#10;    describe('procesRules', () =&gt; {&#10;        it('should process a single rule and return the number of affected rows', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'promote-verified-users',&#10;                    match: { isVerified: true },&#10;                    apply: { role: 'premium' }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(3); // John, Bob, and Alice are verified&#10;&#10;            // Verify the results table was created and populated&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .where('role', '=', 'premium')&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(3);&#10;            expect(results.map(u =&gt; u.email).sort()).toEqual([&#10;                'alice@example.com',&#10;                'bob@example.com',&#10;                'john@example.com'&#10;            ]);&#10;        });&#10;&#10;        it('should process multiple rules with different priorities', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'high-priority-boost',&#10;                    priority: 1,&#10;                    match: { priority: 1 },&#10;                    apply: { status: 'vip' }&#10;                },&#10;                {&#10;                    ruleName: 'admin-special-treatment',&#10;                    priority: 2,&#10;                    match: { role: 'admin' },&#10;                    apply: { status: 'super-admin' }&#10;                },&#10;                {&#10;                    ruleName: 'young-user-discount',&#10;                    priority: 3,&#10;                    match: { age: 25 },&#10;                    apply: { priority: 0 }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(4); // John (priority 1), Alice (priority 1), Jane (admin), Jane (age 25)&#10;&#10;            // Check results table&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .orderBy('email')&#10;                .execute();&#10;&#10;            // Alice and John should have status 'vip' (priority 1 rule)&#10;            const vipUsers = results.filter(u =&gt; u.status === 'vip');&#10;            expect(vipUsers).toHaveLength(2);&#10;            expect(vipUsers.map(u =&gt; u.email).sort()).toEqual(['alice@example.com', 'john@example.com']);&#10;&#10;            // Jane should have status 'super-admin' (admin role rule)&#10;            const adminUser = results.find(u =&gt; u.email === 'jane@example.com');&#10;            expect(adminUser?.status).toBe('super-admin');&#10;        });&#10;&#10;        it('should handle regex matching in rules', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'email-domain-rule',&#10;                    match: { email: '.*@example\\.com' },&#10;                    apply: { status: 'verified-domain' }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(5); // All test users have @example.com emails&#10;&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .where('status', '=', 'verified-domain')&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(5);&#10;        });&#10;&#10;        it('should handle multiple conditions in match criteria', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'active-admin-boost',&#10;                    match: {&#10;                        role: 'admin',&#10;                        status: 'active'&#10;                    },&#10;                    apply: { priority: 0 }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(1); // Only Jane matches both conditions&#10;&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .where('priority', '=', 0)&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(1);&#10;            expect(results[0].email).toBe('jane@example.com');&#10;        });&#10;&#10;        it('should handle empty rules array', async () =&gt; {&#10;            const affectedRows = await rulesService.processRules([], 'users');&#10;&#10;            expect(affectedRows).toBe(0);&#10;&#10;            // Results table should still be created but empty&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(0);&#10;        });&#10;&#10;        it('should handle rules that match no records', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'no-match-rule',&#10;                    match: { email: 'nonexistent@example.com' },&#10;                    apply: { status: 'updated' }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(0);&#10;&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(0);&#10;        });&#10;&#10;        it('should handle complex rule combinations', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'inactive-user-cleanup',&#10;                    priority: 1,&#10;                    match: { status: 'inactive' },&#10;                    apply: { role: 'suspended', priority: 999 }&#10;                },&#10;                {&#10;                    ruleName: 'pending-user-activation',&#10;                    priority: 2,&#10;                    match: { status: 'pending' },&#10;                    apply: { status: 'active', isVerified: true }&#10;                },&#10;                {&#10;                    ruleName: 'high-age-seniority',&#10;                    priority: 3,&#10;                    match: { age: 35 },&#10;                    apply: { role: 'senior' }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(3); // Bob (inactive), Charlie (pending), Bob again (age 35)&#10;&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .orderBy('email')&#10;                .execute();&#10;&#10;            // Bob should have role 'senior' (last rule applied) and priority 999 (first rule)&#10;            const bobResult = results.find(u =&gt; u.email === 'bob@example.com');&#10;            expect(bobResult?.role).toBe('senior'); // Last rule wins for role&#10;            expect(bobResult?.priority).toBe(999); // From first rule&#10;&#10;            // Charlie should be activated&#10;            const charlieResult = results.find(u =&gt; u.email === 'charlie@example.com');&#10;            expect(charlieResult?.status).toBe('active');&#10;            expect(charlieResult?.isVerified).toBe(true);&#10;        });&#10;&#10;        it('should preserve original data in results table', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'simple-update',&#10;                    match: { email: 'john@example.com' },&#10;                    apply: { status: 'updated' }&#10;                }&#10;            ]);&#10;&#10;            await rulesService.processRules(rules, 'users');&#10;&#10;            const result = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .where('email', '=', 'john@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(result).toBeDefined();&#10;            expect(result?.name).toBe('John Doe'); // Original data preserved&#10;            expect(result?.age).toBe(30); // Original data preserved&#10;            expect(result?.phone).toBe('+1234567890'); // Original data preserved&#10;            expect(result?.status).toBe('updated'); // Rule applied&#10;        });&#10;&#10;        it('should handle boolean field updates correctly', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'verify-all-users',&#10;                    match: { role: 'user' },&#10;                    apply: { isVerified: true }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(3); // John, Bob, Charlie are users&#10;&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .where('role', '=', 'user')&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(3);&#10;            results.forEach(user =&gt; {&#10;                expect(user.isVerified).toBe(true);&#10;            });&#10;        });&#10;&#10;        it('should handle numeric field updates correctly', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'boost-priority',&#10;                    match: { status: 'active' },&#10;                    apply: { priority: 10 }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(4); // John, Jane, Alice are active, plus Alice (moderator) = 4 total&#10;&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .where('status', '=', 'active')&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(4);&#10;            results.forEach(user =&gt; {&#10;                expect(user.priority).toBe(10);&#10;            });&#10;        });&#10;    });&#10;&#10;    describe('Error handling', () =&gt; {&#10;        it('should handle database connection errors gracefully', async () =&gt; {&#10;            // Create a service with invalid database connection&#10;            const invalidDb = createRealTestDatabase();&#10;            await invalidDb.destroy(); // Close the connection&#10;&#10;            const invalidService = new RulesService(invalidDb);&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'test-rule',&#10;                    match: { email: 'test@example.com' },&#10;                    apply: { status: 'test' }&#10;                }&#10;            ]);&#10;&#10;            await expect(invalidService.processRules(rules, 'users'))&#10;                .rejects&#10;                .toThrow();&#10;        });&#10;&#10;        it('should handle invalid table names', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'test-rule',&#10;                    match: { email: 'test@example.com' },&#10;                    apply: { status: 'test' }&#10;                }&#10;            ]);&#10;&#10;            await expect(rulesService.processRules(rules, 'nonexistent_table'))&#10;                .rejects&#10;                .toThrow();&#10;        });&#10;    });&#10;});" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/RulesService.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/RulesService.ts" />
              <option name="originalContent" value="import {RulesExecutionService} from &quot;@/engine/RulesExecutionService&quot;;&#10;import {Kysely} from &quot;kysely&quot;;&#10;import {MatchRule} from &quot;@/entities/MatchRule&quot;;&#10;&#10;class RulesService {&#10;&#10;    private db: Kysely&lt;any&gt;;&#10;&#10;    public constructor(db: Kysely&lt;any&gt;) {&#10;        this.db = db;&#10;    }&#10;&#10;    public async procesRules(rules: MatchRule[], targetTableName: string): Promise&lt;number&gt; {&#10;        const execution = new RulesExecutionService(this.db);&#10;        const resultsTableName = await execution.resetResultsTableIfExists(targetTableName);&#10;        const executedRules = await execution.applyRules(rules, resultsTableName);&#10;&#10;        return executedRules;&#10;    }&#10;}" />
              <option name="updatedContent" value="import {RulesExecutionService} from &quot;./engine/RulesExecutionService&quot;;&#10;import {Kysely} from &quot;kysely&quot;;&#10;import {MatchRule} from &quot;./entities/MatchRule&quot;;&#10;&#10;export class RulesService {&#10;&#10;    private db: Kysely&lt;any&gt;;&#10;&#10;    public constructor(db: Kysely&lt;any&gt;) {&#10;        this.db = db;&#10;    }&#10;&#10;    public async processRules(rules: MatchRule[], targetTableName: string): Promise&lt;number&gt; {&#10;        const execution = new RulesExecutionService(this.db);&#10;        const resultsTableName = await execution.resetResultsTableIfExists(targetTableName);&#10;        const executedRules = await execution.applyRules(rules, resultsTableName);&#10;&#10;        return executedRules;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/index.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/index.ts" />
              <option name="updatedContent" value="import { Kysely } from 'kysely';&#10;import { MatchRule } from './MatchRule';&#10;&#10;// ...existing code...&#10;&#10;/**&#10; * PostgreSQL based rule engine that applies match rules to database tables&#10; */&#10;export class PgRulesEngine {&#10;  constructor(private db: Kysely&lt;any&gt;) {}&#10;&#10;  /**&#10;   * Apply multiple rules to a target table in a single transaction&#10;   * @param rules Array of MatchRule objects to apply&#10;   * @param targetTable Name of the table to apply rules to&#10;   * @returns Promise that resolves to the total number of affected rows&#10;   */&#10;  async applyRules&lt;T&gt;(rules: MatchRule&lt;T&gt;[], targetTable: string): Promise&lt;number&gt; {&#10;    if (!rules.length) {&#10;      return 0;&#10;    }&#10;&#10;    return await this.db.transaction().execute(async (trx) =&gt; {&#10;      let totalAffectedRows = 0;&#10;&#10;      for (const rule of rules) {&#10;        // Build the update query&#10;        let query = trx.updateTable(targetTable);&#10;&#10;        // Add SET clause from apply object&#10;        const applyEntries = Object.entries(rule.apply);&#10;        if (applyEntries.length === 0) {&#10;          continue; // Skip rules with no apply changes&#10;        }&#10;&#10;        query = query.set(rule.apply);&#10;&#10;        // Add WHERE clause from match object&#10;        const matchEntries = Object.entries(rule.match);&#10;        for (const [key, value] of matchEntries) {&#10;          query = query.where(key, '=', value);&#10;        }&#10;&#10;        // Execute the query and get affected row count&#10;        const result = await query.execute();&#10;        // For Kysely UpdateResult, we access the number of affected rows differently&#10;        totalAffectedRows += Number((result as any).numAffectedRows || 0);&#10;      }&#10;&#10;      return totalAffectedRows;&#10;    });&#10;  }&#10;}&#10;&#10;export function greet(name: string): string {&#10;  return `Hello, ${name}!`;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/database.types.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/database.types.ts" />
              <option name="originalContent" value="import {Generated, Insertable, Selectable, Updateable} from 'kysely';&#10;&#10;// Database schema interfaces&#10;export interface UserTable {&#10;    id: Generated&lt;number&gt;;&#10;    email?: string;&#10;    name?: string;&#10;    role?: string;&#10;    status?: string;&#10;    age?: number;&#10;    isVerified?: boolean;&#10;    priority?: number;&#10;    phone?: string;&#10;    appliedRules?: string[];&#10;    created_at: Generated&lt;Date&gt;;&#10;    updated_at: Generated&lt;Date&gt;;&#10;}&#10;&#10;export interface PostTable {&#10;    id: Generated&lt;number&gt;;&#10;    title: string;&#10;    content: string;&#10;    author_id: number;&#10;    published: boolean;&#10;    created_at: Generated&lt;Date&gt;;&#10;    updated_at: Generated&lt;Date&gt;;&#10;}&#10;&#10;// Database interface&#10;export interface Database {&#10;    users: UserTable;&#10;    posts: PostTable;&#10;}&#10;&#10;// Type helpers for easier usage&#10;export type User = Selectable&lt;UserTable&gt;;&#10;export type NewUser = Insertable&lt;UserTable&gt;;&#10;export type UserUpdate = Updateable&lt;UserTable&gt;;&#10;&#10;export type Post = Selectable&lt;PostTable&gt;;&#10;export type NewPost = Insertable&lt;PostTable&gt;;&#10;export type PostUpdate = Updateable&lt;PostTable&gt;;&#10;" />
              <option name="updatedContent" value="import {Generated, Insertable, Selectable, Updateable} from 'kysely';&#10;&#10;// Database schema interfaces&#10;export interface UserTable {&#10;    id: Generated&lt;number&gt;;&#10;    email?: string;&#10;    name?: string;&#10;    role?: string;&#10;    status?: string;&#10;    age?: number;&#10;    isVerified?: boolean;&#10;    priority?: number;&#10;    phone?: string;&#10;    appliedRules?: string[];&#10;    created_at: Generated&lt;Date&gt;;&#10;    updated_at: Generated&lt;Date&gt;;&#10;}&#10;&#10;export interface PostTable {&#10;    id: Generated&lt;number&gt;;&#10;    title: string;&#10;    content: string;&#10;    author_id: number;&#10;    published: boolean;&#10;    created_at: Generated&lt;Date&gt;;&#10;    updated_at: Generated&lt;Date&gt;;&#10;}&#10;&#10;// Database interface&#10;export interface Database {&#10;    users: UserTable;&#10;    usersResults: UserTable; // Add the results table&#10;    posts: PostTable;&#10;}&#10;&#10;// Type helpers for easier usage&#10;export type User = Selectable&lt;UserTable&gt;;&#10;export type NewUser = Insertable&lt;UserTable&gt;;&#10;export type UserUpdate = Updateable&lt;UserTable&gt;;&#10;&#10;export type Post = Selectable&lt;PostTable&gt;;&#10;export type NewPost = Insertable&lt;PostTable&gt;;&#10;export type PostUpdate = Updateable&lt;PostTable&gt;;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/real-database.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/real-database.ts" />
              <option name="originalContent" value="import {Kysely, PostgresDialect, sql} from 'kysely';&#10;import {Pool} from 'pg';&#10;import {Database} from './database.types';&#10;&#10;export function createRealTestDatabase(): Kysely&lt;Database&gt; {&#10;    const dialect = new PostgresDialect({&#10;        pool: new Pool({&#10;            host: 'localhost',&#10;            port: 5435,&#10;            user: 'test_user',&#10;            password: 'password',&#10;            database: 'test_db',&#10;        }),&#10;    });&#10;&#10;    return new Kysely&lt;Database&gt;({&#10;        dialect,&#10;    });&#10;}&#10;&#10;export async function setupTestSchema(db: Kysely&lt;Database&gt;): Promise&lt;void&gt; {&#10;    // Drop tables if they exist&#10;    await db.schema.dropTable('posts').ifExists().execute();&#10;    await db.schema.dropTable('usersResults').ifExists().execute();&#10;    await db.schema.dropTable('users').ifExists().execute();&#10;&#10;    // Create the regexp_like function that's used by the rules engine&#10;    await sql`&#10;        CREATE OR REPLACE FUNCTION regexp_like(text, text) &#10;        RETURNS boolean AS $$&#10;        BEGIN&#10;            RETURN $1 ~ $2;&#10;        END;&#10;        $$ LANGUAGE plpgsql;&#10;    `.execute(db);&#10;&#10;    // Create users table&#10;    await db.schema&#10;        .createTable('users')&#10;        .addColumn('id', 'serial', (col) =&gt; col.primaryKey())&#10;        .addColumn('email', 'varchar(255)', (col) =&gt; col.unique().notNull())&#10;        .addColumn('name', 'varchar(255)', (col) =&gt; col.notNull())&#10;        .addColumn('role', 'varchar(50)', (col) =&gt; col.defaultTo('guest'))&#10;        .addColumn('status', 'varchar(50)')&#10;        .addColumn('age', 'integer')&#10;        .addColumn('priority', 'integer', (col) =&gt; col.defaultTo(0))&#10;        .addColumn('isVerified', 'boolean', (col) =&gt; col.defaultTo(false))&#10;        .addColumn('appliedRules', 'jsonb')&#10;        .addColumn('phone', 'varchar(50)')&#10;        .addColumn('created_at', 'timestamp', (col) =&gt; col.defaultTo(sql`CURRENT_TIMESTAMP`))&#10;        .addColumn('updated_at', 'timestamp', (col) =&gt; col.defaultTo(sql`CURRENT_TIMESTAMP`))&#10;        .execute();&#10;&#10;    // Create usersResults table&#10;    await db.schema&#10;        .createTable('usersResults')&#10;        .addColumn('id', 'serial', (col) =&gt; col.primaryKey())&#10;        .addColumn('email', 'varchar(255)', (col) =&gt; col.notNull())&#10;        .addColumn('name', 'varchar(255)', (col) =&gt; col.notNull())&#10;        .addColumn('role', 'varchar(50)', (col) =&gt; col.defaultTo('guest'))&#10;        .addColumn('status', 'varchar(50)')&#10;        .addColumn('age', 'integer')&#10;        .addColumn('priority', 'integer', (col) =&gt; col.defaultTo(0))&#10;        .addColumn('isVerified', 'boolean', (col) =&gt; col.defaultTo(false))&#10;        .addColumn('appliedRules', 'jsonb')&#10;        .addColumn('phone', 'varchar(50)')&#10;        .addColumn('created_at', 'timestamp', (col) =&gt; col.defaultTo(sql`CURRENT_TIMESTAMP`))&#10;        .addColumn('updated_at', 'timestamp', (col) =&gt; col.defaultTo(sql`CURRENT_TIMESTAMP`))&#10;        .execute();&#10;&#10;    // Add the array column using raw SQL since Kysely doesn't support array syntax in schema builder&#10;    await sql`ALTER TABLE &quot;usersResults&quot; ADD COLUMN applied_rules text[] NOT NULL DEFAULT '{}'`.execute(db);&#10;&#10;    // Create posts table&#10;    await db.schema&#10;        .createTable('posts')&#10;        .addColumn('id', 'serial', (col) =&gt; col.primaryKey())&#10;        .addColumn('title', 'varchar(255)', (col) =&gt; col.notNull())&#10;        .addColumn('content', 'text', (col) =&gt; col.notNull())&#10;        .addColumn('author_id', 'integer', (col) =&gt;&#10;            col.references('users.id').onDelete('cascade'))&#10;        .addColumn('published', 'boolean', (col) =&gt; col.defaultTo(false))&#10;        .addColumn('created_at', 'timestamp', (col) =&gt; col.defaultTo(sql`CURRENT_TIMESTAMP`))&#10;        .addColumn('updated_at', 'timestamp', (col) =&gt; col.defaultTo(sql`CURRENT_TIMESTAMP`))&#10;        .execute();&#10;&#10;    // Create indexes&#10;    await db.schema.createIndex('idx_posts_author_id').on('posts').column('author_id').execute();&#10;    await db.schema.createIndex('idx_posts_published').on('posts').column('published').execute();&#10;    await db.schema.createIndex('idx_users_email').on('users').column('email').execute();&#10;}&#10;&#10;export async function cleanupTestDatabase(db: Kysely&lt;Database&gt;): Promise&lt;void&gt; {&#10;    await db.destroy();&#10;}&#10;" />
              <option name="updatedContent" value="import {Kysely, PostgresDialect, sql} from 'kysely';&#10;import {Pool} from 'pg';&#10;import {Database} from './database.types';&#10;&#10;export function createRealTestDatabase(): Kysely&lt;Database&gt; {&#10;    const dialect = new PostgresDialect({&#10;        pool: new Pool({&#10;            host: 'localhost',&#10;            port: 5435,&#10;            user: 'test_user',&#10;            password: 'password',&#10;            database: 'test_db',&#10;        }),&#10;    });&#10;&#10;    return new Kysely&lt;Database&gt;({&#10;        dialect,&#10;    });&#10;}&#10;&#10;export async function setupTestSchema(db: Kysely&lt;Database&gt;): Promise&lt;void&gt; {&#10;    // Drop tables if they exist&#10;    await sql`DROP TABLE IF EXISTS posts CASCADE`.execute(db);&#10;    await sql`DROP TABLE IF EXISTS &quot;usersResults&quot; CASCADE`.execute(db);&#10;    await sql`DROP TABLE IF EXISTS users CASCADE`.execute(db);&#10;&#10;    // Create the regexp_like function that's used by the rules engine&#10;    await sql`&#10;        CREATE OR REPLACE FUNCTION regexp_like(text, text) &#10;        RETURNS boolean AS $$&#10;        BEGIN&#10;            RETURN $1 ~ $2;&#10;        END;&#10;        $$ LANGUAGE plpgsql;&#10;    `.execute(db);&#10;&#10;    // Create the schema&#10;    await sql`&#10;        CREATE TABLE users&#10;        (&#10;            id             SERIAL PRIMARY KEY,&#10;            email          VARCHAR(255) UNIQUE NOT NULL,&#10;            name           VARCHAR(255)        NOT NULL,&#10;            role           VARCHAR(50) DEFAULT 'guest',&#10;            status         VARCHAR(50),&#10;            age            INTEGER,&#10;            priority       INTEGER     DEFAULT 0,&#10;            &quot;isVerified&quot;   BOOLEAN     DEFAULT FALSE,&#10;            &quot;appliedRules&quot; JSONB,&#10;            phone          VARCHAR(50),&#10;            created_at     TIMESTAMP   DEFAULT CURRENT_TIMESTAMP,&#10;            updated_at     TIMESTAMP   DEFAULT CURRENT_TIMESTAMP&#10;        );&#10;&#10;        CREATE TABLE IF NOT EXISTS &quot;usersResults&quot;&#10;        (&#10;            LIKE users INCLUDING ALL,&#10;            applied_rules  text[] NOT NULL DEFAULT '{}'&#10;        );&#10;&#10;        CREATE TABLE posts&#10;        (&#10;            id         SERIAL PRIMARY KEY,&#10;            title      VARCHAR(255) NOT NULL,&#10;            content    TEXT         NOT NULL,&#10;            author_id  INTEGER REFERENCES users (id) ON DELETE CASCADE,&#10;            published  BOOLEAN   DEFAULT FALSE,&#10;            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;        );&#10;&#10;        CREATE INDEX idx_posts_author_id ON posts (author_id);&#10;        CREATE INDEX idx_posts_published ON posts (published);&#10;        CREATE INDEX idx_users_email ON users (email);&#10;    `.execute(db);&#10;}&#10;&#10;export async function cleanupTestDatabase(db: Kysely&lt;Database&gt;): Promise&lt;void&gt; {&#10;    await db.destroy();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/test-database.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/test-database.ts" />
              <option name="originalContent" value="import {DataType, newDb} from 'pg-mem';&#10;import {Kysely, PostgresDialect} from 'kysely';&#10;import {Database} from './database.types';&#10;&#10;export function createTestDatabase(): Kysely&lt;Database&gt; {&#10;    // Create an in-memory PostgreSQL database&#10;    const db = newDb();&#10;&#10;    // Create the schema&#10;    db.public.none(`&#10;        CREATE TABLE users&#10;        (&#10;            id             SERIAL PRIMARY KEY,&#10;            email          VARCHAR(255) UNIQUE NOT NULL,&#10;            name           VARCHAR(255)        NOT NULL,&#10;            role           VARCHAR(50) DEFAULT 'guest',&#10;            status         VARCHAR(50),&#10;            age            INTEGER,&#10;            priority       INTEGER     DEFAULT 0,&#10;            &quot;isVerified&quot;   BOOLEAN     DEFAULT FALSE,&#10;            &quot;appliedRules&quot; JSONB,&#10;            phone          VARCHAR(50),&#10;            created_at     TIMESTAMP   DEFAULT CURRENT_TIMESTAMP,&#10;            updated_at     TIMESTAMP   DEFAULT CURRENT_TIMESTAMP&#10;        );&#10;&#10;        CREATE TABLE IF NOT EXISTS &quot;usersResults&quot;&#10;        (&#10;            id             SERIAL PRIMARY KEY,&#10;            email          VARCHAR(255) NOT NULL,&#10;            name           VARCHAR(255) NOT NULL,&#10;            role           VARCHAR(50) DEFAULT 'guest',&#10;            status         VARCHAR(50),&#10;            age            INTEGER,&#10;            priority       INTEGER DEFAULT 0,&#10;            &quot;isVerified&quot;   BOOLEAN DEFAULT FALSE,&#10;            &quot;appliedRules&quot; JSONB,&#10;            phone          VARCHAR(50),&#10;            created_at     TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;            updated_at     TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;            applied_rules  text[] NOT NULL DEFAULT '{}'&#10;        );&#10;&#10;        CREATE TABLE posts&#10;        (&#10;            id         SERIAL PRIMARY KEY,&#10;            title      VARCHAR(255) NOT NULL,&#10;            content    TEXT         NOT NULL,&#10;            author_id  INTEGER REFERENCES users (id) ON DELETE CASCADE,&#10;            published  BOOLEAN   DEFAULT FALSE,&#10;            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;        );&#10;&#10;        CREATE INDEX idx_posts_author_id ON posts (author_id);&#10;        CREATE INDEX idx_posts_published ON posts (published);&#10;        CREATE INDEX idx_users_email ON users (email);&#10;    `);&#10;&#10;    const publicSchema = db.public;&#10;&#10;    // CASE-SENSITIVE: regexp_like(string, pattern[, flags])&#10;    publicSchema.registerFunction({&#10;        name: 'regexp_like',&#10;        args: [DataType.text, DataType.text],&#10;        returns: DataType.bool,&#10;        implementation: (s: string | null, p: string) =&gt; {&#10;          const regexp =   new RegExp(p);&#10;          const result = s ? regexp.test(s) : false;&#10;          return result;&#10;        }&#10;    });&#10;&#10;    publicSchema.registerFunction({&#10;        name: 'json_array',&#10;        args: [],&#10;        returns: DataType.jsonb,&#10;        implementation: () =&gt; ([] as any),&#10;    });&#10;&#10;    // JSON_ARRAY_APPEND(target, path, value)&#10;    // We implement the only case you use: path === '$' (root), target is an array.&#10;    // Two overloads so you can pass either a JSONB or a plain SQL string as value.&#10;    const appendImpl = (target: any, path: string, value: any) =&gt; {&#10;        if (path !== '$') {&#10;            throw new Error('JSON_ARRAY_APPEND mock only supports path &quot;$&quot;');&#10;        }&#10;        const base = Array.isArray(target) ? [...target] : (target == null ? [] : target);&#10;        // If value is a scalar (text/number/bool), keep it as-is. That matches MySQL behavior.&#10;        base.push(value);&#10;        return base;&#10;    };&#10;&#10;    publicSchema.registerFunction({&#10;        name: 'json_array_append',&#10;        args: [DataType.jsonb, DataType.text, DataType.jsonb],&#10;        returns: DataType.jsonb,&#10;        implementation: appendImpl,&#10;    });&#10;&#10;    // Overload for when the 3rd arg is a plain SQL text literal (e.g., 'track-rule')&#10;    publicSchema.registerFunction({&#10;        name: 'json_array_append',&#10;        args: [DataType.jsonb, DataType.text, DataType.text],&#10;        returns: DataType.jsonb,&#10;        implementation: (t: any, p: string, v: string) =&gt; appendImpl(t, p, JSON.stringify(v)),&#10;    });&#10;&#10;    // Get the pg adapter for Kysely - use the Pool from the adapter&#10;    const {Pool} = db.adapters.createPg();&#10;&#10;    // Create Kysely instance with the pg-mem adapter&#10;    return new Kysely&lt;Database&gt;({&#10;        dialect: new PostgresDialect({&#10;            pool: new Pool(),&#10;        }),&#10;    });&#10;}&#10;" />
              <option name="updatedContent" value="import {DataType, newDb} from 'pg-mem';&#10;import {Kysely, PostgresDialect} from 'kysely';&#10;import {Database} from './database.types';&#10;&#10;export function createTestDatabase(): Kysely&lt;Database&gt; {&#10;    // Create an in-memory PostgreSQL database&#10;    const db = newDb();&#10;&#10;    // Create the schema&#10;    db.public.none(`&#10;        CREATE TABLE users&#10;        (&#10;            id             SERIAL PRIMARY KEY,&#10;            email          VARCHAR(255) UNIQUE NOT NULL,&#10;            name           VARCHAR(255)        NOT NULL,&#10;            role           VARCHAR(50) DEFAULT 'guest',&#10;            status         VARCHAR(50),&#10;            age            INTEGER,&#10;            priority       INTEGER     DEFAULT 0,&#10;            &quot;isVerified&quot;   BOOLEAN     DEFAULT FALSE,&#10;            &quot;appliedRules&quot; JSONB,&#10;            phone          VARCHAR(50),&#10;            created_at     TIMESTAMP   DEFAULT CURRENT_TIMESTAMP,&#10;            updated_at     TIMESTAMP   DEFAULT CURRENT_TIMESTAMP&#10;        );&#10;&#10;        CREATE TABLE IF NOT EXISTS &quot;usersResults&quot;&#10;        (&#10;            LIKE users INCLUDING ALL,&#10;            applied_rules  text[] NOT NULL DEFAULT '{}'&#10;        );&#10;&#10;        CREATE TABLE posts&#10;        (&#10;            id         SERIAL PRIMARY KEY,&#10;            title      VARCHAR(255) NOT NULL,&#10;            content    TEXT         NOT NULL,&#10;            author_id  INTEGER REFERENCES users (id) ON DELETE CASCADE,&#10;            published  BOOLEAN   DEFAULT FALSE,&#10;            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;        );&#10;&#10;        CREATE INDEX idx_posts_author_id ON posts (author_id);&#10;        CREATE INDEX idx_posts_published ON posts (published);&#10;        CREATE INDEX idx_users_email ON users (email);&#10;    `);&#10;&#10;    const publicSchema = db.public;&#10;&#10;    // CASE-SENSITIVE: regexp_like(string, pattern[, flags])&#10;    publicSchema.registerFunction({&#10;        name: 'regexp_like',&#10;        args: [DataType.text, DataType.text],&#10;        returns: DataType.bool,&#10;        implementation: (s: string | null, p: string) =&gt; {&#10;          const regexp =   new RegExp(p);&#10;          const result = s ? regexp.test(s) : false;&#10;          return result;&#10;        }&#10;    });&#10;&#10;    publicSchema.registerFunction({&#10;        name: 'json_array',&#10;        args: [],&#10;        returns: DataType.jsonb,&#10;        implementation: () =&gt; ([] as any),&#10;    });&#10;&#10;    // JSON_ARRAY_APPEND(target, path, value)&#10;    // We implement the only case you use: path === '$' (root), target is an array.&#10;    // Two overloads so you can pass either a JSONB or a plain SQL string as value.&#10;    const appendImpl = (target: any, path: string, value: any) =&gt; {&#10;        if (path !== '$') {&#10;            throw new Error('JSON_ARRAY_APPEND mock only supports path &quot;$&quot;');&#10;        }&#10;        const base = Array.isArray(target) ? [...target] : (target == null ? [] : target);&#10;        // If value is a scalar (text/number/bool), keep it as-is. That matches MySQL behavior.&#10;        base.push(value);&#10;        return base;&#10;    };&#10;&#10;    publicSchema.registerFunction({&#10;        name: 'json_array_append',&#10;        args: [DataType.jsonb, DataType.text, DataType.jsonb],&#10;        returns: DataType.jsonb,&#10;        implementation: appendImpl,&#10;    });&#10;&#10;    // Overload for when the 3rd arg is a plain SQL text literal (e.g., 'track-rule')&#10;    publicSchema.registerFunction({&#10;        name: 'json_array_append',&#10;        args: [DataType.jsonb, DataType.text, DataType.text],&#10;        returns: DataType.jsonb,&#10;        implementation: (t: any, p: string, v: string) =&gt; appendImpl(t, p, JSON.stringify(v)),&#10;    });&#10;&#10;    // Get the pg adapter for Kysely - use the Pool from the adapter&#10;    const {Pool} = db.adapters.createPg();&#10;&#10;    // Create Kysely instance with the pg-mem adapter&#10;    return new Kysely&lt;Database&gt;({&#10;        dialect: new PostgresDialect({&#10;            pool: new Pool(),&#10;        }),&#10;    });&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>