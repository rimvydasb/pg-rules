<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.eslintrc.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.eslintrc.js" />
              <option name="updatedContent" value="module.exports = {&#10;  parser: '@typescript-eslint/parser',&#10;  parserOptions: {&#10;    ecmaVersion: 2020,&#10;    sourceType: 'module',&#10;  },&#10;  plugins: ['@typescript-eslint'],&#10;  extends: [&#10;    'eslint:recommended',&#10;    '@typescript-eslint/recommended',&#10;  ],&#10;  rules: {&#10;    '@typescript-eslint/no-unused-vars': 'error',&#10;    '@typescript-eslint/no-explicit-any': 'warn',&#10;    '@typescript-eslint/explicit-function-return-type': 'off',&#10;    '@typescript-eslint/explicit-module-boundary-types': 'off',&#10;    '@typescript-eslint/no-inferrable-types': 'off',&#10;    'prefer-const': 'error',&#10;    'no-var': 'error',&#10;  },&#10;  env: {&#10;    node: true,&#10;    es6: true,&#10;    jest: true,&#10;  },&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/jest.config.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/jest.config.js" />
              <option name="updatedContent" value="module.exports = {&#10;  preset: 'ts-jest',&#10;  testEnvironment: 'node',&#10;  roots: ['&lt;rootDir&gt;/src'],&#10;  testMatch: [&#10;    '**/__tests__/**/*.+(ts|tsx|js)',&#10;    '**/*.(test|spec).+(ts|tsx|js)'&#10;  ],&#10;  transform: {&#10;    '^.+\\.(ts|tsx)$': 'ts-jest'&#10;  },&#10;  collectCoverageFrom: [&#10;    'src/**/*.{ts,tsx}',&#10;    '!src/**/*.d.ts',&#10;    '!src/**/*.test.{ts,tsx}',&#10;    '!src/**/*.spec.{ts,tsx}'&#10;  ],&#10;  coverageDirectory: 'coverage',&#10;  coverageReporters: [&#10;    'text',&#10;    'lcov',&#10;    'html'&#10;  ]&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/package.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/package.json" />
              <option name="originalContent" value="{&#10;  &quot;name&quot;: &quot;pg-rules&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;description&quot;: &quot;PostgreSQL rules project&quot;,&#10;  &quot;main&quot;: &quot;dist/index.js&quot;,&#10;  &quot;scripts&quot;: {&#10;    &quot;build&quot;: &quot;tsc&quot;,&#10;    &quot;start&quot;: &quot;node dist/index.js&quot;,&#10;    &quot;dev&quot;: &quot;ts-node src/index.ts&quot;,&#10;    &quot;test&quot;: &quot;jest&quot;,&#10;    &quot;test:watch&quot;: &quot;jest --watch&quot;,&#10;    &quot;test:coverage&quot;: &quot;jest --coverage&quot;,&#10;    &quot;lint&quot;: &quot;eslint src/**/*.ts&quot;,&#10;    &quot;lint:fix&quot;: &quot;eslint src/**/*.ts --fix&quot;&#10;  },&#10;  &quot;keywords&quot;: [&quot;postgresql&quot;, &quot;rules&quot;, &quot;typescript&quot;],&#10;  &quot;author&quot;: &quot;&quot;,&#10;  &quot;license&quot;: &quot;ISC&quot;,&#10;  &quot;devDependencies&quot;: {&#10;    &quot;@types/jest&quot;: &quot;^29.5.5&quot;,&#10;    &quot;@types/node&quot;: &quot;^20.6.0&quot;,&#10;    &quot;@typescript-eslint/eslint-plugin&quot;: &quot;^6.7.0&quot;,&#10;    &quot;@typescript-eslint/parser&quot;: &quot;^6.7.0&quot;,&#10;    &quot;eslint&quot;: &quot;^8.49.0&quot;,&#10;    &quot;jest&quot;: &quot;^29.7.0&quot;,&#10;    &quot;ts-jest&quot;: &quot;^29.1.1&quot;,&#10;    &quot;ts-node&quot;: &quot;^10.9.1&quot;,&#10;    &quot;typescript&quot;: &quot;^5.2.2&quot;&#10;  },&#10;  &quot;dependencies&quot;: {}&#10;}&#10;&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;name&quot;: &quot;pg-rules&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;description&quot;: &quot;PostgreSQL rules project&quot;,&#10;  &quot;main&quot;: &quot;dist/index.js&quot;,&#10;  &quot;scripts&quot;: {&#10;    &quot;build&quot;: &quot;tsc&quot;,&#10;    &quot;start&quot;: &quot;node dist/index.js&quot;,&#10;    &quot;dev&quot;: &quot;ts-node src/index.ts&quot;,&#10;    &quot;test&quot;: &quot;jest&quot;,&#10;    &quot;test:watch&quot;: &quot;jest --watch&quot;,&#10;    &quot;test:coverage&quot;: &quot;jest --coverage&quot;,&#10;    &quot;lint&quot;: &quot;eslint src/**/*.ts&quot;,&#10;    &quot;lint:fix&quot;: &quot;eslint src/**/*.ts --fix&quot;&#10;  },&#10;  &quot;keywords&quot;: [&quot;postgresql&quot;, &quot;rules&quot;, &quot;typescript&quot;],&#10;  &quot;author&quot;: &quot;&quot;,&#10;  &quot;license&quot;: &quot;ISC&quot;,&#10;  &quot;devDependencies&quot;: {&#10;    &quot;@types/jest&quot;: &quot;^29.5.5&quot;,&#10;    &quot;@types/node&quot;: &quot;^20.6.0&quot;,&#10;    &quot;@typescript-eslint/eslint-plugin&quot;: &quot;^6.7.0&quot;,&#10;    &quot;@typescript-eslint/parser&quot;: &quot;^6.7.0&quot;,&#10;    &quot;eslint&quot;: &quot;^8.49.0&quot;,&#10;    &quot;jest&quot;: &quot;^29.7.0&quot;,&#10;    &quot;ts-jest&quot;: &quot;^29.1.1&quot;,&#10;    &quot;ts-node&quot;: &quot;^10.9.1&quot;,&#10;    &quot;typescript&quot;: &quot;^5.2.2&quot;,&#10;    &quot;@types/pg&quot;: &quot;^8.11.6&quot;,&#10;    &quot;pg-mem&quot;: &quot;^2.8.1&quot;&#10;  },&#10;  &quot;dependencies&quot;: {&#10;    &quot;kysely&quot;: &quot;^0.27.3&quot;,&#10;    &quot;pg&quot;: &quot;^8.11.3&quot;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/database.service.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/database.service.ts" />
              <option name="originalContent" value="import { Kysely } from 'kysely';&#10;import { Database, User, NewUser, Post, NewPost } from './database.types';&#10;&#10;export class DatabaseService {&#10;  constructor(private db: Kysely&lt;Database&gt;) {}&#10;&#10;  // User operations&#10;  async createUser(user: NewUser): Promise&lt;User&gt; {&#10;    return await this.db&#10;      .insertInto('users')&#10;      .values(user)&#10;      .returningAll()&#10;      .executeTakeFirstOrThrow();&#10;  }&#10;&#10;  async getUserById(id: number): Promise&lt;User | undefined&gt; {&#10;    return await this.db&#10;      .selectFrom('users')&#10;      .selectAll()&#10;      .where('id', '=', id)&#10;      .executeTakeFirst();&#10;  }&#10;&#10;  async getUserByEmail(email: string): Promise&lt;User | undefined&gt; {&#10;    return await this.db&#10;      .selectFrom('users')&#10;      .selectAll()&#10;      .where('email', '=', email)&#10;      .executeTakeFirst();&#10;  }&#10;&#10;  async getAllUsers(): Promise&lt;User[]&gt; {&#10;    return await this.db&#10;      .selectFrom('users')&#10;      .selectAll()&#10;      .orderBy('created_at', 'desc')&#10;      .execute();&#10;  }&#10;&#10;  async updateUser(id: number, updates: Partial&lt;NewUser&gt;): Promise&lt;User&gt; {&#10;    return await this.db&#10;      .updateTable('users')&#10;      .set(updates)&#10;      .where('id', '=', id)&#10;      .returningAll()&#10;      .executeTakeFirstOrThrow();&#10;  }&#10;&#10;  async deleteUser(id: number): Promise&lt;void&gt; {&#10;    await this.db&#10;      .deleteFrom('users')&#10;      .where('id', '=', id)&#10;      .execute();&#10;  }&#10;&#10;  // Post operations&#10;  async createPost(post: NewPost): Promise&lt;Post&gt; {&#10;    return await this.db&#10;      .insertInto('posts')&#10;      .values(post)&#10;      .returningAll()&#10;      .executeTakeFirstOrThrow();&#10;  }&#10;&#10;  async getPostById(id: number): Promise&lt;Post | undefined&gt; {&#10;    return await this.db&#10;      .selectFrom('posts')&#10;      .selectAll()&#10;      .where('id', '=', id)&#10;      .executeTakeFirst();&#10;  }&#10;&#10;  async getPostsByAuthor(authorId: number): Promise&lt;Post[]&gt; {&#10;    return await this.db&#10;      .selectFrom('posts')&#10;      .selectAll()&#10;      .where('author_id', '=', authorId)&#10;      .orderBy('created_at', 'desc')&#10;      .execute();&#10;  }&#10;&#10;  async getPublishedPosts(): Promise&lt;Post[]&gt; {&#10;    return await this.db&#10;      .selectFrom('posts')&#10;      .selectAll()&#10;      .where('published', '=', true)&#10;      .orderBy('created_at', 'desc')&#10;      .execute();&#10;  }&#10;&#10;  async publishPost(id: number): Promise&lt;Post&gt; {&#10;    return await this.db&#10;      .updateTable('posts')&#10;      .set({ published: true })&#10;      .where('id', '=', id)&#10;      .returningAll()&#10;      .executeTakeFirstOrThrow();&#10;  }&#10;&#10;  async deletePost(id: number): Promise&lt;void&gt; {&#10;    await this.db&#10;      .deleteFrom('posts')&#10;      .where('id', '=', id)&#10;      .execute();&#10;  }&#10;&#10;  // Complex queries&#10;  async getUsersWithPostCount(): Promise&lt;Array&lt;User &amp; { post_count: number }&gt;&gt; {&#10;    return await this.db&#10;      .selectFrom('users')&#10;      .leftJoin('posts', 'users.id', 'posts.author_id')&#10;      .select([&#10;        'users.id',&#10;        'users.email',&#10;        'users.name',&#10;        'users.created_at',&#10;        'users.updated_at',&#10;        (eb) =&gt; eb.fn.count('posts.id').as('post_count')&#10;      ])&#10;      .groupBy(['users.id', 'users.email', 'users.name', 'users.created_at', 'users.updated_at'])&#10;      .execute() as Promise&lt;Array&lt;User &amp; { post_count: number }&gt;&gt;;&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { Kysely } from 'kysely';&#10;import { Database, User, NewUser, Post, NewPost } from './database.types';&#10;&#10;export class DatabaseService {&#10;  constructor(private db: Kysely&lt;Database&gt;) {}&#10;&#10;  // User operations&#10;  async createUser(user: NewUser): Promise&lt;User&gt; {&#10;    return await this.db&#10;      .insertInto('users')&#10;      .values(user)&#10;      .returningAll()&#10;      .executeTakeFirstOrThrow();&#10;  }&#10;&#10;  async getUserById(id: number): Promise&lt;User | undefined&gt; {&#10;    return await this.db&#10;      .selectFrom('users')&#10;      .selectAll()&#10;      .where('id', '=', id)&#10;      .executeTakeFirst();&#10;  }&#10;&#10;  async getUserByEmail(email: string): Promise&lt;User | undefined&gt; {&#10;    return await this.db&#10;      .selectFrom('users')&#10;      .selectAll()&#10;      .where('email', '=', email)&#10;      .executeTakeFirst();&#10;  }&#10;&#10;  async getAllUsers(): Promise&lt;User[]&gt; {&#10;    return await this.db&#10;      .selectFrom('users')&#10;      .selectAll()&#10;      .orderBy('created_at', 'desc')&#10;      .execute();&#10;  }&#10;&#10;  async updateUser(id: number, updates: Partial&lt;NewUser&gt;): Promise&lt;User&gt; {&#10;    return await this.db&#10;      .updateTable('users')&#10;      .set(updates)&#10;      .where('id', '=', id)&#10;      .returningAll()&#10;      .executeTakeFirstOrThrow();&#10;  }&#10;&#10;  async deleteUser(id: number): Promise&lt;void&gt; {&#10;    await this.db&#10;      .deleteFrom('users')&#10;      .where('id', '=', id)&#10;      .execute();&#10;  }&#10;&#10;  // Post operations&#10;  async createPost(post: NewPost): Promise&lt;Post&gt; {&#10;    return await this.db&#10;      .insertInto('posts')&#10;      .values(post)&#10;      .returningAll()&#10;      .executeTakeFirstOrThrow();&#10;  }&#10;&#10;  async getPostById(id: number): Promise&lt;Post | undefined&gt; {&#10;    return await this.db&#10;      .selectFrom('posts')&#10;      .selectAll()&#10;      .where('id', '=', id)&#10;      .executeTakeFirst();&#10;  }&#10;&#10;  async getPostsByAuthor(authorId: number): Promise&lt;Post[]&gt; {&#10;    return await this.db&#10;      .selectFrom('posts')&#10;      .selectAll()&#10;      .where('author_id', '=', authorId)&#10;      .orderBy('created_at', 'desc')&#10;      .execute();&#10;  }&#10;&#10;  async getPublishedPosts(): Promise&lt;Post[]&gt; {&#10;    return await this.db&#10;      .selectFrom('posts')&#10;      .selectAll()&#10;      .where('published', '=', true)&#10;      .orderBy('created_at', 'desc')&#10;      .execute();&#10;  }&#10;&#10;  async publishPost(id: number): Promise&lt;Post&gt; {&#10;    return await this.db&#10;      .updateTable('posts')&#10;      .set({ published: true })&#10;      .where('id', '=', id)&#10;      .returningAll()&#10;      .executeTakeFirstOrThrow();&#10;  }&#10;&#10;  async deletePost(id: number): Promise&lt;void&gt; {&#10;    await this.db&#10;      .deleteFrom('posts')&#10;      .where('id', '=', id)&#10;      .execute();&#10;  }&#10;&#10;  // Complex queries&#10;  async getUsersWithPostCount(): Promise&lt;Array&lt;User &amp; { post_count: number }&gt;&gt; {&#10;    const result = await this.db&#10;      .selectFrom('users')&#10;      .leftJoin('posts', 'users.id', 'posts.author_id')&#10;      .select([&#10;        'users.id',&#10;        'users.email',&#10;        'users.name',&#10;        'users.created_at',&#10;        'users.updated_at',&#10;        (eb) =&gt; eb.fn.count('posts.id').as('post_count')&#10;      ])&#10;      .groupBy(['users.id', 'users.email', 'users.name', 'users.created_at', 'users.updated_at'])&#10;      .execute();&#10;    &#10;    return result.map(row =&gt; ({&#10;      ...row,&#10;      post_count: Number(row.post_count)&#10;    })) as Array&lt;User &amp; { post_count: number }&gt;;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/database.test.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/database.test.ts" />
              <option name="updatedContent" value="import { Kysely } from 'kysely';&#10;import { Database } from './database.types';&#10;import { DatabaseService } from './database.service';&#10;import { createTestDatabase } from './test-database';&#10;&#10;describe('DatabaseService with Kysely and pg-mem', () =&gt; {&#10;  let db: Kysely&lt;Database&gt;;&#10;  let dbService: DatabaseService;&#10;&#10;  beforeEach(() =&gt; {&#10;    // Create a fresh in-memory database for each test&#10;    db = createTestDatabase();&#10;    dbService = new DatabaseService(db);&#10;  });&#10;&#10;  afterEach(async () =&gt; {&#10;    // Clean up after each test&#10;    await db.destroy();&#10;  });&#10;&#10;  describe('User operations', () =&gt; {&#10;    it('should create a user', async () =&gt; {&#10;      const newUser = {&#10;        email: 'john@example.com',&#10;        name: 'John Doe'&#10;      };&#10;&#10;      const user = await dbService.createUser(newUser);&#10;&#10;      expect(user).toMatchObject({&#10;        id: expect.any(Number),&#10;        email: 'john@example.com',&#10;        name: 'John Doe',&#10;        created_at: expect.any(Date),&#10;        updated_at: expect.any(Date)&#10;      });&#10;      expect(user.id).toBeGreaterThan(0);&#10;    });&#10;&#10;    it('should get user by id', async () =&gt; {&#10;      const newUser = {&#10;        email: 'jane@example.com',&#10;        name: 'Jane Smith'&#10;      };&#10;&#10;      const createdUser = await dbService.createUser(newUser);&#10;      const foundUser = await dbService.getUserById(createdUser.id);&#10;&#10;      expect(foundUser).toEqual(createdUser);&#10;    });&#10;&#10;    it('should get user by email', async () =&gt; {&#10;      const newUser = {&#10;        email: 'alice@example.com',&#10;        name: 'Alice Johnson'&#10;      };&#10;&#10;      const createdUser = await dbService.createUser(newUser);&#10;      const foundUser = await dbService.getUserByEmail('alice@example.com');&#10;&#10;      expect(foundUser).toEqual(createdUser);&#10;    });&#10;&#10;    it('should return undefined for non-existent user', async () =&gt; {&#10;      const user = await dbService.getUserById(999);&#10;      expect(user).toBeUndefined();&#10;    });&#10;&#10;    it('should get all users', async () =&gt; {&#10;      const users = [&#10;        { email: 'user1@example.com', name: 'User One' },&#10;        { email: 'user2@example.com', name: 'User Two' },&#10;        { email: 'user3@example.com', name: 'User Three' }&#10;      ];&#10;&#10;      for (const userData of users) {&#10;        await dbService.createUser(userData);&#10;      }&#10;&#10;      const allUsers = await dbService.getAllUsers();&#10;      expect(allUsers).toHaveLength(3);&#10;      expect(allUsers.map(u =&gt; u.email)).toEqual(&#10;        expect.arrayContaining(['user1@example.com', 'user2@example.com', 'user3@example.com'])&#10;      );&#10;    });&#10;&#10;    it('should update a user', async () =&gt; {&#10;      const newUser = await dbService.createUser({&#10;        email: 'bob@example.com',&#10;        name: 'Bob Wilson'&#10;      });&#10;&#10;      const updatedUser = await dbService.updateUser(newUser.id, {&#10;        name: 'Robert Wilson'&#10;      });&#10;&#10;      expect(updatedUser.name).toBe('Robert Wilson');&#10;      expect(updatedUser.email).toBe('bob@example.com');&#10;      expect(updatedUser.id).toBe(newUser.id);&#10;    });&#10;&#10;    it('should delete a user', async () =&gt; {&#10;      const newUser = await dbService.createUser({&#10;        email: 'delete@example.com',&#10;        name: 'Delete Me'&#10;      });&#10;&#10;      await dbService.deleteUser(newUser.id);&#10;      const foundUser = await dbService.getUserById(newUser.id);&#10;&#10;      expect(foundUser).toBeUndefined();&#10;    });&#10;  });&#10;&#10;  describe('Post operations', () =&gt; {&#10;    let author: any;&#10;&#10;    beforeEach(async () =&gt; {&#10;      author = await dbService.createUser({&#10;        email: 'author@example.com',&#10;        name: 'Post Author'&#10;      });&#10;    });&#10;&#10;    it('should create a post', async () =&gt; {&#10;      const newPost = {&#10;        title: 'My First Post',&#10;        content: 'This is the content of my first post.',&#10;        author_id: author.id,&#10;        published: false&#10;      };&#10;&#10;      const post = await dbService.createPost(newPost);&#10;&#10;      expect(post).toMatchObject({&#10;        id: expect.any(Number),&#10;        title: 'My First Post',&#10;        content: 'This is the content of my first post.',&#10;        author_id: author.id,&#10;        published: false,&#10;        created_at: expect.any(Date),&#10;        updated_at: expect.any(Date)&#10;      });&#10;    });&#10;&#10;    it('should get post by id', async () =&gt; {&#10;      const newPost = await dbService.createPost({&#10;        title: 'Test Post',&#10;        content: 'Test content',&#10;        author_id: author.id,&#10;        published: true&#10;      });&#10;&#10;      const foundPost = await dbService.getPostById(newPost.id);&#10;&#10;      expect(foundPost).toEqual(newPost);&#10;    });&#10;&#10;    it('should get posts by author', async () =&gt; {&#10;      const posts = [&#10;        { title: 'Post 1', content: 'Content 1', author_id: author.id, published: true },&#10;        { title: 'Post 2', content: 'Content 2', author_id: author.id, published: false },&#10;        { title: 'Post 3', content: 'Content 3', author_id: author.id, published: true }&#10;      ];&#10;&#10;      for (const postData of posts) {&#10;        await dbService.createPost(postData);&#10;      }&#10;&#10;      const authorPosts = await dbService.getPostsByAuthor(author.id);&#10;      expect(authorPosts).toHaveLength(3);&#10;      expect(authorPosts.map(p =&gt; p.title)).toEqual(&#10;        expect.arrayContaining(['Post 1', 'Post 2', 'Post 3'])&#10;      );&#10;    });&#10;&#10;    it('should get only published posts', async () =&gt; {&#10;      const posts = [&#10;        { title: 'Published 1', content: 'Content 1', author_id: author.id, published: true },&#10;        { title: 'Draft 1', content: 'Content 2', author_id: author.id, published: false },&#10;        { title: 'Published 2', content: 'Content 3', author_id: author.id, published: true }&#10;      ];&#10;&#10;      for (const postData of posts) {&#10;        await dbService.createPost(postData);&#10;      }&#10;&#10;      const publishedPosts = await dbService.getPublishedPosts();&#10;      expect(publishedPosts).toHaveLength(2);&#10;      expect(publishedPosts.every(p =&gt; p.published)).toBe(true);&#10;      expect(publishedPosts.map(p =&gt; p.title)).toEqual(&#10;        expect.arrayContaining(['Published 1', 'Published 2'])&#10;      );&#10;    });&#10;&#10;    it('should publish a post', async () =&gt; {&#10;      const newPost = await dbService.createPost({&#10;        title: 'Draft Post',&#10;        content: 'This is a draft',&#10;        author_id: author.id,&#10;        published: false&#10;      });&#10;&#10;      const publishedPost = await dbService.publishPost(newPost.id);&#10;&#10;      expect(publishedPost.published).toBe(true);&#10;      expect(publishedPost.id).toBe(newPost.id);&#10;    });&#10;&#10;    it('should delete a post', async () =&gt; {&#10;      const newPost = await dbService.createPost({&#10;        title: 'To Be Deleted',&#10;        content: 'This post will be deleted',&#10;        author_id: author.id,&#10;        published: false&#10;      });&#10;&#10;      await dbService.deletePost(newPost.id);&#10;      const foundPost = await dbService.getPostById(newPost.id);&#10;&#10;      expect(foundPost).toBeUndefined();&#10;    });&#10;  });&#10;&#10;  describe('Complex queries', () =&gt; {&#10;    it('should get users with post count', async () =&gt; {&#10;      // Create users&#10;      const user1 = await dbService.createUser({&#10;        email: 'prolific@example.com',&#10;        name: 'Prolific Writer'&#10;      });&#10;      &#10;      const user2 = await dbService.createUser({&#10;        email: 'casual@example.com',&#10;        name: 'Casual Writer'&#10;      });&#10;&#10;      const user3 = await dbService.createUser({&#10;        email: 'lurker@example.com',&#10;        name: 'Just Lurking'&#10;      });&#10;&#10;      // Create posts&#10;      await dbService.createPost({&#10;        title: 'Post 1',&#10;        content: 'Content 1',&#10;        author_id: user1.id,&#10;        published: true&#10;      });&#10;&#10;      await dbService.createPost({&#10;        title: 'Post 2',&#10;        content: 'Content 2',&#10;        author_id: user1.id,&#10;        published: true&#10;      });&#10;&#10;      await dbService.createPost({&#10;        title: 'Post 3',&#10;        content: 'Content 3',&#10;        author_id: user1.id,&#10;        published: false&#10;      });&#10;&#10;      await dbService.createPost({&#10;        title: 'Single Post',&#10;        content: 'Only post',&#10;        author_id: user2.id,&#10;        published: true&#10;      });&#10;&#10;      // user3 has no posts&#10;&#10;      const usersWithPostCount = await dbService.getUsersWithPostCount();&#10;&#10;      expect(usersWithPostCount).toHaveLength(3);&#10;      &#10;      const prolificUser = usersWithPostCount.find(u =&gt; u.email === 'prolific@example.com');&#10;      const casualUser = usersWithPostCount.find(u =&gt; u.email === 'casual@example.com');&#10;      const lurkerUser = usersWithPostCount.find(u =&gt; u.email === 'lurker@example.com');&#10;&#10;      expect(prolificUser?.post_count).toBe(3);&#10;      expect(casualUser?.post_count).toBe(1);&#10;      expect(lurkerUser?.post_count).toBe(0);&#10;    });&#10;  });&#10;&#10;  describe('Database constraints and relationships', () =&gt; {&#10;    it('should enforce foreign key constraints', async () =&gt; {&#10;      // Try to create a post with non-existent author&#10;      const invalidPost = {&#10;        title: 'Orphaned Post',&#10;        content: 'This post has no valid author',&#10;        author_id: 999, // Non-existent user ID&#10;        published: false&#10;      };&#10;&#10;      await expect(dbService.createPost(invalidPost)).rejects.toThrow();&#10;    });&#10;&#10;    it('should enforce unique email constraint', async () =&gt; {&#10;      await dbService.createUser({&#10;        email: 'unique@example.com',&#10;        name: 'First User'&#10;      });&#10;&#10;      await expect(dbService.createUser({&#10;        email: 'unique@example.com',&#10;        name: 'Second User'&#10;      })).rejects.toThrow();&#10;    });&#10;&#10;    it('should cascade delete posts when user is deleted', async () =&gt; {&#10;      const user = await dbService.createUser({&#10;        email: 'cascade@example.com',&#10;        name: 'User To Delete'&#10;      });&#10;&#10;      const post = await dbService.createPost({&#10;        title: 'Will Be Deleted',&#10;        content: 'This post will be deleted with user',&#10;        author_id: user.id,&#10;        published: true&#10;      });&#10;&#10;      // Delete the user&#10;      await dbService.deleteUser(user.id);&#10;&#10;      // Post should also be deleted due to CASCADE&#10;      const foundPost = await dbService.getPostById(post.id);&#10;      expect(foundPost).toBeUndefined();&#10;    });&#10;  });&#10;});" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/database.types.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/database.types.ts" />
              <option name="updatedContent" value="import { Generated, Insertable, Selectable, Updateable } from 'kysely';&#10;&#10;// Database schema interfaces&#10;export interface UserTable {&#10;  id: Generated&lt;number&gt;;&#10;  email: string;&#10;  name: string;&#10;  created_at: Generated&lt;Date&gt;;&#10;  updated_at: Generated&lt;Date&gt;;&#10;}&#10;&#10;export interface PostTable {&#10;  id: Generated&lt;number&gt;;&#10;  title: string;&#10;  content: string;&#10;  author_id: number;&#10;  published: boolean;&#10;  created_at: Generated&lt;Date&gt;;&#10;  updated_at: Generated&lt;Date&gt;;&#10;}&#10;&#10;// Database interface&#10;export interface Database {&#10;  users: UserTable;&#10;  posts: PostTable;&#10;}&#10;&#10;// Type helpers for easier usage&#10;export type User = Selectable&lt;UserTable&gt;;&#10;export type NewUser = Insertable&lt;UserTable&gt;;&#10;export type UserUpdate = Updateable&lt;UserTable&gt;;&#10;&#10;export type Post = Selectable&lt;PostTable&gt;;&#10;export type NewPost = Insertable&lt;PostTable&gt;;&#10;export type PostUpdate = Updateable&lt;PostTable&gt;;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/index.test.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/index.test.ts" />
              <option name="updatedContent" value="import { Calculator, greet } from './index';&#10;&#10;describe('Calculator', () =&gt; {&#10;  let calculator: Calculator;&#10;&#10;  beforeEach(() =&gt; {&#10;    calculator = new Calculator();&#10;  });&#10;&#10;  describe('add', () =&gt; {&#10;    it('should add two positive numbers correctly', () =&gt; {&#10;      expect(calculator.add(2, 3)).toBe(5);&#10;    });&#10;&#10;    it('should handle negative numbers', () =&gt; {&#10;      expect(calculator.add(-2, 3)).toBe(1);&#10;    });&#10;  });&#10;&#10;  describe('subtract', () =&gt; {&#10;    it('should subtract two numbers correctly', () =&gt; {&#10;      expect(calculator.subtract(5, 3)).toBe(2);&#10;    });&#10;&#10;    it('should handle negative results', () =&gt; {&#10;      expect(calculator.subtract(3, 5)).toBe(-2);&#10;    });&#10;  });&#10;&#10;  describe('multiply', () =&gt; {&#10;    it('should multiply two numbers correctly', () =&gt; {&#10;      expect(calculator.multiply(3, 4)).toBe(12);&#10;    });&#10;&#10;    it('should handle zero multiplication', () =&gt; {&#10;      expect(calculator.multiply(5, 0)).toBe(0);&#10;    });&#10;  });&#10;&#10;  describe('divide', () =&gt; {&#10;    it('should divide two numbers correctly', () =&gt; {&#10;      expect(calculator.divide(10, 2)).toBe(5);&#10;    });&#10;&#10;    it('should throw error when dividing by zero', () =&gt; {&#10;      expect(() =&gt; calculator.divide(10, 0)).toThrow('Division by zero is not allowed');&#10;    });&#10;  });&#10;});&#10;&#10;describe('greet', () =&gt; {&#10;  it('should return a greeting message', () =&gt; {&#10;    expect(greet('World')).toBe('Hello, World!');&#10;  });&#10;&#10;  it('should handle empty string', () =&gt; {&#10;    expect(greet('')).toBe('Hello, !');&#10;  });&#10;});" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/index.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/index.ts" />
              <option name="updatedContent" value="export class Calculator {&#10;  add(a: number, b: number): number {&#10;    return a + b;&#10;  }&#10;&#10;  subtract(a: number, b: number): number {&#10;    return a - b;&#10;  }&#10;&#10;  multiply(a: number, b: number): number {&#10;    return a * b;&#10;  }&#10;&#10;  divide(a: number, b: number): number {&#10;    if (b === 0) {&#10;      throw new Error('Division by zero is not allowed');&#10;    }&#10;    return a / b;&#10;  }&#10;}&#10;&#10;export function greet(name: string): string {&#10;  return `Hello, ${name}!`;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/simple.test.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/simple.test.ts" />
              <option name="updatedContent" value="import { createTestDatabase } from './test-database';&#10;&#10;describe('Simple pg-mem test', () =&gt; {&#10;  it('should create an in-memory database', () =&gt; {&#10;    const db = createTestDatabase();&#10;    expect(db).toBeDefined();&#10;  });&#10;});" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test-database.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test-database.ts" />
              <option name="originalContent" value="import { newDb } from 'pg-mem';&#10;import { Kysely, PostgresDialect } from 'kysely';&#10;import { Database } from './database.types';&#10;&#10;export function createTestDatabase(): Kysely&lt;Database&gt; {&#10;  // Create an in-memory PostgreSQL database&#10;  const db = newDb();&#10;&#10;  // Create the schema&#10;  db.public.none(`&#10;    CREATE TABLE users (&#10;      id SERIAL PRIMARY KEY,&#10;      email VARCHAR(255) UNIQUE NOT NULL,&#10;      name VARCHAR(255) NOT NULL,&#10;      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;    );&#10;&#10;    CREATE TABLE posts (&#10;      id SERIAL PRIMARY KEY,&#10;      title VARCHAR(255) NOT NULL,&#10;      content TEXT NOT NULL,&#10;      author_id INTEGER REFERENCES users(id) ON DELETE CASCADE,&#10;      published BOOLEAN DEFAULT FALSE,&#10;      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;    );&#10;&#10;    CREATE INDEX idx_posts_author_id ON posts(author_id);&#10;    CREATE INDEX idx_posts_published ON posts(published);&#10;    CREATE INDEX idx_users_email ON users(email);&#10;  `);&#10;&#10;  // Get the pg adapter for Kysely&#10;  const pgAdapter = db.adapters.createPg();&#10;&#10;  // Create Kysely instance with the pg-mem adapter&#10;  return new Kysely&lt;Database&gt;({&#10;    dialect: new PostgresDialect({&#10;      pool: pgAdapter,&#10;    }),&#10;  });&#10;}&#10;" />
              <option name="updatedContent" value="import { newDb } from 'pg-mem';&#10;import { Kysely, PostgresDialect } from 'kysely';&#10;import { Database } from './database.types';&#10;&#10;export function createTestDatabase(): Kysely&lt;Database&gt; {&#10;  // Create an in-memory PostgreSQL database&#10;  const db = newDb();&#10;&#10;  // Create the schema&#10;  db.public.none(`&#10;    CREATE TABLE users (&#10;      id SERIAL PRIMARY KEY,&#10;      email VARCHAR(255) UNIQUE NOT NULL,&#10;      name VARCHAR(255) NOT NULL,&#10;      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;    );&#10;&#10;    CREATE TABLE posts (&#10;      id SERIAL PRIMARY KEY,&#10;      title VARCHAR(255) NOT NULL,&#10;      content TEXT NOT NULL,&#10;      author_id INTEGER REFERENCES users(id) ON DELETE CASCADE,&#10;      published BOOLEAN DEFAULT FALSE,&#10;      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,&#10;      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP&#10;    );&#10;&#10;    CREATE INDEX idx_posts_author_id ON posts(author_id);&#10;    CREATE INDEX idx_posts_published ON posts(published);&#10;    CREATE INDEX idx_users_email ON users(email);&#10;  `);&#10;&#10;  // Get the pg adapter for Kysely - use the Pool from the adapter&#10;  const { Pool } = db.adapters.createPg();&#10;&#10;  // Create Kysely instance with the pg-mem adapter&#10;  return new Kysely&lt;Database&gt;({&#10;    dialect: new PostgresDialect({&#10;      pool: new Pool(),&#10;    }),&#10;  });&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tsconfig.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tsconfig.json" />
              <option name="updatedContent" value="{&#10;  &quot;compilerOptions&quot;: {&#10;    &quot;target&quot;: &quot;ES2020&quot;,&#10;    &quot;module&quot;: &quot;commonjs&quot;,&#10;    &quot;lib&quot;: [&quot;ES2020&quot;],&#10;    &quot;outDir&quot;: &quot;./dist&quot;,&#10;    &quot;rootDir&quot;: &quot;./src&quot;,&#10;    &quot;strict&quot;: true,&#10;    &quot;esModuleInterop&quot;: true,&#10;    &quot;skipLibCheck&quot;: true,&#10;    &quot;forceConsistentCasingInFileNames&quot;: true,&#10;    &quot;declaration&quot;: true,&#10;    &quot;declarationMap&quot;: true,&#10;    &quot;sourceMap&quot;: true,&#10;    &quot;removeComments&quot;: true,&#10;    &quot;noImplicitAny&quot;: true,&#10;    &quot;strictNullChecks&quot;: true,&#10;    &quot;strictFunctionTypes&quot;: true,&#10;    &quot;noImplicitThis&quot;: true,&#10;    &quot;noImplicitReturns&quot;: true,&#10;    &quot;noFallthroughCasesInSwitch&quot;: true,&#10;    &quot;moduleResolution&quot;: &quot;node&quot;,&#10;    &quot;baseUrl&quot;: &quot;./&quot;,&#10;    &quot;paths&quot;: {&#10;      &quot;@/*&quot;: [&quot;src/*&quot;]&#10;    }&#10;  },&#10;  &quot;include&quot;: [&#10;    &quot;src/**/*&quot;&#10;  ],&#10;  &quot;exclude&quot;: [&#10;    &quot;node_modules&quot;,&#10;    &quot;dist&quot;,&#10;    &quot;**/*.test.ts&quot;,&#10;    &quot;**/*.spec.ts&quot;&#10;  ]&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>