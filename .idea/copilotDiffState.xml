<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.eslintrc.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.eslintrc.js" />
              <option name="updatedContent" value="module.exports = {&#10;  parser: '@typescript-eslint/parser',&#10;  parserOptions: {&#10;    ecmaVersion: 2020,&#10;    sourceType: 'module',&#10;  },&#10;  plugins: ['@typescript-eslint'],&#10;  extends: [&#10;    'eslint:recommended',&#10;    '@typescript-eslint/recommended',&#10;  ],&#10;  rules: {&#10;    '@typescript-eslint/no-unused-vars': 'error',&#10;    '@typescript-eslint/no-explicit-any': 'warn',&#10;    '@typescript-eslint/explicit-function-return-type': 'off',&#10;    '@typescript-eslint/explicit-module-boundary-types': 'off',&#10;    '@typescript-eslint/no-inferrable-types': 'off',&#10;    'prefer-const': 'error',&#10;    'no-var': 'error',&#10;  },&#10;  env: {&#10;    node: true,&#10;    es6: true,&#10;    jest: true,&#10;  },&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/jest.config.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/jest.config.js" />
              <option name="updatedContent" value="module.exports = {&#10;  preset: 'ts-jest',&#10;  testEnvironment: 'node',&#10;  roots: ['&lt;rootDir&gt;/src'],&#10;  testMatch: [&#10;    '**/__tests__/**/*.+(ts|tsx|js)',&#10;    '**/*.(test|spec).+(ts|tsx|js)'&#10;  ],&#10;  transform: {&#10;    '^.+\\.(ts|tsx)$': 'ts-jest'&#10;  },&#10;  collectCoverageFrom: [&#10;    'src/**/*.{ts,tsx}',&#10;    '!src/**/*.d.ts',&#10;    '!src/**/*.test.{ts,tsx}',&#10;    '!src/**/*.spec.{ts,tsx}'&#10;  ],&#10;  coverageDirectory: 'coverage',&#10;  coverageReporters: [&#10;    'text',&#10;    'lcov',&#10;    'html'&#10;  ]&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/package.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/package.json" />
              <option name="originalContent" value="{&#10;  &quot;name&quot;: &quot;pg-rules&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;description&quot;: &quot;PostgreSQL rules project&quot;,&#10;  &quot;main&quot;: &quot;dist/index.js&quot;,&#10;  &quot;scripts&quot;: {&#10;    &quot;build&quot;: &quot;tsc&quot;,&#10;    &quot;start&quot;: &quot;node dist/index.js&quot;,&#10;    &quot;dev&quot;: &quot;ts-node src/index.ts&quot;,&#10;    &quot;test&quot;: &quot;jest&quot;,&#10;    &quot;test:watch&quot;: &quot;jest --watch&quot;,&#10;    &quot;test:coverage&quot;: &quot;jest --coverage&quot;,&#10;    &quot;lint&quot;: &quot;eslint src/**/*.ts&quot;,&#10;    &quot;lint:fix&quot;: &quot;eslint src/**/*.ts --fix&quot;&#10;  },&#10;  &quot;keywords&quot;: [&quot;postgresql&quot;, &quot;rules&quot;, &quot;typescript&quot;],&#10;  &quot;author&quot;: &quot;&quot;,&#10;  &quot;license&quot;: &quot;ISC&quot;,&#10;  &quot;devDependencies&quot;: {&#10;    &quot;@types/jest&quot;: &quot;^29.5.5&quot;,&#10;    &quot;@types/node&quot;: &quot;^20.6.0&quot;,&#10;    &quot;@typescript-eslint/eslint-plugin&quot;: &quot;^6.7.0&quot;,&#10;    &quot;@typescript-eslint/parser&quot;: &quot;^6.7.0&quot;,&#10;    &quot;eslint&quot;: &quot;^8.49.0&quot;,&#10;    &quot;jest&quot;: &quot;^29.7.0&quot;,&#10;    &quot;ts-jest&quot;: &quot;^29.1.1&quot;,&#10;    &quot;ts-node&quot;: &quot;^10.9.1&quot;,&#10;    &quot;typescript&quot;: &quot;^5.2.2&quot;&#10;  },&#10;  &quot;dependencies&quot;: {}&#10;}&#10;&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;name&quot;: &quot;pg-rules&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;description&quot;: &quot;PostgreSQL rules project&quot;,&#10;  &quot;main&quot;: &quot;dist/index.js&quot;,&#10;  &quot;scripts&quot;: {&#10;    &quot;build&quot;: &quot;tsc&quot;,&#10;    &quot;start&quot;: &quot;node dist/index.js&quot;,&#10;    &quot;dev&quot;: &quot;ts-node src/index.ts&quot;,&#10;    &quot;test&quot;: &quot;jest&quot;,&#10;    &quot;test:watch&quot;: &quot;jest --watch&quot;,&#10;    &quot;test:coverage&quot;: &quot;jest --coverage&quot;,&#10;    &quot;lint&quot;: &quot;eslint src/**/*.ts&quot;,&#10;    &quot;lint:fix&quot;: &quot;eslint src/**/*.ts --fix&quot;&#10;  },&#10;  &quot;keywords&quot;: [&quot;postgresql&quot;, &quot;rules&quot;, &quot;typescript&quot;],&#10;  &quot;author&quot;: &quot;&quot;,&#10;  &quot;license&quot;: &quot;ISC&quot;,&#10;  &quot;devDependencies&quot;: {&#10;    &quot;@types/jest&quot;: &quot;^29.5.5&quot;,&#10;    &quot;@types/node&quot;: &quot;^20.6.0&quot;,&#10;    &quot;@typescript-eslint/eslint-plugin&quot;: &quot;^6.7.0&quot;,&#10;    &quot;@typescript-eslint/parser&quot;: &quot;^6.7.0&quot;,&#10;    &quot;eslint&quot;: &quot;^8.49.0&quot;,&#10;    &quot;jest&quot;: &quot;^29.7.0&quot;,&#10;    &quot;ts-jest&quot;: &quot;^29.1.1&quot;,&#10;    &quot;ts-node&quot;: &quot;^10.9.1&quot;,&#10;    &quot;typescript&quot;: &quot;^5.2.2&quot;,&#10;    &quot;@types/pg&quot;: &quot;^8.11.6&quot;,&#10;    &quot;pg-mem&quot;: &quot;^2.8.1&quot;&#10;  },&#10;  &quot;dependencies&quot;: {&#10;    &quot;kysely&quot;: &quot;^0.27.3&quot;,&#10;    &quot;pg&quot;: &quot;^8.11.3&quot;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/PgRulesEngine.test.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/PgRulesEngine.test.ts" />
              <option name="originalContent" value="import { createTestDatabase } from './test-database';&#10;import { PgRulesEngine } from './PgRulesEngine';&#10;import { MatchRule } from './MatchRule';&#10;import { User, NewUser } from './database.types';&#10;&#10;describe('PgRulesEngine', () =&gt; {&#10;  let db: any;&#10;  let rulesEngine: PgRulesEngine;&#10;&#10;  beforeEach(async () =&gt; {&#10;    db = createTestDatabase();&#10;    rulesEngine = new PgRulesEngine(db);&#10;&#10;    // Insert test users&#10;    await db&#10;      .insertInto('users')&#10;      .values([&#10;        { email: 'john@example.com', name: 'John Doe' },&#10;        { email: 'jane@example.com', name: 'Jane Smith' },&#10;        { email: 'bob@example.com', name: 'Bob Johnson' },&#10;        { email: 'alice@example.com', name: 'Alice Brown' },&#10;      ])&#10;      .execute();&#10;  });&#10;&#10;  describe('applyRules', () =&gt; {&#10;    it('should apply a single rule to update user names', async () =&gt; {&#10;      // Create a rule to update John's name&#10;      const rule = new MatchRule&lt;User&gt;(&#10;        'update-john-name',&#10;        { email: 'john@example.com' },&#10;        { name: 'John Updated' }&#10;      );&#10;&#10;      const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;      expect(affectedRows).toBe(1);&#10;&#10;      // Verify the update was applied&#10;      const updatedUser = await db&#10;        .selectFrom('users')&#10;        .selectAll()&#10;        .where('email', '=', 'john@example.com')&#10;        .executeTakeFirst();&#10;&#10;      expect(updatedUser.name).toBe('John Updated');&#10;    });&#10;&#10;    it('should apply multiple rules in a single transaction', async () =&gt; {&#10;      const rules = [&#10;        new MatchRule&lt;User&gt;(&#10;          'update-john',&#10;          { email: 'john@example.com' },&#10;          { name: 'John Modified' }&#10;        ),&#10;        new MatchRule&lt;User&gt;(&#10;          'update-jane',&#10;          { email: 'jane@example.com' },&#10;          { name: 'Jane Modified' }&#10;        ),&#10;      ];&#10;&#10;      const affectedRows = await rulesEngine.applyRules(rules, 'users');&#10;&#10;      expect(affectedRows).toBe(2);&#10;&#10;      // Verify both updates were applied&#10;      const users = await db&#10;        .selectFrom('users')&#10;        .selectAll()&#10;        .where('email', 'in', ['john@example.com', 'jane@example.com'])&#10;        .execute();&#10;&#10;      expect(users).toHaveLength(2);&#10;      expect(users.find((u: User) =&gt; u.email === 'john@example.com')?.name).toBe('John Modified');&#10;      expect(users.find((u: User) =&gt; u.email === 'jane@example.com')?.name).toBe('Jane Modified');&#10;    });&#10;&#10;    it('should handle rules with multiple match conditions', async () =&gt; {&#10;      // First, update one user to have a specific name&#10;      await db&#10;        .updateTable('users')&#10;        .set({ name: 'Target User' })&#10;        .where('email', '=', 'bob@example.com')&#10;        .execute();&#10;&#10;      const rule = new MatchRule&lt;User&gt;(&#10;        'update-specific-user',&#10;        { email: 'bob@example.com', name: 'Target User' },&#10;        { name: 'Updated Target User' }&#10;      );&#10;&#10;      const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;      expect(affectedRows).toBe(1);&#10;&#10;      const updatedUser = await db&#10;        .selectFrom('users')&#10;        .selectAll()&#10;        .where('email', '=', 'bob@example.com')&#10;        .executeTakeFirst();&#10;&#10;      expect(updatedUser.name).toBe('Updated Target User');&#10;    });&#10;&#10;    it('should return 0 when no rules match any records', async () =&gt; {&#10;      const rule = new MatchRule&lt;User&gt;(&#10;        'update-nonexistent',&#10;        { email: 'nonexistent@example.com' },&#10;        { name: 'Should Not Update' }&#10;      );&#10;&#10;      const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;      expect(affectedRows).toBe(0);&#10;&#10;      // Verify no users were changed&#10;      const allUsers = await db&#10;        .selectFrom('users')&#10;        .selectAll()&#10;        .execute();&#10;&#10;      expect(allUsers).toHaveLength(4);&#10;      expect(allUsers.every((u: User) =&gt; !u.name.includes('Should Not Update'))).toBe(true);&#10;    });&#10;&#10;    it('should return 0 when given an empty rules array', async () =&gt; {&#10;      const affectedRows = await rulesEngine.applyRules([], 'users');&#10;&#10;      expect(affectedRows).toBe(0);&#10;    });&#10;&#10;    it('should skip rules with empty apply objects', async () =&gt; {&#10;      const rules = [&#10;        new MatchRule&lt;User&gt;(&#10;          'empty-apply',&#10;          { email: 'john@example.com' },&#10;          {} // Empty apply object&#10;        ),&#10;        new MatchRule&lt;User&gt;(&#10;          'valid-rule',&#10;          { email: 'jane@example.com' },&#10;          { name: 'Jane Updated' }&#10;        ),&#10;      ];&#10;&#10;      const affectedRows = await rulesEngine.applyRules(rules, 'users');&#10;&#10;      expect(affectedRows).toBe(1); // Only the valid rule should be applied&#10;&#10;      // Verify only Jane was updated&#10;      const john = await db&#10;        .selectFrom('users')&#10;        .selectAll()&#10;        .where('email', '=', 'john@example.com')&#10;        .executeTakeFirst();&#10;&#10;      const jane = await db&#10;        .selectFrom('users')&#10;        .selectAll()&#10;        .where('email', '=', 'jane@example.com')&#10;        .executeTakeFirst();&#10;&#10;      expect(john.name).toBe('John Doe'); // Unchanged&#10;      expect(jane.name).toBe('Jane Updated'); // Changed&#10;    });&#10;&#10;    it('should handle rules that update multiple fields', async () =&gt; {&#10;      const rule = new MatchRule&lt;User&gt;(&#10;        'update-multiple-fields',&#10;        { email: 'alice@example.com' },&#10;        {&#10;          name: 'Alice Updated',&#10;          email: 'alice.updated@example.com'&#10;        }&#10;      );&#10;&#10;      const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;      expect(affectedRows).toBe(1);&#10;&#10;      // Verify both fields were updated&#10;      const updatedUser = await db&#10;        .selectFrom('users')&#10;        .selectAll()&#10;        .where('email', '=', 'alice.updated@example.com')&#10;        .executeTakeFirst();&#10;&#10;      expect(updatedUser).toBeDefined();&#10;      expect(updatedUser.name).toBe('Alice Updated');&#10;      expect(updatedUser.email).toBe('alice.updated@example.com');&#10;    });&#10;&#10;    it('should maintain transaction integrity on error', async () =&gt; {&#10;      // Create a rule that will cause a constraint violation&#10;      const rules = [&#10;        new MatchRule&lt;User&gt;(&#10;          'valid-update',&#10;          { email: 'john@example.com' },&#10;          { name: 'John Updated First' }&#10;        ),&#10;        new MatchRule&lt;User&gt;(&#10;          'duplicate-email',&#10;          { email: 'jane@example.com' },&#10;          { email: 'john@example.com' } // This will cause a unique constraint violation&#10;        ),&#10;      ];&#10;&#10;      try {&#10;        // This should fail due to unique constraint violation&#10;        await rulesEngine.applyRules(rules, 'users');&#10;        // If we get here, the constraint wasn't enforced, which is okay for pg-mem&#10;        // Just verify that at least one rule was applied&#10;        const john = await db&#10;          .selectFrom('users')&#10;          .selectAll()&#10;          .where('email', '=', 'john@example.com')&#10;          .executeTakeFirst();&#10;&#10;        // In pg-mem, the first rule might succeed before the second fails&#10;        expect(john.name).toBeDefined();&#10;      } catch (error) {&#10;        // If an error was thrown, verify that no changes were made (transaction was rolled back)&#10;        const john = await db&#10;          .selectFrom('users')&#10;          .selectAll()&#10;          .where('email', '=', 'john@example.com')&#10;          .executeTakeFirst();&#10;&#10;        expect(john.name).toBe('John Doe'); // Should be unchanged due to rollback&#10;      }&#10;    });&#10;  });&#10;});&#10;" />
              <option name="updatedContent" value="import { createTestDatabase } from './test-database';&#10;import { PgRulesEngine } from './PgRulesEngine';&#10;import { MatchRule } from './MatchRule';&#10;import { User, NewUser } from './database.types';&#10;&#10;describe('PgRulesEngine', () =&gt; {&#10;  let db: any;&#10;  let rulesEngine: PgRulesEngine;&#10;&#10;  beforeEach(async () =&gt; {&#10;    db = createTestDatabase();&#10;    rulesEngine = new PgRulesEngine(db);&#10;&#10;    // Insert test users&#10;    await db&#10;      .insertInto('users')&#10;      .values([&#10;        { email: 'john@example.com', name: 'John Doe' },&#10;        { email: 'jane@example.com', name: 'Jane Smith' },&#10;        { email: 'bob@example.com', name: 'Bob Johnson' },&#10;        { email: 'alice@example.com', name: 'Alice Brown' },&#10;      ])&#10;      .execute();&#10;  });&#10;&#10;  describe('applyRules', () =&gt; {&#10;    it('should apply a single rule to update user names', async () =&gt; {&#10;      // Create a rule to update John's name&#10;      const rule = new MatchRule&lt;User&gt;(&#10;        'update-john-name',&#10;        { email: 'john@example.com' },&#10;        { name: 'John Updated' }&#10;      );&#10;&#10;      const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;      expect(affectedRows).toBe(1);&#10;&#10;      // Verify the update was applied&#10;      const updatedUser = await db&#10;        .selectFrom('users')&#10;        .selectAll()&#10;        .where('email', '=', 'john@example.com')&#10;        .executeTakeFirst();&#10;&#10;      expect(updatedUser.name).toBe('John Updated');&#10;    });&#10;&#10;    it('should apply multiple rules in a single transaction', async () =&gt; {&#10;      const rules = [&#10;        new MatchRule&lt;User&gt;(&#10;          'update-john',&#10;          { email: 'john@example.com' },&#10;          { name: 'John Modified' }&#10;        ),&#10;        new MatchRule&lt;User&gt;(&#10;          'update-jane',&#10;          { email: 'jane@example.com' },&#10;          { name: 'Jane Modified' }&#10;        ),&#10;      ];&#10;&#10;      const affectedRows = await rulesEngine.applyRules(rules, 'users');&#10;&#10;      expect(affectedRows).toBe(2);&#10;&#10;      // Verify both updates were applied&#10;      const users = await db&#10;        .selectFrom('users')&#10;        .selectAll()&#10;        .where('email', 'in', ['john@example.com', 'jane@example.com'])&#10;        .execute();&#10;&#10;      expect(users).toHaveLength(2);&#10;      expect(users.find((u: User) =&gt; u.email === 'john@example.com')?.name).toBe('John Modified');&#10;      expect(users.find((u: User) =&gt; u.email === 'jane@example.com')?.name).toBe('Jane Modified');&#10;    });&#10;&#10;    it('should handle rules with multiple match conditions', async () =&gt; {&#10;      // First, update one user to have a specific name&#10;      await db&#10;        .updateTable('users')&#10;        .set({ name: 'Target User' })&#10;        .where('email', '=', 'bob@example.com')&#10;        .execute();&#10;&#10;      const rule = new MatchRule&lt;User&gt;(&#10;        'update-specific-user',&#10;        { email: 'bob@example.com', name: 'Target User' },&#10;        { name: 'Updated Target User' }&#10;      );&#10;&#10;      const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;      expect(affectedRows).toBe(1);&#10;&#10;      const updatedUser = await db&#10;        .selectFrom('users')&#10;        .selectAll()&#10;        .where('email', '=', 'bob@example.com')&#10;        .executeTakeFirst();&#10;&#10;      expect(updatedUser.name).toBe('Updated Target User');&#10;    });&#10;&#10;    it('should return 0 when no rules match any records', async () =&gt; {&#10;      const rule = new MatchRule&lt;User&gt;(&#10;        'update-nonexistent',&#10;        { email: 'nonexistent@example.com' },&#10;        { name: 'Should Not Update' }&#10;      );&#10;&#10;      const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;      expect(affectedRows).toBe(0);&#10;&#10;      // Verify no users were changed&#10;      const allUsers = await db&#10;        .selectFrom('users')&#10;        .selectAll()&#10;        .execute();&#10;&#10;      expect(allUsers).toHaveLength(4);&#10;      expect(allUsers.every((u: User) =&gt; !u.name.includes('Should Not Update'))).toBe(true);&#10;    });&#10;&#10;    it('should return 0 when given an empty rules array', async () =&gt; {&#10;      const affectedRows = await rulesEngine.applyRules([], 'users');&#10;&#10;      expect(affectedRows).toBe(0);&#10;    });&#10;&#10;    it('should skip rules with empty apply objects', async () =&gt; {&#10;      const rules = [&#10;        new MatchRule&lt;User&gt;(&#10;          'empty-apply',&#10;          { email: 'john@example.com' },&#10;          {} // Empty apply object&#10;        ),&#10;        new MatchRule&lt;User&gt;(&#10;          'valid-rule',&#10;          { email: 'jane@example.com' },&#10;          { name: 'Jane Updated' }&#10;        ),&#10;      ];&#10;&#10;      const affectedRows = await rulesEngine.applyRules(rules, 'users');&#10;&#10;      expect(affectedRows).toBe(1); // Only the valid rule should be applied&#10;&#10;      // Verify only Jane was updated&#10;      const john = await db&#10;        .selectFrom('users')&#10;        .selectAll()&#10;        .where('email', '=', 'john@example.com')&#10;        .executeTakeFirst();&#10;&#10;      const jane = await db&#10;        .selectFrom('users')&#10;        .selectAll()&#10;        .where('email', '=', 'jane@example.com')&#10;        .executeTakeFirst();&#10;&#10;      expect(john.name).toBe('John Doe'); // Unchanged&#10;      expect(jane.name).toBe('Jane Updated'); // Changed&#10;    });&#10;&#10;    it('should handle rules that update multiple fields', async () =&gt; {&#10;      const rule = new MatchRule&lt;User&gt;(&#10;        'update-multiple-fields',&#10;        { email: 'alice@example.com' },&#10;        {&#10;          name: 'Alice Updated',&#10;          email: 'alice.updated@example.com'&#10;        }&#10;      );&#10;&#10;      const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;      expect(affectedRows).toBe(1);&#10;&#10;      // Verify both fields were updated&#10;      const updatedUser = await db&#10;        .selectFrom('users')&#10;        .selectAll()&#10;        .where('email', '=', 'alice.updated@example.com')&#10;        .executeTakeFirst();&#10;&#10;      expect(updatedUser).toBeDefined();&#10;      expect(updatedUser.name).toBe('Alice Updated');&#10;      expect(updatedUser.email).toBe('alice.updated@example.com');&#10;    });&#10;&#10;    it('should maintain transaction integrity on error', async () =&gt; {&#10;      // Create a rule that will cause a constraint violation by trying to set an invalid value&#10;      const rules = [&#10;        new MatchRule&lt;User&gt;(&#10;          'valid-update',&#10;          { email: 'john@example.com' },&#10;          { name: 'John Updated First' }&#10;        ),&#10;        new MatchRule&lt;User&gt;(&#10;          'invalid-update',&#10;          { email: 'jane@example.com' },&#10;          { email: null as any } // This should cause a NOT NULL constraint violation&#10;        ),&#10;      ];&#10;&#10;      try {&#10;        // This should fail due to constraint violation&#10;        await rulesEngine.applyRules(rules, 'users');&#10;        &#10;        // If no error was thrown, it means pg-mem allows the operation&#10;        // In this case, just verify the transaction completed normally&#10;        const john = await db&#10;          .selectFrom('users')&#10;          .selectAll()&#10;          .where('email', '=', 'john@example.com')&#10;          .executeTakeFirst();&#10;        &#10;        expect(john.name).toBe('John Updated First');&#10;      } catch (error) {&#10;        // If an error was thrown, verify that the transaction was rolled back&#10;        const john = await db&#10;          .selectFrom('users')&#10;          .selectAll()&#10;          .where('email', '=', 'john@example.com')&#10;          .executeTakeFirst();&#10;&#10;        expect(john.name).toBe('John Doe'); // Should be unchanged due to rollback&#10;      }&#10;    });&#10;  });&#10;});" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/PgRulesEngine.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/PgRulesEngine.ts" />
              <option name="originalContent" value="import {Kysely} from 'kysely';&#10;import {MatchRule} from &quot;@/MatchRule&quot;;&#10;&#10;/**&#10; * PostgreSQL based rule engine that applies match rules to database tables&#10; */&#10;export class PgRulesEngine {&#10;  constructor(private db: Kysely&lt;any&gt;) {}&#10;&#10;  /**&#10;   * Apply multiple rules to a target table in a single transaction&#10;   * @param rules Array of MatchRule objects to apply&#10;   * @param targetTable Name of the table to apply rules to&#10;   * @returns Promise that resolves to the total number of affected rows&#10;   */&#10;  async applyRules&lt;T&gt;(rules: MatchRule&lt;T&gt;[], targetTable: string): Promise&lt;number&gt; {&#10;    if (!rules.length) {&#10;      return 0;&#10;    }&#10;&#10;    return await this.db.transaction().execute(async (trx) =&gt; {&#10;      let totalAffectedRows = 0;&#10;&#10;      for (const rule of rules) {&#10;        // Build the update query&#10;        let query = trx.updateTable(targetTable);&#10;&#10;        // Add SET clause from apply object&#10;        const applyEntries = Object.entries(rule.apply);&#10;        if (applyEntries.length === 0) {&#10;          continue; // Skip rules with no apply changes&#10;        }&#10;&#10;        query = query.set(rule.apply);&#10;&#10;        // Add WHERE clause from match object&#10;        const matchEntries = Object.entries(rule.match);&#10;        for (const [key, value] of matchEntries) {&#10;          query = query.where(key, '=', value);&#10;        }&#10;&#10;        // Execute the query and get affected row count&#10;        const result = await query.execute();&#10;        // Kysely's UpdateResult has numUpdatedRows as BigInt, convert to number&#10;        totalAffectedRows += Number(result.numUpdatedRows || 0n);&#10;      }&#10;&#10;      return totalAffectedRows;&#10;    });&#10;  }&#10;}" />
              <option name="updatedContent" value="import {Kysely} from 'kysely';&#10;import {MatchRule} from &quot;@/MatchRule&quot;;&#10;&#10;/**&#10; * PostgreSQL based rule engine that applies match rules to database tables&#10; */&#10;export class PgRulesEngine {&#10;  constructor(private db: Kysely&lt;any&gt;) {}&#10;&#10;  /**&#10;   * Apply multiple rules to a target table in a single transaction&#10;   * @param rules Array of MatchRule objects to apply&#10;   * @param targetTable Name of the table to apply rules to&#10;   * @returns Promise that resolves to the total number of affected rows&#10;   */&#10;  async applyRules&lt;T&gt;(rules: MatchRule&lt;T&gt;[], targetTable: string): Promise&lt;number&gt; {&#10;    if (!rules.length) {&#10;      return 0;&#10;    }&#10;&#10;    return await this.db.transaction().execute(async (trx) =&gt; {&#10;      let totalAffectedRows = 0;&#10;&#10;      for (const rule of rules) {&#10;        // Build the update query&#10;        let query = trx.updateTable(targetTable);&#10;&#10;        // Add SET clause from apply object&#10;        const applyEntries = Object.entries(rule.apply);&#10;        if (applyEntries.length === 0) {&#10;          continue; // Skip rules with no apply changes&#10;        }&#10;&#10;        query = query.set(rule.apply);&#10;&#10;        // Add WHERE clause from match object&#10;        const matchEntries = Object.entries(rule.match);&#10;        for (const [key, value] of matchEntries) {&#10;          query = query.where(key, '=', value);&#10;        }&#10;&#10;        // Execute the query and get affected row count&#10;        const result = await query.execute();&#10;        // Kysely's execute() returns UpdateResult[], we need the first result's numUpdatedRows&#10;        totalAffectedRows += Number(result[0]?.numUpdatedRows || 0);&#10;      }&#10;&#10;      return totalAffectedRows;&#10;    });&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/index.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/index.ts" />
              <option name="originalContent" value="import { Kysely } from 'kysely';&#10;&#10;/**&#10; * Represents a match rule that can be applied to database records&#10; */&#10;export class MatchRule&lt;T = any&gt; {&#10;  public readonly ruleName: string;&#10;  public readonly match: Partial&lt;T&gt;;&#10;  public readonly apply: Partial&lt;T&gt;;&#10;&#10;  constructor(ruleName: string, match: Partial&lt;T&gt;, apply: Partial&lt;T&gt;) {&#10;    this.ruleName = ruleName;&#10;    this.match = match;&#10;    this.apply = apply;&#10;  }&#10;}&#10;&#10;/**&#10; * PostgreSQL based rule engine that applies match rules to database tables&#10; */&#10;export class PgRulesEngine {&#10;  constructor(private db: Kysely&lt;any&gt;) {}&#10;&#10;  /**&#10;   * Apply multiple rules to a target table in a single transaction&#10;   * @param rules Array of MatchRule objects to apply&#10;   * @param targetTable Name of the table to apply rules to&#10;   * @returns Promise that resolves to the total number of affected rows&#10;   */&#10;  async applyRules&lt;T&gt;(rules: MatchRule&lt;T&gt;[], targetTable: string): Promise&lt;number&gt; {&#10;    if (!rules.length) {&#10;      return 0;&#10;    }&#10;&#10;    return await this.db.transaction().execute(async (trx) =&gt; {&#10;      let totalAffectedRows = 0;&#10;&#10;      for (const rule of rules) {&#10;        // Build the update query&#10;        let query = trx.updateTable(targetTable);&#10;&#10;        // Add SET clause from apply object&#10;        const applyEntries = Object.entries(rule.apply);&#10;        if (applyEntries.length === 0) {&#10;          continue; // Skip rules with no apply changes&#10;        }&#10;&#10;        query = query.set(rule.apply);&#10;&#10;        // Add WHERE clause from match object&#10;        const matchEntries = Object.entries(rule.match);&#10;        for (const [key, value] of matchEntries) {&#10;          query = query.where(key, '=', value);&#10;        }&#10;&#10;        // Execute the query and get affected row count&#10;        const result = await query.execute();&#10;        totalAffectedRows += Number(result.numUpdatedRows || 0);&#10;      }&#10;&#10;      return totalAffectedRows;&#10;    });&#10;  }&#10;}&#10;&#10;export function greet(name: string): string {&#10;  return `Hello, ${name}!`;&#10;}&#10;" />
              <option name="updatedContent" value="import { Kysely } from 'kysely';&#10;&#10;/**&#10; * Represents a match rule that can be applied to database records&#10; */&#10;export class MatchRule&lt;T = any&gt; {&#10;  public readonly ruleName: string;&#10;  public readonly match: Partial&lt;T&gt;;&#10;  public readonly apply: Partial&lt;T&gt;;&#10;&#10;  constructor(ruleName: string, match: Partial&lt;T&gt;, apply: Partial&lt;T&gt;) {&#10;    this.ruleName = ruleName;&#10;    this.match = match;&#10;    this.apply = apply;&#10;  }&#10;}&#10;&#10;/**&#10; * PostgreSQL based rule engine that applies match rules to database tables&#10; */&#10;export class PgRulesEngine {&#10;  constructor(private db: Kysely&lt;any&gt;) {}&#10;&#10;  /**&#10;   * Apply multiple rules to a target table in a single transaction&#10;   * @param rules Array of MatchRule objects to apply&#10;   * @param targetTable Name of the table to apply rules to&#10;   * @returns Promise that resolves to the total number of affected rows&#10;   */&#10;  async applyRules&lt;T&gt;(rules: MatchRule&lt;T&gt;[], targetTable: string): Promise&lt;number&gt; {&#10;    if (!rules.length) {&#10;      return 0;&#10;    }&#10;&#10;    return await this.db.transaction().execute(async (trx) =&gt; {&#10;      let totalAffectedRows = 0;&#10;&#10;      for (const rule of rules) {&#10;        // Build the update query&#10;        let query = trx.updateTable(targetTable);&#10;&#10;        // Add SET clause from apply object&#10;        const applyEntries = Object.entries(rule.apply);&#10;        if (applyEntries.length === 0) {&#10;          continue; // Skip rules with no apply changes&#10;        }&#10;&#10;        query = query.set(rule.apply);&#10;&#10;        // Add WHERE clause from match object&#10;        const matchEntries = Object.entries(rule.match);&#10;        for (const [key, value] of matchEntries) {&#10;          query = query.where(key, '=', value);&#10;        }&#10;&#10;        // Execute the query and get affected row count&#10;        const result = await query.execute();&#10;        // For Kysely UpdateResult, we access the number of affected rows differently&#10;        totalAffectedRows += Number((result as any).numUpdatedRows || 0);&#10;      }&#10;&#10;      return totalAffectedRows;&#10;    });&#10;  }&#10;}&#10;&#10;export function greet(name: string): string {&#10;  return `Hello, ${name}!`;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tsconfig.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tsconfig.json" />
              <option name="updatedContent" value="{&#10;  &quot;compilerOptions&quot;: {&#10;    &quot;target&quot;: &quot;ES2020&quot;,&#10;    &quot;module&quot;: &quot;commonjs&quot;,&#10;    &quot;lib&quot;: [&quot;ES2020&quot;],&#10;    &quot;outDir&quot;: &quot;./dist&quot;,&#10;    &quot;rootDir&quot;: &quot;./src&quot;,&#10;    &quot;strict&quot;: true,&#10;    &quot;esModuleInterop&quot;: true,&#10;    &quot;skipLibCheck&quot;: true,&#10;    &quot;forceConsistentCasingInFileNames&quot;: true,&#10;    &quot;declaration&quot;: true,&#10;    &quot;declarationMap&quot;: true,&#10;    &quot;sourceMap&quot;: true,&#10;    &quot;removeComments&quot;: true,&#10;    &quot;noImplicitAny&quot;: true,&#10;    &quot;strictNullChecks&quot;: true,&#10;    &quot;strictFunctionTypes&quot;: true,&#10;    &quot;noImplicitThis&quot;: true,&#10;    &quot;noImplicitReturns&quot;: true,&#10;    &quot;noFallthroughCasesInSwitch&quot;: true,&#10;    &quot;moduleResolution&quot;: &quot;node&quot;,&#10;    &quot;baseUrl&quot;: &quot;./&quot;,&#10;    &quot;paths&quot;: {&#10;      &quot;@/*&quot;: [&quot;src/*&quot;]&#10;    }&#10;  },&#10;  &quot;include&quot;: [&#10;    &quot;src/**/*&quot;&#10;  ],&#10;  &quot;exclude&quot;: [&#10;    &quot;node_modules&quot;,&#10;    &quot;dist&quot;,&#10;    &quot;**/*.test.ts&quot;,&#10;    &quot;**/*.spec.ts&quot;&#10;  ]&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>