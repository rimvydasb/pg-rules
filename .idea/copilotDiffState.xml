<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/jest.config.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/jest.config.js" />
              <option name="updatedContent" value="module.exports = {&#10;  preset: 'ts-jest',&#10;  testEnvironment: 'node',&#10;  roots: ['&lt;rootDir&gt;/src'],&#10;  testMatch: [&#10;    '**/__tests__/**/*.+(ts|tsx|js)',&#10;    '**/*.(test|spec).+(ts|tsx|js)'&#10;  ],&#10;  transform: {&#10;    '^.+\\.(ts|tsx)$': 'ts-jest'&#10;  },&#10;  collectCoverageFrom: [&#10;    'src/**/*.{ts,tsx}',&#10;    '!src/**/*.d.ts',&#10;    '!src/**/*.test.{ts,tsx}',&#10;    '!src/**/*.spec.{ts,tsx}'&#10;  ],&#10;  coverageDirectory: 'coverage',&#10;  coverageReporters: [&#10;    'text',&#10;    'lcov',&#10;    'html'&#10;  ]&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/package.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/package.json" />
              <option name="originalContent" value="{&#10;  &quot;name&quot;: &quot;pg-rules&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;description&quot;: &quot;PostgreSQL rules project&quot;,&#10;  &quot;main&quot;: &quot;dist/index.js&quot;,&#10;  &quot;scripts&quot;: {&#10;    &quot;build&quot;: &quot;tsc&quot;,&#10;    &quot;start&quot;: &quot;node dist/index.js&quot;,&#10;    &quot;dev&quot;: &quot;ts-node src/index.ts&quot;,&#10;    &quot;test&quot;: &quot;jest&quot;,&#10;    &quot;test:watch&quot;: &quot;jest --watch&quot;,&#10;    &quot;test:coverage&quot;: &quot;jest --coverage&quot;,&#10;    &quot;lint&quot;: &quot;eslint src/**/*.ts&quot;,&#10;    &quot;lint:fix&quot;: &quot;eslint src/**/*.ts --fix&quot;&#10;  },&#10;  &quot;keywords&quot;: [&quot;postgresql&quot;, &quot;rules&quot;, &quot;typescript&quot;],&#10;  &quot;author&quot;: &quot;&quot;,&#10;  &quot;license&quot;: &quot;ISC&quot;,&#10;  &quot;devDependencies&quot;: {&#10;    &quot;@types/jest&quot;: &quot;^29.5.5&quot;,&#10;    &quot;@types/node&quot;: &quot;^20.6.0&quot;,&#10;    &quot;@typescript-eslint/eslint-plugin&quot;: &quot;^6.7.0&quot;,&#10;    &quot;@typescript-eslint/parser&quot;: &quot;^6.7.0&quot;,&#10;    &quot;eslint&quot;: &quot;^8.49.0&quot;,&#10;    &quot;jest&quot;: &quot;^29.7.0&quot;,&#10;    &quot;ts-jest&quot;: &quot;^29.1.1&quot;,&#10;    &quot;ts-node&quot;: &quot;^10.9.1&quot;,&#10;    &quot;typescript&quot;: &quot;^5.2.2&quot;&#10;}&#10;  &quot;dependencies&quot;: {}&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;name&quot;: &quot;pg-rules&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;description&quot;: &quot;PostgreSQL rules project&quot;,&#10;  &quot;main&quot;: &quot;dist/index.js&quot;,&#10;  &quot;scripts&quot;: {&#10;    &quot;build&quot;: &quot;tsc&quot;,&#10;    &quot;start&quot;: &quot;node dist/index.js&quot;,&#10;    &quot;dev&quot;: &quot;ts-node src/index.ts&quot;,&#10;    &quot;test&quot;: &quot;jest&quot;,&#10;    &quot;test:watch&quot;: &quot;jest --watch&quot;,&#10;    &quot;test:coverage&quot;: &quot;jest --coverage&quot;,&#10;    &quot;lint&quot;: &quot;eslint src/**/*.ts&quot;,&#10;    &quot;lint:fix&quot;: &quot;eslint src/**/*.ts --fix&quot;&#10;  },&#10;  &quot;keywords&quot;: [&quot;postgresql&quot;, &quot;rules&quot;, &quot;typescript&quot;],&#10;  &quot;author&quot;: &quot;&quot;,&#10;  &quot;license&quot;: &quot;ISC&quot;,&#10;  &quot;devDependencies&quot;: {&#10;    &quot;@types/jest&quot;: &quot;^29.5.5&quot;,&#10;    &quot;@types/node&quot;: &quot;^20.6.0&quot;,&#10;    &quot;@typescript-eslint/eslint-plugin&quot;: &quot;^6.7.0&quot;,&#10;    &quot;@typescript-eslint/parser&quot;: &quot;^6.7.0&quot;,&#10;    &quot;eslint&quot;: &quot;^8.49.0&quot;,&#10;    &quot;jest&quot;: &quot;^29.7.0&quot;,&#10;    &quot;ts-jest&quot;: &quot;^29.1.1&quot;,&#10;    &quot;ts-node&quot;: &quot;^10.9.1&quot;,&#10;    &quot;typescript&quot;: &quot;^5.2.2&quot;,&#10;    &quot;@types/pg&quot;: &quot;^8.11.6&quot;,&#10;    &quot;pg-mem&quot;: &quot;^2.8.1&quot;&#10;  },&#10;  &quot;dependencies&quot;: {&#10;    &quot;kysely&quot;: &quot;^0.27.3&quot;,&#10;    &quot;pg&quot;: &quot;^8.11.3&quot;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/MatchRuleFactory.test.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/MatchRuleFactory.test.ts" />
              <option name="originalContent" value="import { MatchRule } from './MatchRule';&#10;import { User } from './database.types';&#10;import {MatchRuleFactory} from &quot;./MatchRuleFactory&quot;;&#10;&#10;describe('MatchRuleFactory', () =&gt; {&#10;  describe('create', () =&gt; {&#10;    it('should create a MatchRule from valid JSON object', () =&gt; {&#10;      const json = {&#10;        ruleName: 'test-rule',&#10;        match: { email: 'test@example.com' },&#10;        apply: { name: 'Updated Name' }&#10;      };&#10;&#10;      const rule = MatchRuleFactory.create&lt;User&gt;(json);&#10;&#10;      expect(rule.ruleName).toBe('test-rule');&#10;      expect(rule.match).toEqual({ email: 'test@example.com' });&#10;      expect(rule.apply).toEqual({ name: 'Updated Name' });&#10;    });&#10;&#10;    it('should trim whitespace from rule name', () =&gt; {&#10;      const json = {&#10;        ruleName: '  test-rule  ',&#10;        match: { email: 'test@example.com' },&#10;        apply: { name: 'Updated Name' }&#10;      };&#10;&#10;      const rule = MatchRuleFactory.create&lt;User&gt;(json);&#10;&#10;      expect(rule.ruleName).toBe('test-rule');&#10;    });&#10;&#10;    it('should throw error for null or undefined input', () =&gt; {&#10;      expect(() =&gt; MatchRuleFactory.create(null)).toThrow('Invalid rule object provided');&#10;      expect(() =&gt; MatchRuleFactory.create(undefined)).toThrow('Invalid rule object provided');&#10;    });&#10;&#10;    it('should throw error for invalid rule name', () =&gt; {&#10;      const json = {&#10;        ruleName: '',&#10;        match: { email: 'test@example.com' },&#10;        apply: { name: 'Updated Name' }&#10;      };&#10;&#10;      expect(() =&gt; MatchRuleFactory.create(json)).toThrow('Rule name must be a non-empty string');&#10;    });&#10;&#10;    it('should throw error for non-string rule name', () =&gt; {&#10;      const json = {&#10;        ruleName: 123,&#10;        match: { email: 'test@example.com' },&#10;        apply: { name: 'Updated Name' }&#10;      };&#10;&#10;      expect(() =&gt; MatchRuleFactory.create(json)).toThrow('Rule name must be a non-empty string');&#10;    });&#10;&#10;    it('should throw error for missing match object', () =&gt; {&#10;      const json = {&#10;        ruleName: 'test-rule',&#10;        apply: { name: 'Updated Name' }&#10;      };&#10;&#10;      expect(() =&gt; MatchRuleFactory.create(json)).toThrow('Match object must be provided and be an object');&#10;    });&#10;&#10;    it('should throw error for invalid match object', () =&gt; {&#10;      const json = {&#10;        ruleName: 'test-rule',&#10;        match: 'invalid',&#10;        apply: { name: 'Updated Name' }&#10;      };&#10;&#10;      expect(() =&gt; MatchRuleFactory.create(json)).toThrow('Match object must be provided and be an object');&#10;    });&#10;&#10;    it('should throw error for missing apply object', () =&gt; {&#10;      const json = {&#10;        ruleName: 'test-rule',&#10;        match: { email: 'test@example.com' }&#10;      };&#10;&#10;      expect(() =&gt; MatchRuleFactory.create(json)).toThrow('Apply object must be provided and be an object');&#10;    });&#10;&#10;    it('should throw error for invalid apply object', () =&gt; {&#10;      const json = {&#10;        ruleName: 'test-rule',&#10;        match: { email: 'test@example.com' },&#10;        apply: 'invalid'&#10;      };&#10;&#10;      expect(() =&gt; MatchRuleFactory.create(json)).toThrow('Apply object must be provided and be an object');&#10;    });&#10;  });&#10;&#10;  describe('createRule', () =&gt; {&#10;    it('should create a MatchRule with direct parameters', () =&gt; {&#10;      const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;        'direct-rule',&#10;        { email: 'test@example.com' },&#10;        { name: 'Direct Update' }&#10;      );&#10;&#10;      expect(rule.ruleName).toBe('direct-rule');&#10;      expect(rule.match).toEqual({ email: 'test@example.com' });&#10;      expect(rule.apply).toEqual({ name: 'Direct Update' });&#10;    });&#10;&#10;    it('should trim whitespace from rule name', () =&gt; {&#10;      const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;        '  direct-rule  ',&#10;        { email: 'test@example.com' },&#10;        { name: 'Direct Update' }&#10;      );&#10;&#10;      expect(rule.ruleName).toBe('direct-rule');&#10;    });&#10;&#10;    it('should throw error for invalid rule name', () =&gt; {&#10;      expect(() =&gt; MatchRuleFactory.createRule('', {}, {})).toThrow('Rule name must be a non-empty string');&#10;      expect(() =&gt; MatchRuleFactory.createRule(null as any, {}, {})).toThrow('Rule name must be a non-empty string');&#10;      expect(() =&gt; MatchRuleFactory.createRule(123 as any, {}, {})).toThrow('Rule name must be a non-empty string');&#10;    });&#10;&#10;    it('should throw error for invalid match object', () =&gt; {&#10;      expect(() =&gt; MatchRuleFactory.createRule('test', null as any, {})).toThrow('Match object must be provided and be an object');&#10;      expect(() =&gt; MatchRuleFactory.createRule('test', 'invalid' as any, {})).toThrow('Match object must be provided and be an object');&#10;    });&#10;&#10;    it('should throw error for invalid apply object', () =&gt; {&#10;      expect(() =&gt; MatchRuleFactory.createRule('test', {}, null as any)).toThrow('Apply object must be provided and be an object');&#10;      expect(() =&gt; MatchRuleFactory.createRule('test', {}, 'invalid' as any)).toThrow('Apply object must be provided and be an object');&#10;    });&#10;&#10;    it('should handle complex match and apply objects', () =&gt; {&#10;      const match = { email: 'test@example.com', name: 'John Doe' };&#10;      const apply = { name: 'Jane Doe', email: 'jane@example.com' };&#10;&#10;      const rule = MatchRuleFactory.createRule&lt;User&gt;('complex-rule', match, apply);&#10;&#10;      expect(rule.ruleName).toBe('complex-rule');&#10;      expect(rule.match).toEqual(match);&#10;      expect(rule.apply).toEqual(apply);&#10;    });&#10;  });&#10;});&#10;" />
              <option name="updatedContent" value="import { MatchRule } from './MatchRule';&#10;import { User } from './database.types';&#10;import {MatchRuleFactory} from &quot;./MatchRuleFactory&quot;;&#10;&#10;describe('MatchRuleFactory', () =&gt; {&#10;  describe('create', () =&gt; {&#10;    it('should create a MatchRule from valid JSON object', () =&gt; {&#10;      const json = {&#10;        ruleName: 'test-rule',&#10;        match: { email: 'test@example.com' },&#10;        apply: { name: 'Updated Name' }&#10;      };&#10;&#10;      const rule = MatchRuleFactory.create&lt;User&gt;(json);&#10;&#10;      expect(rule.ruleName).toBe('test-rule');&#10;      expect(rule.match).toEqual({ email: 'test@example.com' });&#10;      expect(rule.apply).toEqual({ name: 'Updated Name' });&#10;    });&#10;&#10;    it('should trim whitespace from rule name', () =&gt; {&#10;      const json = {&#10;        ruleName: '  test-rule  ',&#10;        match: { email: 'test@example.com' },&#10;        apply: { name: 'Updated Name' }&#10;      };&#10;&#10;      const rule = MatchRuleFactory.create&lt;User&gt;(json);&#10;&#10;      expect(rule.ruleName).toBe('test-rule');&#10;    });&#10;&#10;    it('should throw error for null or undefined input', () =&gt; {&#10;      expect(() =&gt; MatchRuleFactory.create(null)).toThrow();&#10;      expect(() =&gt; MatchRuleFactory.create(undefined)).toThrow();&#10;    });&#10;&#10;    it('should throw error for invalid rule name', () =&gt; {&#10;      const json = {&#10;        ruleName: '',&#10;        match: { email: 'test@example.com' },&#10;        apply: { name: 'Updated Name' }&#10;      };&#10;&#10;      expect(() =&gt; MatchRuleFactory.create(json)).toThrow('Rule name must be a non-empty string');&#10;    });&#10;&#10;    it('should throw error for non-string rule name', () =&gt; {&#10;      const json = {&#10;        ruleName: 123,&#10;        match: { email: 'test@example.com' },&#10;        apply: { name: 'Updated Name' }&#10;      };&#10;&#10;      expect(() =&gt; MatchRuleFactory.create(json)).toThrow('Rule name must be a non-empty string');&#10;    });&#10;&#10;    it('should handle missing match object with default empty object', () =&gt; {&#10;      const json = {&#10;        ruleName: 'test-rule',&#10;        apply: { name: 'Updated Name' }&#10;      };&#10;&#10;      const rule = MatchRuleFactory.create(json);&#10;      expect(rule.ruleName).toBe('test-rule');&#10;      expect(rule.match).toEqual({});&#10;      expect(rule.apply).toEqual({ name: 'Updated Name' });&#10;    });&#10;&#10;    it('should handle invalid match object with default empty object', () =&gt; {&#10;      const json = {&#10;        ruleName: 'test-rule',&#10;        match: 'invalid',&#10;        apply: { name: 'Updated Name' }&#10;      };&#10;&#10;      const rule = MatchRuleFactory.create(json);&#10;      expect(rule.ruleName).toBe('test-rule');&#10;      expect(rule.match).toEqual({});&#10;      expect(rule.apply).toEqual({ name: 'Updated Name' });&#10;    });&#10;&#10;    it('should handle missing apply object with default empty object', () =&gt; {&#10;      const json = {&#10;        ruleName: 'test-rule',&#10;        match: { email: 'test@example.com' }&#10;      };&#10;&#10;      const rule = MatchRuleFactory.create(json);&#10;      expect(rule.ruleName).toBe('test-rule');&#10;      expect(rule.match).toEqual({ email: 'test@example.com' });&#10;      expect(rule.apply).toEqual({});&#10;    });&#10;&#10;    it('should handle invalid apply object with default empty object', () =&gt; {&#10;      const json = {&#10;        ruleName: 'test-rule',&#10;        match: { email: 'test@example.com' },&#10;        apply: 'invalid'&#10;      };&#10;&#10;      const rule = MatchRuleFactory.create(json);&#10;      expect(rule.ruleName).toBe('test-rule');&#10;      expect(rule.match).toEqual({ email: 'test@example.com' });&#10;      expect(rule.apply).toEqual({});&#10;    });&#10;  });&#10;&#10;  describe('createRule', () =&gt; {&#10;    it('should create a MatchRule with direct parameters', () =&gt; {&#10;      const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;        'direct-rule',&#10;        { email: 'test@example.com' },&#10;        { name: 'Direct Update' }&#10;      );&#10;&#10;      expect(rule.ruleName).toBe('direct-rule');&#10;      expect(rule.match).toEqual({ email: 'test@example.com' });&#10;      expect(rule.apply).toEqual({ name: 'Direct Update' });&#10;    });&#10;&#10;    it('should trim whitespace from rule name', () =&gt; {&#10;      const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;        '  direct-rule  ',&#10;        { email: 'test@example.com' },&#10;        { name: 'Direct Update' }&#10;      );&#10;&#10;      expect(rule.ruleName).toBe('direct-rule');&#10;    });&#10;&#10;    it('should throw error for invalid rule name', () =&gt; {&#10;      expect(() =&gt; MatchRuleFactory.createRule('', {}, {})).toThrow('Rule name must be a non-empty string');&#10;      expect(() =&gt; MatchRuleFactory.createRule('   ', {}, {})).toThrow('Rule name must be a non-empty string');&#10;      expect(() =&gt; MatchRuleFactory.createRule(null as any, {}, {})).toThrow('Rule name must be a non-empty string');&#10;      expect(() =&gt; MatchRuleFactory.createRule(undefined as any, {}, {})).toThrow('Rule name must be a non-empty string');&#10;      expect(() =&gt; MatchRuleFactory.createRule(123 as any, {}, {})).toThrow('Rule name must be a non-empty string');&#10;    });&#10;&#10;    it('should handle invalid match object with default empty object', () =&gt; {&#10;      const rule1 = MatchRuleFactory.createRule('test', null as any, {});&#10;      expect(rule1.match).toEqual({});&#10;      &#10;      const rule2 = MatchRuleFactory.createRule('test', 'invalid' as any, {});&#10;      expect(rule2.match).toEqual({});&#10;      &#10;      const rule3 = MatchRuleFactory.createRule('test', undefined as any, {});&#10;      expect(rule3.match).toEqual({});&#10;    });&#10;&#10;    it('should handle invalid apply object with default empty object', () =&gt; {&#10;      const rule1 = MatchRuleFactory.createRule('test', {}, null as any);&#10;      expect(rule1.apply).toEqual({});&#10;      &#10;      const rule2 = MatchRuleFactory.createRule('test', {}, 'invalid' as any);&#10;      expect(rule2.apply).toEqual({});&#10;      &#10;      const rule3 = MatchRuleFactory.createRule('test', {}, undefined as any);&#10;      expect(rule3.apply).toEqual({});&#10;    });&#10;&#10;    it('should handle complex match and apply objects', () =&gt; {&#10;      const match = { email: 'test@example.com', name: 'John Doe' };&#10;      const apply = { name: 'Jane Doe', email: 'jane@example.com' };&#10;&#10;      const rule = MatchRuleFactory.createRule&lt;User&gt;('complex-rule', match, apply);&#10;&#10;      expect(rule.ruleName).toBe('complex-rule');&#10;      expect(rule.match).toEqual(match);&#10;      expect(rule.apply).toEqual(apply);&#10;    });&#10;  });&#10;});" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/MatchRuleFactory.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/MatchRuleFactory.ts" />
              <option name="originalContent" value="import {MatchRule} from &quot;@/MatchRule&quot;;&#10;&#10;export class MatchRuleFactory {&#10;    /**&#10;     * Creates a MatchRule instance from a rule object&#10;     * @returns A new MatchRule instance&#10;     * @param json&#10;     */&#10;    static create&lt;T&gt;(json: any): MatchRule&lt;T&gt; {&#10;        if (!json || typeof json !== 'object') {&#10;            throw new Error('Invalid rule object provided');&#10;        }&#10;        &#10;        return MatchRuleFactory.createRule&lt;T&gt;(&#10;            json.ruleName,&#10;            json.match || {},&#10;            json.apply || {}&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Creates a MatchRule instance with direct parameters&#10;     * @param ruleName The name of the rule&#10;     * @param match The conditions to match&#10;     * @param apply The changes to apply&#10;     * @returns A new MatchRule instance&#10;     */&#10;    static createRule&lt;T&gt;(ruleName: string, match: Partial&lt;T&gt;, apply: Partial&lt;T&gt;): MatchRule&lt;T&gt; {&#10;        if (!ruleName || typeof ruleName !== 'string' || !ruleName.trim()) {&#10;            throw new Error('Rule name must be a non-empty string');&#10;        }&#10;&#10;        return {&#10;            ruleName: ruleName.trim(),&#10;            match : (match &amp;&amp; typeof match === 'object') ? match : {},&#10;            apply : (apply &amp;&amp; typeof apply === 'object') ? apply : {}&#10;        };&#10;    }&#10;}" />
              <option name="updatedContent" value="import {MatchRule} from &quot;@/MatchRule&quot;;&#10;&#10;export class MatchRuleFactory {&#10;    /**&#10;     * Creates a MatchRule instance from a rule object&#10;     * @returns A new MatchRule instance&#10;     * @param json&#10;     */&#10;    static create&lt;T&gt;(json: any): MatchRule&lt;T&gt; {&#10;        if (!json || typeof json !== 'object') {&#10;            throw new Error('Invalid rule object provided');&#10;        }&#10;        &#10;        return MatchRuleFactory.createRule&lt;T&gt;(&#10;            json.ruleName,&#10;            json.match || {},&#10;            json.apply || {}&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Creates a MatchRule instance with direct parameters&#10;     * @param ruleName The name of the rule&#10;     * @param match The conditions to match&#10;     * @param apply The changes to apply&#10;     * @returns A new MatchRule instance&#10;     */&#10;    static createRule&lt;T&gt;(ruleName: string, match: Partial&lt;T&gt;, apply: Partial&lt;T&gt;): MatchRule&lt;T&gt; {&#10;        if (!ruleName || typeof ruleName !== 'string' || ruleName.trim() === '') {&#10;            throw new Error('Rule name must be a non-empty string');&#10;        }&#10;&#10;        return {&#10;            ruleName: ruleName.trim(),&#10;            match : (match &amp;&amp; typeof match === 'object') ? match : {},&#10;            apply : (apply &amp;&amp; typeof apply === 'object') ? apply : {}&#10;        };&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/index.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/index.ts" />
              <option name="updatedContent" value="import { Kysely } from 'kysely';&#10;import { MatchRule } from './MatchRule';&#10;&#10;// ...existing code...&#10;&#10;/**&#10; * PostgreSQL based rule engine that applies match rules to database tables&#10; */&#10;export class PgRulesEngine {&#10;  constructor(private db: Kysely&lt;any&gt;) {}&#10;&#10;  /**&#10;   * Apply multiple rules to a target table in a single transaction&#10;   * @param rules Array of MatchRule objects to apply&#10;   * @param targetTable Name of the table to apply rules to&#10;   * @returns Promise that resolves to the total number of affected rows&#10;   */&#10;  async applyRules&lt;T&gt;(rules: MatchRule&lt;T&gt;[], targetTable: string): Promise&lt;number&gt; {&#10;    if (!rules.length) {&#10;      return 0;&#10;    }&#10;&#10;    return await this.db.transaction().execute(async (trx) =&gt; {&#10;      let totalAffectedRows = 0;&#10;&#10;      for (const rule of rules) {&#10;        // Build the update query&#10;        let query = trx.updateTable(targetTable);&#10;&#10;        // Add SET clause from apply object&#10;        const applyEntries = Object.entries(rule.apply);&#10;        if (applyEntries.length === 0) {&#10;          continue; // Skip rules with no apply changes&#10;        }&#10;&#10;        query = query.set(rule.apply);&#10;&#10;        // Add WHERE clause from match object&#10;        const matchEntries = Object.entries(rule.match);&#10;        for (const [key, value] of matchEntries) {&#10;          query = query.where(key, '=', value);&#10;        }&#10;&#10;        // Execute the query and get affected row count&#10;        const result = await query.execute();&#10;        // For Kysely UpdateResult, we access the number of affected rows differently&#10;        totalAffectedRows += Number((result as any).numAffectedRows || 0);&#10;      }&#10;&#10;      return totalAffectedRows;&#10;    });&#10;  }&#10;}&#10;&#10;export function greet(name: string): string {&#10;  return `Hello, ${name}!`;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tsconfig.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tsconfig.json" />
              <option name="updatedContent" value="{&#10;  &quot;compilerOptions&quot;: {&#10;    &quot;target&quot;: &quot;ES2020&quot;,&#10;    &quot;module&quot;: &quot;commonjs&quot;,&#10;    &quot;lib&quot;: [&quot;ES2020&quot;],&#10;    &quot;outDir&quot;: &quot;./dist&quot;,&#10;    &quot;rootDir&quot;: &quot;./src&quot;,&#10;    &quot;strict&quot;: true,&#10;    &quot;esModuleInterop&quot;: true,&#10;    &quot;skipLibCheck&quot;: true,&#10;    &quot;forceConsistentCasingInFileNames&quot;: true,&#10;    &quot;declaration&quot;: true,&#10;    &quot;declarationMap&quot;: true,&#10;    &quot;sourceMap&quot;: true,&#10;    &quot;removeComments&quot;: true,&#10;    &quot;noImplicitAny&quot;: true,&#10;    &quot;strictNullChecks&quot;: true,&#10;    &quot;strictFunctionTypes&quot;: true,&#10;    &quot;noImplicitThis&quot;: true,&#10;    &quot;noImplicitReturns&quot;: true,&#10;    &quot;noFallthroughCasesInSwitch&quot;: true,&#10;    &quot;moduleResolution&quot;: &quot;node&quot;,&#10;    &quot;baseUrl&quot;: &quot;./&quot;,&#10;    &quot;paths&quot;: {&#10;      &quot;@/*&quot;: [&quot;src/*&quot;]&#10;    }&#10;  },&#10;  &quot;include&quot;: [&#10;    &quot;src/**/*&quot;&#10;  ],&#10;  &quot;exclude&quot;: [&#10;    &quot;node_modules&quot;,&#10;    &quot;dist&quot;,&#10;    &quot;**/*.test.ts&quot;,&#10;    &quot;**/*.spec.ts&quot;&#10;  ]&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>