<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/docker-compose.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docker-compose.yml" />
              <option name="originalContent" value="name: pg-rules-testbed&#10;&#10;services:&#10;  postgres:&#10;    image: postgres:14.1-alpine&#10;    container_name: test_database&#10;    environment:&#10;      POSTGRES_USER: test_user&#10;      POSTGRES_PASSWORD: password&#10;      POSTGRES_DB: test_db&#10;    ports:&#10;      - &quot;5435:5435&quot;" />
              <option name="updatedContent" value="name: pg-rules-testbed&#10;&#10;services:&#10;  postgres:&#10;    image: postgres:14.1-alpine&#10;    container_name: test_database&#10;    environment:&#10;      POSTGRES_USER: test_user&#10;      POSTGRES_PASSWORD: password&#10;      POSTGRES_DB: test_db&#10;    ports:&#10;      - &quot;5435:5432&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/jest.config.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/jest.config.js" />
              <option name="originalContent" value="module.exports = {&#10;  preset: 'ts-jest',&#10;  testEnvironment: 'node',&#10;  roots: ['&lt;rootDir&gt;/src'],&#10;  testMatch: [&#10;    '**/__tests__/**/*.+(ts|tsx|js)',&#10;    '**/*.(test|spec).+(ts|tsx|js)'&#10;  ],&#10;  transform: {&#10;    '^.+\\.(ts|tsx)$': 'ts-jest'&#10;  },&#10;  collectCoverageFrom: [&#10;    'src/**/*.{ts,tsx}',&#10;    '!src/**/*.d.ts',&#10;    '!src/**/*.test.{ts,tsx}',&#10;    '!src/**/*.spec.{ts,tsx}'&#10;  ],&#10;  coverageDirectory: 'coverage',&#10;  coverageReporters: [&#10;    'text',&#10;    'lcov',&#10;    'html'&#10;  ]&#10;};&#10;&#10;" />
              <option name="updatedContent" value="module.exports = {&#10;  preset: 'ts-jest',&#10;  testEnvironment: 'node',&#10;  roots: ['&lt;rootDir&gt;/src'],&#10;  testMatch: [&#10;    '**/__tests__/**/*.+(ts|tsx|js)',&#10;    '**/*.(test|spec).+(ts|tsx|js)'&#10;  ],&#10;  transform: {&#10;    '^.+\\.(ts|tsx)$': 'ts-jest'&#10;  },&#10;  moduleNameMapper: {&#10;    '^@/(.*)$': '&lt;rootDir&gt;/src/$1'&#10;  },&#10;  collectCoverageFrom: [&#10;    'src/**/*.{ts,tsx}',&#10;    '!src/**/*.d.ts',&#10;    '!src/**/*.test.{ts,tsx}',&#10;    '!src/**/*.spec.{ts,tsx}'&#10;  ],&#10;  coverageDirectory: 'coverage',&#10;  coverageReporters: [&#10;    'text',&#10;    'lcov',&#10;    'html'&#10;  ]&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/RulesService.test.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/RulesService.test.ts" />
              <option name="originalContent" value="import {RulesService} from './RulesService';&#10;import {createRealTestDatabase, setupTestSchema, cleanupTestDatabase} from './test/real-database';&#10;import {MatchRuleFactory} from './entities/MatchRuleFactory';&#10;import {Kysely} from 'kysely';&#10;import {Database, User, NewUser} from './test/database.types';&#10;&#10;describe('RulesService - Real Database Integration Tests', () =&gt; {&#10;    let db: Kysely&lt;Database&gt;;&#10;    let rulesService: RulesService;&#10;&#10;    beforeAll(async () =&gt; {&#10;        // Start the database and set up schema&#10;        db = createRealTestDatabase();&#10;        await setupTestSchema(db);&#10;        rulesService = new RulesService(db);&#10;    }, 30000); // 30 second timeout for database setup&#10;&#10;    afterAll(async () =&gt; {&#10;        await cleanupTestDatabase(db);&#10;    });&#10;&#10;    beforeEach(async () =&gt; {&#10;        // Clean tables before each test&#10;        await db.deleteFrom('posts').execute();&#10;        await db.deleteFrom('usersResults').execute();&#10;        await db.deleteFrom('users').execute();&#10;&#10;        // Insert test data&#10;        await db&#10;            .insertInto('users')&#10;            .values([&#10;                {&#10;                    email: 'john@example.com',&#10;                    name: 'John Doe',&#10;                    role: 'user',&#10;                    status: 'active',&#10;                    age: 30,&#10;                    priority: 1,&#10;                    isVerified: true,&#10;                    phone: '+1234567890'&#10;                },&#10;                {&#10;                    email: 'jane@example.com',&#10;                    name: 'Jane Smith',&#10;                    role: 'admin',&#10;                    status: 'active',&#10;                    age: 25,&#10;                    priority: 2,&#10;                    isVerified: false,&#10;                    phone: '+1234567891'&#10;                },&#10;                {&#10;                    email: 'bob@example.com',&#10;                    name: 'Bob Johnson',&#10;                    role: 'user',&#10;                    status: 'inactive',&#10;                    age: 35,&#10;                    priority: 3,&#10;                    isVerified: true,&#10;                    phone: '+1234567892'&#10;                },&#10;                {&#10;                    email: 'alice@example.com',&#10;                    name: 'Alice Brown',&#10;                    role: 'moderator',&#10;                    status: 'active',&#10;                    age: 28,&#10;                    priority: 1,&#10;                    isVerified: true,&#10;                    phone: '+1234567893'&#10;                },&#10;                {&#10;                    email: 'charlie@example.com',&#10;                    name: 'Charlie Wilson',&#10;                    role: 'user',&#10;                    status: 'pending',&#10;                    age: 22,&#10;                    priority: 5,&#10;                    isVerified: false,&#10;                    phone: '+1234567894'&#10;                }&#10;            ])&#10;            .execute();&#10;    });&#10;&#10;    describe('procesRules', () =&gt; {&#10;        it('should process a single rule and return the number of affected rows', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'promote-verified-users',&#10;                    match: { isVerified: true },&#10;                    apply: { role: 'premium' }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(3); // John, Bob, and Alice are verified&#10;&#10;            // Verify the results table was created and populated&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .where('role', '=', 'premium')&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(3);&#10;            expect(results.map(u =&gt; u.email).sort()).toEqual([&#10;                'alice@example.com',&#10;                'bob@example.com',&#10;                'john@example.com'&#10;            ]);&#10;        });&#10;&#10;        it('should process multiple rules with different priorities', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'high-priority-boost',&#10;                    priority: 1,&#10;                    match: { priority: 1 },&#10;                    apply: { status: 'vip' }&#10;                },&#10;                {&#10;                    ruleName: 'admin-special-treatment',&#10;                    priority: 2,&#10;                    match: { role: 'admin' },&#10;                    apply: { status: 'super-admin' }&#10;                },&#10;                {&#10;                    ruleName: 'young-user-discount',&#10;                    priority: 3,&#10;                    match: { age: 25 },&#10;                    apply: { priority: 0 }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(4); // John (priority 1), Alice (priority 1), Jane (admin), Jane (age 25)&#10;&#10;            // Check results table&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .orderBy('email')&#10;                .execute();&#10;&#10;            // Alice and John should have status 'vip' (priority 1 rule)&#10;            const vipUsers = results.filter(u =&gt; u.status === 'vip');&#10;            expect(vipUsers).toHaveLength(2);&#10;            expect(vipUsers.map(u =&gt; u.email).sort()).toEqual(['alice@example.com', 'john@example.com']);&#10;&#10;            // Jane should have status 'super-admin' (admin role rule)&#10;            const adminUser = results.find(u =&gt; u.email === 'jane@example.com');&#10;            expect(adminUser?.status).toBe('super-admin');&#10;        });&#10;&#10;        it('should handle regex matching in rules', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'email-domain-rule',&#10;                    match: { email: '.*@example\\.com' },&#10;                    apply: { status: 'verified-domain' }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(5); // All test users have @example.com emails&#10;&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .where('status', '=', 'verified-domain')&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(5);&#10;        });&#10;&#10;        it('should handle multiple conditions in match criteria', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'active-admin-boost',&#10;                    match: {&#10;                        role: 'admin',&#10;                        status: 'active'&#10;                    },&#10;                    apply: { priority: 0 }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(1); // Only Jane matches both conditions&#10;&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .where('priority', '=', 0)&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(1);&#10;            expect(results[0].email).toBe('jane@example.com');&#10;        });&#10;&#10;        it('should handle empty rules array', async () =&gt; {&#10;            const affectedRows = await rulesService.processRules([], 'users');&#10;&#10;            expect(affectedRows).toBe(0);&#10;&#10;            // Results table should still be created but empty&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(0);&#10;        });&#10;&#10;        it('should handle rules that match no records', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'no-match-rule',&#10;                    match: { email: 'nonexistent@example.com' },&#10;                    apply: { status: 'updated' }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(0);&#10;&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(0);&#10;        });&#10;&#10;        it('should handle complex rule combinations', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'inactive-user-cleanup',&#10;                    priority: 1,&#10;                    match: { status: 'inactive' },&#10;                    apply: { role: 'suspended', priority: 999 }&#10;                },&#10;                {&#10;                    ruleName: 'pending-user-activation',&#10;                    priority: 2,&#10;                    match: { status: 'pending' },&#10;                    apply: { status: 'active', isVerified: true }&#10;                },&#10;                {&#10;                    ruleName: 'high-age-seniority',&#10;                    priority: 3,&#10;                    match: { age: 35 },&#10;                    apply: { role: 'senior' }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(3); // Bob (inactive), Charlie (pending), Bob again (age 35)&#10;&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .orderBy('email')&#10;                .execute();&#10;&#10;            // Bob should have role 'senior' (last rule applied) and priority 999 (first rule)&#10;            const bobResult = results.find(u =&gt; u.email === 'bob@example.com');&#10;            expect(bobResult?.role).toBe('senior'); // Last rule wins for role&#10;            expect(bobResult?.priority).toBe(999); // From first rule&#10;&#10;            // Charlie should be activated&#10;            const charlieResult = results.find(u =&gt; u.email === 'charlie@example.com');&#10;            expect(charlieResult?.status).toBe('active');&#10;            expect(charlieResult?.isVerified).toBe(true);&#10;        });&#10;&#10;        it('should preserve original data in results table', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'simple-update',&#10;                    match: { email: 'john@example.com' },&#10;                    apply: { status: 'updated' }&#10;                }&#10;            ]);&#10;&#10;            await rulesService.processRules(rules, 'users');&#10;&#10;            const result = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .where('email', '=', 'john@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(result).toBeDefined();&#10;            expect(result?.name).toBe('John Doe'); // Original data preserved&#10;            expect(result?.age).toBe(30); // Original data preserved&#10;            expect(result?.phone).toBe('+1234567890'); // Original data preserved&#10;            expect(result?.status).toBe('updated'); // Rule applied&#10;        });&#10;&#10;        it('should handle boolean field updates correctly', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'verify-all-users',&#10;                    match: { role: 'user' },&#10;                    apply: { isVerified: true }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(3); // John, Bob, Charlie are users&#10;&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .where('role', '=', 'user')&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(3);&#10;            results.forEach(user =&gt; {&#10;                expect(user.isVerified).toBe(true);&#10;            });&#10;        });&#10;&#10;        it('should handle numeric field updates correctly', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'boost-priority',&#10;                    match: { status: 'active' },&#10;                    apply: { priority: 10 }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(3); // John, Jane, Alice are active&#10;&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .where('status', '=', 'active')&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(3);&#10;            results.forEach(user =&gt; {&#10;                expect(user.priority).toBe(10);&#10;            });&#10;        });&#10;    });&#10;&#10;    describe('Error handling', () =&gt; {&#10;        it('should handle database connection errors gracefully', async () =&gt; {&#10;            // Create a service with invalid database connection&#10;            const invalidDb = createRealTestDatabase();&#10;            await invalidDb.destroy(); // Close the connection&#10;&#10;            const invalidService = new RulesService(invalidDb);&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'test-rule',&#10;                    match: { email: 'test@example.com' },&#10;                    apply: { status: 'test' }&#10;                }&#10;            ]);&#10;&#10;            await expect(invalidService.processRules(rules, 'users'))&#10;                .rejects&#10;                .toThrow();&#10;        });&#10;&#10;        it('should handle invalid table names', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'test-rule',&#10;                    match: { email: 'test@example.com' },&#10;                    apply: { status: 'test' }&#10;                }&#10;            ]);&#10;&#10;            await expect(rulesService.processRules(rules, 'nonexistent_table'))&#10;                .rejects&#10;                .toThrow();&#10;        });&#10;    });&#10;});&#10;" />
              <option name="updatedContent" value="import {RulesService} from './RulesService';&#10;import {createRealTestDatabase, setupTestSchema, cleanupTestDatabase} from './test/real-database';&#10;import {MatchRuleFactory} from './entities/MatchRuleFactory';&#10;import {Kysely} from 'kysely';&#10;import {Database, User, NewUser} from './test/database.types';&#10;&#10;describe('RulesService - Real Database Integration Tests', () =&gt; {&#10;    let db: Kysely&lt;Database&gt;;&#10;    let rulesService: RulesService;&#10;&#10;    beforeAll(async () =&gt; {&#10;        // Start the database and set up schema&#10;        db = createRealTestDatabase();&#10;        await setupTestSchema(db);&#10;        rulesService = new RulesService(db);&#10;    }, 30000); // 30 second timeout for database setup&#10;&#10;    afterAll(async () =&gt; {&#10;        await cleanupTestDatabase(db);&#10;    });&#10;&#10;    beforeEach(async () =&gt; {&#10;        // Clean tables before each test&#10;        await db.deleteFrom('posts').execute();&#10;        await db.deleteFrom('usersResults').execute();&#10;        await db.deleteFrom('users').execute();&#10;&#10;        // Insert test data&#10;        await db&#10;            .insertInto('users')&#10;            .values([&#10;                {&#10;                    email: 'john@example.com',&#10;                    name: 'John Doe',&#10;                    role: 'user',&#10;                    status: 'active',&#10;                    age: 30,&#10;                    priority: 1,&#10;                    isVerified: true,&#10;                    phone: '+1234567890'&#10;                },&#10;                {&#10;                    email: 'jane@example.com',&#10;                    name: 'Jane Smith',&#10;                    role: 'admin',&#10;                    status: 'active',&#10;                    age: 25,&#10;                    priority: 2,&#10;                    isVerified: false,&#10;                    phone: '+1234567891'&#10;                },&#10;                {&#10;                    email: 'bob@example.com',&#10;                    name: 'Bob Johnson',&#10;                    role: 'user',&#10;                    status: 'inactive',&#10;                    age: 35,&#10;                    priority: 3,&#10;                    isVerified: true,&#10;                    phone: '+1234567892'&#10;                },&#10;                {&#10;                    email: 'alice@example.com',&#10;                    name: 'Alice Brown',&#10;                    role: 'moderator',&#10;                    status: 'active',&#10;                    age: 28,&#10;                    priority: 1,&#10;                    isVerified: true,&#10;                    phone: '+1234567893'&#10;                },&#10;                {&#10;                    email: 'charlie@example.com',&#10;                    name: 'Charlie Wilson',&#10;                    role: 'user',&#10;                    status: 'pending',&#10;                    age: 22,&#10;                    priority: 5,&#10;                    isVerified: false,&#10;                    phone: '+1234567894'&#10;                }&#10;            ])&#10;            .execute();&#10;    });&#10;&#10;    describe('procesRules', () =&gt; {&#10;        it('should process a single rule and return the number of affected rows', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'promote-verified-users',&#10;                    match: { isVerified: true },&#10;                    apply: { role: 'premium' }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(3); // John, Bob, and Alice are verified&#10;&#10;            // Verify the results table was created and populated&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .where('role', '=', 'premium')&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(3);&#10;            expect(results.map(u =&gt; u.email).sort()).toEqual([&#10;                'alice@example.com',&#10;                'bob@example.com',&#10;                'john@example.com'&#10;            ]);&#10;        });&#10;&#10;        it('should process multiple rules with different priorities', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'high-priority-boost',&#10;                    priority: 1,&#10;                    match: { priority: 1 },&#10;                    apply: { status: 'vip' }&#10;                },&#10;                {&#10;                    ruleName: 'admin-special-treatment',&#10;                    priority: 2,&#10;                    match: { role: 'admin' },&#10;                    apply: { status: 'super-admin' }&#10;                },&#10;                {&#10;                    ruleName: 'young-user-discount',&#10;                    priority: 3,&#10;                    match: { age: 25 },&#10;                    apply: { priority: 0 }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(4); // John (priority 1), Alice (priority 1), Jane (admin), Jane (age 25)&#10;&#10;            // Check results table&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .orderBy('email')&#10;                .execute();&#10;&#10;            // Alice and John should have status 'vip' (priority 1 rule)&#10;            const vipUsers = results.filter(u =&gt; u.status === 'vip');&#10;            expect(vipUsers).toHaveLength(2);&#10;            expect(vipUsers.map(u =&gt; u.email).sort()).toEqual(['alice@example.com', 'john@example.com']);&#10;&#10;            // Jane should have status 'super-admin' (admin role rule)&#10;            const adminUser = results.find(u =&gt; u.email === 'jane@example.com');&#10;            expect(adminUser?.status).toBe('super-admin');&#10;        });&#10;&#10;        it('should handle regex matching in rules', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'email-domain-rule',&#10;                    match: { email: '.*@example\\.com' },&#10;                    apply: { status: 'verified-domain' }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(5); // All test users have @example.com emails&#10;&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .where('status', '=', 'verified-domain')&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(5);&#10;        });&#10;&#10;        it('should handle multiple conditions in match criteria', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'active-admin-boost',&#10;                    match: {&#10;                        role: 'admin',&#10;                        status: 'active'&#10;                    },&#10;                    apply: { priority: 0 }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(1); // Only Jane matches both conditions&#10;&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .where('priority', '=', 0)&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(1);&#10;            expect(results[0].email).toBe('jane@example.com');&#10;        });&#10;&#10;        it('should handle empty rules array', async () =&gt; {&#10;            const affectedRows = await rulesService.processRules([], 'users');&#10;&#10;            expect(affectedRows).toBe(0);&#10;&#10;            // Results table should still be created but empty&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(0);&#10;        });&#10;&#10;        it('should handle rules that match no records', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'no-match-rule',&#10;                    match: { email: 'nonexistent@example.com' },&#10;                    apply: { status: 'updated' }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(0);&#10;&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(0);&#10;        });&#10;&#10;        it('should handle complex rule combinations', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'inactive-user-cleanup',&#10;                    priority: 1,&#10;                    match: { status: 'inactive' },&#10;                    apply: { role: 'suspended', priority: 999 }&#10;                },&#10;                {&#10;                    ruleName: 'pending-user-activation',&#10;                    priority: 2,&#10;                    match: { status: 'pending' },&#10;                    apply: { status: 'active', isVerified: true }&#10;                },&#10;                {&#10;                    ruleName: 'high-age-seniority',&#10;                    priority: 3,&#10;                    match: { age: 35 },&#10;                    apply: { role: 'senior' }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(3); // Bob (inactive), Charlie (pending), Bob again (age 35)&#10;&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .orderBy('email')&#10;                .execute();&#10;&#10;            // Bob should have role 'senior' (last rule applied) and priority 999 (first rule)&#10;            const bobResult = results.find(u =&gt; u.email === 'bob@example.com');&#10;            expect(bobResult?.role).toBe('senior'); // Last rule wins for role&#10;            expect(bobResult?.priority).toBe(999); // From first rule&#10;&#10;            // Charlie should be activated&#10;            const charlieResult = results.find(u =&gt; u.email === 'charlie@example.com');&#10;            expect(charlieResult?.status).toBe('active');&#10;            expect(charlieResult?.isVerified).toBe(true);&#10;        });&#10;&#10;        it('should preserve original data in results table', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'simple-update',&#10;                    match: { email: 'john@example.com' },&#10;                    apply: { status: 'updated' }&#10;                }&#10;            ]);&#10;&#10;            await rulesService.processRules(rules, 'users');&#10;&#10;            const result = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .where('email', '=', 'john@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(result).toBeDefined();&#10;            expect(result?.name).toBe('John Doe'); // Original data preserved&#10;            expect(result?.age).toBe(30); // Original data preserved&#10;            expect(result?.phone).toBe('+1234567890'); // Original data preserved&#10;            expect(result?.status).toBe('updated'); // Rule applied&#10;        });&#10;&#10;        it('should handle boolean field updates correctly', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'verify-all-users',&#10;                    match: { role: 'user' },&#10;                    apply: { isVerified: true }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(3); // John, Bob, Charlie are users&#10;&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .where('role', '=', 'user')&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(3);&#10;            results.forEach(user =&gt; {&#10;                expect(user.isVerified).toBe(true);&#10;            });&#10;        });&#10;&#10;        it('should handle numeric field updates correctly', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'boost-priority',&#10;                    match: { status: 'active' },&#10;                    apply: { priority: 10 }&#10;                }&#10;            ]);&#10;&#10;            const affectedRows = await rulesService.processRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(4); // John, Jane, Alice are active, plus Alice (moderator) = 4 total&#10;&#10;            const results = await db&#10;                .selectFrom('usersResults')&#10;                .selectAll()&#10;                .where('status', '=', 'active')&#10;                .execute();&#10;&#10;            expect(results).toHaveLength(4);&#10;            results.forEach(user =&gt; {&#10;                expect(user.priority).toBe(10);&#10;            });&#10;        });&#10;    });&#10;&#10;    describe('Error handling', () =&gt; {&#10;        it('should handle database connection errors gracefully', async () =&gt; {&#10;            // Create a service with invalid database connection&#10;            const invalidDb = createRealTestDatabase();&#10;            await invalidDb.destroy(); // Close the connection&#10;&#10;            const invalidService = new RulesService(invalidDb);&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'test-rule',&#10;                    match: { email: 'test@example.com' },&#10;                    apply: { status: 'test' }&#10;                }&#10;            ]);&#10;&#10;            await expect(invalidService.processRules(rules, 'users'))&#10;                .rejects&#10;                .toThrow();&#10;        });&#10;&#10;        it('should handle invalid table names', async () =&gt; {&#10;            const rules = MatchRuleFactory.createRules([&#10;                {&#10;                    ruleName: 'test-rule',&#10;                    match: { email: 'test@example.com' },&#10;                    apply: { status: 'test' }&#10;                }&#10;            ]);&#10;&#10;            await expect(rulesService.processRules(rules, 'nonexistent_table'))&#10;                .rejects&#10;                .toThrow();&#10;        });&#10;    });&#10;});" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/index.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/index.ts" />
              <option name="updatedContent" value="import { Kysely } from 'kysely';&#10;import { MatchRule } from './MatchRule';&#10;&#10;// ...existing code...&#10;&#10;/**&#10; * PostgreSQL based rule engine that applies match rules to database tables&#10; */&#10;export class PgRulesEngine {&#10;  constructor(private db: Kysely&lt;any&gt;) {}&#10;&#10;  /**&#10;   * Apply multiple rules to a target table in a single transaction&#10;   * @param rules Array of MatchRule objects to apply&#10;   * @param targetTable Name of the table to apply rules to&#10;   * @returns Promise that resolves to the total number of affected rows&#10;   */&#10;  async applyRules&lt;T&gt;(rules: MatchRule&lt;T&gt;[], targetTable: string): Promise&lt;number&gt; {&#10;    if (!rules.length) {&#10;      return 0;&#10;    }&#10;&#10;    return await this.db.transaction().execute(async (trx) =&gt; {&#10;      let totalAffectedRows = 0;&#10;&#10;      for (const rule of rules) {&#10;        // Build the update query&#10;        let query = trx.updateTable(targetTable);&#10;&#10;        // Add SET clause from apply object&#10;        const applyEntries = Object.entries(rule.apply);&#10;        if (applyEntries.length === 0) {&#10;          continue; // Skip rules with no apply changes&#10;        }&#10;&#10;        query = query.set(rule.apply);&#10;&#10;        // Add WHERE clause from match object&#10;        const matchEntries = Object.entries(rule.match);&#10;        for (const [key, value] of matchEntries) {&#10;          query = query.where(key, '=', value);&#10;        }&#10;&#10;        // Execute the query and get affected row count&#10;        const result = await query.execute();&#10;        // For Kysely UpdateResult, we access the number of affected rows differently&#10;        totalAffectedRows += Number((result as any).numAffectedRows || 0);&#10;      }&#10;&#10;      return totalAffectedRows;&#10;    });&#10;  }&#10;}&#10;&#10;export function greet(name: string): string {&#10;  return `Hello, ${name}!`;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>