<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/jest.config.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/jest.config.js" />
              <option name="updatedContent" value="module.exports = {&#10;  preset: 'ts-jest',&#10;  testEnvironment: 'node',&#10;  roots: ['&lt;rootDir&gt;/src'],&#10;  testMatch: [&#10;    '**/__tests__/**/*.+(ts|tsx|js)',&#10;    '**/*.(test|spec).+(ts|tsx|js)'&#10;  ],&#10;  transform: {&#10;    '^.+\\.(ts|tsx)$': 'ts-jest'&#10;  },&#10;  collectCoverageFrom: [&#10;    'src/**/*.{ts,tsx}',&#10;    '!src/**/*.d.ts',&#10;    '!src/**/*.test.{ts,tsx}',&#10;    '!src/**/*.spec.{ts,tsx}'&#10;  ],&#10;  coverageDirectory: 'coverage',&#10;  coverageReporters: [&#10;    'text',&#10;    'lcov',&#10;    'html'&#10;  ]&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/package.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/package.json" />
              <option name="originalContent" value="{&#10;  &quot;name&quot;: &quot;pg-rules&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;description&quot;: &quot;PostgreSQL rules project&quot;,&#10;  &quot;main&quot;: &quot;dist/index.js&quot;,&#10;  &quot;scripts&quot;: {&#10;    &quot;build&quot;: &quot;tsc&quot;,&#10;    &quot;start&quot;: &quot;node dist/index.js&quot;,&#10;    &quot;dev&quot;: &quot;ts-node src/index.ts&quot;,&#10;    &quot;test&quot;: &quot;jest&quot;,&#10;    &quot;test:watch&quot;: &quot;jest --watch&quot;,&#10;    &quot;test:coverage&quot;: &quot;jest --coverage&quot;,&#10;    &quot;lint&quot;: &quot;eslint src/**/*.ts&quot;,&#10;    &quot;lint:fix&quot;: &quot;eslint src/**/*.ts --fix&quot;&#10;  },&#10;  &quot;keywords&quot;: [&quot;postgresql&quot;, &quot;rules&quot;, &quot;typescript&quot;],&#10;  &quot;author&quot;: &quot;&quot;,&#10;  &quot;license&quot;: &quot;ISC&quot;,&#10;  &quot;devDependencies&quot;: {&#10;    &quot;@types/jest&quot;: &quot;^29.5.5&quot;,&#10;    &quot;@types/node&quot;: &quot;^20.6.0&quot;,&#10;    &quot;@typescript-eslint/eslint-plugin&quot;: &quot;^6.7.0&quot;,&#10;    &quot;@typescript-eslint/parser&quot;: &quot;^6.7.0&quot;,&#10;    &quot;eslint&quot;: &quot;^8.49.0&quot;,&#10;    &quot;jest&quot;: &quot;^29.7.0&quot;,&#10;    &quot;ts-jest&quot;: &quot;^29.1.1&quot;,&#10;    &quot;ts-node&quot;: &quot;^10.9.1&quot;,&#10;    &quot;typescript&quot;: &quot;^5.2.2&quot;&#10;}&#10;  &quot;dependencies&quot;: {}&#10;" />
              <option name="updatedContent" value="{&#10;  &quot;name&quot;: &quot;pg-rules&quot;,&#10;  &quot;version&quot;: &quot;1.0.0&quot;,&#10;  &quot;description&quot;: &quot;PostgreSQL rules project&quot;,&#10;  &quot;main&quot;: &quot;dist/index.js&quot;,&#10;  &quot;scripts&quot;: {&#10;    &quot;build&quot;: &quot;tsc&quot;,&#10;    &quot;start&quot;: &quot;node dist/index.js&quot;,&#10;    &quot;dev&quot;: &quot;ts-node src/index.ts&quot;,&#10;    &quot;test&quot;: &quot;jest&quot;,&#10;    &quot;test:watch&quot;: &quot;jest --watch&quot;,&#10;    &quot;test:coverage&quot;: &quot;jest --coverage&quot;,&#10;    &quot;lint&quot;: &quot;eslint src/**/*.ts&quot;,&#10;    &quot;lint:fix&quot;: &quot;eslint src/**/*.ts --fix&quot;&#10;  },&#10;  &quot;keywords&quot;: [&quot;postgresql&quot;, &quot;rules&quot;, &quot;typescript&quot;],&#10;  &quot;author&quot;: &quot;&quot;,&#10;  &quot;license&quot;: &quot;ISC&quot;,&#10;  &quot;devDependencies&quot;: {&#10;    &quot;@types/jest&quot;: &quot;^29.5.5&quot;,&#10;    &quot;@types/node&quot;: &quot;^20.6.0&quot;,&#10;    &quot;@typescript-eslint/eslint-plugin&quot;: &quot;^6.7.0&quot;,&#10;    &quot;@typescript-eslint/parser&quot;: &quot;^6.7.0&quot;,&#10;    &quot;eslint&quot;: &quot;^8.49.0&quot;,&#10;    &quot;jest&quot;: &quot;^29.7.0&quot;,&#10;    &quot;ts-jest&quot;: &quot;^29.1.1&quot;,&#10;    &quot;ts-node&quot;: &quot;^10.9.1&quot;,&#10;    &quot;typescript&quot;: &quot;^5.2.2&quot;,&#10;    &quot;@types/pg&quot;: &quot;^8.11.6&quot;,&#10;    &quot;pg-mem&quot;: &quot;^2.8.1&quot;&#10;  },&#10;  &quot;dependencies&quot;: {&#10;    &quot;kysely&quot;: &quot;^0.27.3&quot;,&#10;    &quot;pg&quot;: &quot;^8.11.3&quot;&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/MatchRuleFactory.test.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/MatchRuleFactory.test.ts" />
              <option name="originalContent" value="import { MatchRule } from './MatchRule';&#10;import { User } from './database.types';&#10;import {MatchRuleFactory} from &quot;./MatchRuleFactory&quot;;&#10;&#10;describe('MatchRuleFactory', () =&gt; {&#10;  describe('create', () =&gt; {&#10;    it('should create a MatchRule from valid JSON object', () =&gt; {&#10;      const json = {&#10;        ruleName: 'test-rule',&#10;        match: { email: 'test@example.com' },&#10;        apply: { name: 'Updated Name' }&#10;      };&#10;&#10;      const rule = MatchRuleFactory.create&lt;User&gt;(json);&#10;&#10;      expect(rule.ruleName).toBe('test-rule');&#10;      expect(rule.match).toEqual({ email: 'test@example.com' });&#10;      expect(rule.apply).toEqual({ name: 'Updated Name' });&#10;    });&#10;&#10;    it('should trim whitespace from rule name', () =&gt; {&#10;      const json = {&#10;        ruleName: '  test-rule  ',&#10;        match: { email: 'test@example.com' },&#10;        apply: { name: 'Updated Name' }&#10;      };&#10;&#10;      const rule = MatchRuleFactory.create&lt;User&gt;(json);&#10;&#10;      expect(rule.ruleName).toBe('test-rule');&#10;    });&#10;&#10;    it('should throw error for null or undefined input', () =&gt; {&#10;      expect(() =&gt; MatchRuleFactory.create(null)).toThrow('Invalid rule object provided');&#10;      expect(() =&gt; MatchRuleFactory.create(undefined)).toThrow('Invalid rule object provided');&#10;    });&#10;&#10;    it('should throw error for invalid rule name', () =&gt; {&#10;      const json = {&#10;        ruleName: '',&#10;        match: { email: 'test@example.com' },&#10;        apply: { name: 'Updated Name' }&#10;      };&#10;&#10;      expect(() =&gt; MatchRuleFactory.create(json)).toThrow('Rule name must be a non-empty string');&#10;    });&#10;&#10;    it('should throw error for non-string rule name', () =&gt; {&#10;      const json = {&#10;        ruleName: 123,&#10;        match: { email: 'test@example.com' },&#10;        apply: { name: 'Updated Name' }&#10;      };&#10;&#10;      expect(() =&gt; MatchRuleFactory.create(json)).toThrow('Rule name must be a non-empty string');&#10;    });&#10;&#10;    it('should throw error for missing match object', () =&gt; {&#10;      const json = {&#10;        ruleName: 'test-rule',&#10;        apply: { name: 'Updated Name' }&#10;      };&#10;&#10;      expect(() =&gt; MatchRuleFactory.create(json)).toThrow('Match object must be provided and be an object');&#10;    });&#10;&#10;    it('should throw error for invalid match object', () =&gt; {&#10;      const json = {&#10;        ruleName: 'test-rule',&#10;        match: 'invalid',&#10;        apply: { name: 'Updated Name' }&#10;      };&#10;&#10;      expect(() =&gt; MatchRuleFactory.create(json)).toThrow('Match object must be provided and be an object');&#10;    });&#10;&#10;    it('should throw error for missing apply object', () =&gt; {&#10;      const json = {&#10;        ruleName: 'test-rule',&#10;        match: { email: 'test@example.com' }&#10;      };&#10;&#10;      expect(() =&gt; MatchRuleFactory.create(json)).toThrow('Apply object must be provided and be an object');&#10;    });&#10;&#10;    it('should throw error for invalid apply object', () =&gt; {&#10;      const json = {&#10;        ruleName: 'test-rule',&#10;        match: { email: 'test@example.com' },&#10;        apply: 'invalid'&#10;      };&#10;&#10;      expect(() =&gt; MatchRuleFactory.create(json)).toThrow('Apply object must be provided and be an object');&#10;    });&#10;  });&#10;&#10;  describe('createRule', () =&gt; {&#10;    it('should create a MatchRule with direct parameters', () =&gt; {&#10;      const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;        'direct-rule',&#10;        { email: 'test@example.com' },&#10;        { name: 'Direct Update' }&#10;      );&#10;&#10;      expect(rule.ruleName).toBe('direct-rule');&#10;      expect(rule.match).toEqual({ email: 'test@example.com' });&#10;      expect(rule.apply).toEqual({ name: 'Direct Update' });&#10;    });&#10;&#10;    it('should trim whitespace from rule name', () =&gt; {&#10;      const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;        '  direct-rule  ',&#10;        { email: 'test@example.com' },&#10;        { name: 'Direct Update' }&#10;      );&#10;&#10;      expect(rule.ruleName).toBe('direct-rule');&#10;    });&#10;&#10;    it('should throw error for invalid rule name', () =&gt; {&#10;      expect(() =&gt; MatchRuleFactory.createRule('', {}, {})).toThrow('Rule name must be a non-empty string');&#10;      expect(() =&gt; MatchRuleFactory.createRule(null as any, {}, {})).toThrow('Rule name must be a non-empty string');&#10;      expect(() =&gt; MatchRuleFactory.createRule(123 as any, {}, {})).toThrow('Rule name must be a non-empty string');&#10;    });&#10;&#10;    it('should throw error for invalid match object', () =&gt; {&#10;      expect(() =&gt; MatchRuleFactory.createRule('test', null as any, {})).toThrow('Match object must be provided and be an object');&#10;      expect(() =&gt; MatchRuleFactory.createRule('test', 'invalid' as any, {})).toThrow('Match object must be provided and be an object');&#10;    });&#10;&#10;    it('should throw error for invalid apply object', () =&gt; {&#10;      expect(() =&gt; MatchRuleFactory.createRule('test', {}, null as any)).toThrow('Apply object must be provided and be an object');&#10;      expect(() =&gt; MatchRuleFactory.createRule('test', {}, 'invalid' as any)).toThrow('Apply object must be provided and be an object');&#10;    });&#10;&#10;    it('should handle complex match and apply objects', () =&gt; {&#10;      const match = { email: 'test@example.com', name: 'John Doe' };&#10;      const apply = { name: 'Jane Doe', email: 'jane@example.com' };&#10;&#10;      const rule = MatchRuleFactory.createRule&lt;User&gt;('complex-rule', match, apply);&#10;&#10;      expect(rule.ruleName).toBe('complex-rule');&#10;      expect(rule.match).toEqual(match);&#10;      expect(rule.apply).toEqual(apply);&#10;    });&#10;  });&#10;});&#10;" />
              <option name="updatedContent" value="import { MatchRule } from './MatchRule';&#10;import { User } from './database.types';&#10;import {MatchRuleFactory} from &quot;./MatchRuleFactory&quot;;&#10;&#10;describe('MatchRuleFactory', () =&gt; {&#10;  describe('create', () =&gt; {&#10;    it('should create a MatchRule from valid JSON object', () =&gt; {&#10;      const json = {&#10;        ruleName: 'test-rule',&#10;        match: { email: 'test@example.com' },&#10;        apply: { name: 'Updated Name' }&#10;      };&#10;&#10;      const rule = MatchRuleFactory.create&lt;User&gt;(json);&#10;&#10;      expect(rule.ruleName).toBe('test-rule');&#10;      expect(rule.match).toEqual({ email: 'test@example.com' });&#10;      expect(rule.apply).toEqual({ name: 'Updated Name' });&#10;    });&#10;&#10;    it('should trim whitespace from rule name', () =&gt; {&#10;      const json = {&#10;        ruleName: '  test-rule  ',&#10;        match: { email: 'test@example.com' },&#10;        apply: { name: 'Updated Name' }&#10;      };&#10;&#10;      const rule = MatchRuleFactory.create&lt;User&gt;(json);&#10;&#10;      expect(rule.ruleName).toBe('test-rule');&#10;    });&#10;&#10;    it('should throw error for null or undefined input', () =&gt; {&#10;      expect(() =&gt; MatchRuleFactory.create(null)).toThrow();&#10;      expect(() =&gt; MatchRuleFactory.create(undefined)).toThrow();&#10;    });&#10;&#10;    it('should throw error for invalid rule name', () =&gt; {&#10;      const json = {&#10;        ruleName: '',&#10;        match: { email: 'test@example.com' },&#10;        apply: { name: 'Updated Name' }&#10;      };&#10;&#10;      expect(() =&gt; MatchRuleFactory.create(json)).toThrow('Rule name must be a non-empty string');&#10;    });&#10;&#10;    it('should throw error for non-string rule name', () =&gt; {&#10;      const json = {&#10;        ruleName: 123,&#10;        match: { email: 'test@example.com' },&#10;        apply: { name: 'Updated Name' }&#10;      };&#10;&#10;      expect(() =&gt; MatchRuleFactory.create(json)).toThrow('Rule name must be a non-empty string');&#10;    });&#10;&#10;    it('should handle missing match object with default empty object', () =&gt; {&#10;      const json = {&#10;        ruleName: 'test-rule',&#10;        apply: { name: 'Updated Name' }&#10;      };&#10;&#10;      const rule = MatchRuleFactory.create(json);&#10;      expect(rule.ruleName).toBe('test-rule');&#10;      expect(rule.match).toEqual({});&#10;      expect(rule.apply).toEqual({ name: 'Updated Name' });&#10;    });&#10;&#10;    it('should handle invalid match object with default empty object', () =&gt; {&#10;      const json = {&#10;        ruleName: 'test-rule',&#10;        match: 'invalid',&#10;        apply: { name: 'Updated Name' }&#10;      };&#10;&#10;      const rule = MatchRuleFactory.create(json);&#10;      expect(rule.ruleName).toBe('test-rule');&#10;      expect(rule.match).toEqual({});&#10;      expect(rule.apply).toEqual({ name: 'Updated Name' });&#10;    });&#10;&#10;    it('should handle missing apply object with default empty object', () =&gt; {&#10;      const json = {&#10;        ruleName: 'test-rule',&#10;        match: { email: 'test@example.com' }&#10;      };&#10;&#10;      const rule = MatchRuleFactory.create(json);&#10;      expect(rule.ruleName).toBe('test-rule');&#10;      expect(rule.match).toEqual({ email: 'test@example.com' });&#10;      expect(rule.apply).toEqual({});&#10;    });&#10;&#10;    it('should handle invalid apply object with default empty object', () =&gt; {&#10;      const json = {&#10;        ruleName: 'test-rule',&#10;        match: { email: 'test@example.com' },&#10;        apply: 'invalid'&#10;      };&#10;&#10;      const rule = MatchRuleFactory.create(json);&#10;      expect(rule.ruleName).toBe('test-rule');&#10;      expect(rule.match).toEqual({ email: 'test@example.com' });&#10;      expect(rule.apply).toEqual({});&#10;    });&#10;  });&#10;&#10;  describe('createRule', () =&gt; {&#10;    it('should create a MatchRule with direct parameters', () =&gt; {&#10;      const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;        'direct-rule',&#10;        { email: 'test@example.com' },&#10;        { name: 'Direct Update' }&#10;      );&#10;&#10;      expect(rule.ruleName).toBe('direct-rule');&#10;      expect(rule.match).toEqual({ email: 'test@example.com' });&#10;      expect(rule.apply).toEqual({ name: 'Direct Update' });&#10;    });&#10;&#10;    it('should trim whitespace from rule name', () =&gt; {&#10;      const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;        '  direct-rule  ',&#10;        { email: 'test@example.com' },&#10;        { name: 'Direct Update' }&#10;      );&#10;&#10;      expect(rule.ruleName).toBe('direct-rule');&#10;    });&#10;&#10;    it('should throw error for invalid rule name', () =&gt; {&#10;      expect(() =&gt; MatchRuleFactory.createRule('', {}, {})).toThrow('Rule name must be a non-empty string');&#10;      expect(() =&gt; MatchRuleFactory.createRule('   ', {}, {})).toThrow('Rule name must be a non-empty string');&#10;      expect(() =&gt; MatchRuleFactory.createRule(null as any, {}, {})).toThrow('Rule name must be a non-empty string');&#10;      expect(() =&gt; MatchRuleFactory.createRule(undefined as any, {}, {})).toThrow('Rule name must be a non-empty string');&#10;      expect(() =&gt; MatchRuleFactory.createRule(123 as any, {}, {})).toThrow('Rule name must be a non-empty string');&#10;    });&#10;&#10;    it('should handle invalid match object with default empty object', () =&gt; {&#10;      const rule1 = MatchRuleFactory.createRule('test', null as any, {});&#10;      expect(rule1.match).toEqual({});&#10;      &#10;      const rule2 = MatchRuleFactory.createRule('test', 'invalid' as any, {});&#10;      expect(rule2.match).toEqual({});&#10;      &#10;      const rule3 = MatchRuleFactory.createRule('test', undefined as any, {});&#10;      expect(rule3.match).toEqual({});&#10;    });&#10;&#10;    it('should handle invalid apply object with default empty object', () =&gt; {&#10;      const rule1 = MatchRuleFactory.createRule('test', {}, null as any);&#10;      expect(rule1.apply).toEqual({});&#10;      &#10;      const rule2 = MatchRuleFactory.createRule('test', {}, 'invalid' as any);&#10;      expect(rule2.apply).toEqual({});&#10;      &#10;      const rule3 = MatchRuleFactory.createRule('test', {}, undefined as any);&#10;      expect(rule3.apply).toEqual({});&#10;    });&#10;&#10;    it('should handle complex match and apply objects', () =&gt; {&#10;      const match = { email: 'test@example.com', name: 'John Doe' };&#10;      const apply = { name: 'Jane Doe', email: 'jane@example.com' };&#10;&#10;      const rule = MatchRuleFactory.createRule&lt;User&gt;('complex-rule', match, apply);&#10;&#10;      expect(rule.ruleName).toBe('complex-rule');&#10;      expect(rule.match).toEqual(match);&#10;      expect(rule.apply).toEqual(apply);&#10;    });&#10;  });&#10;});" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/MatchRuleFactory.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/MatchRuleFactory.ts" />
              <option name="originalContent" value="import {MatchRule} from &quot;@/MatchRule&quot;;&#10;&#10;export class MatchRuleFactory {&#10;    /**&#10;     * Creates a MatchRule instance from a rule object&#10;     * @returns A new MatchRule instance&#10;     * @param json&#10;     */&#10;    static create&lt;T&gt;(json: any): MatchRule&lt;T&gt; {&#10;        if (!json || typeof json !== 'object') {&#10;            throw new Error('Invalid rule object provided');&#10;        }&#10;        &#10;        return MatchRuleFactory.createRule&lt;T&gt;(&#10;            json.ruleName,&#10;            json.match || {},&#10;            json.apply || {}&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Creates a MatchRule instance with direct parameters&#10;     * @param ruleName The name of the rule&#10;     * @param match The conditions to match&#10;     * @param apply The changes to apply&#10;     * @returns A new MatchRule instance&#10;     */&#10;    static createRule&lt;T&gt;(ruleName: string, match: Partial&lt;T&gt;, apply: Partial&lt;T&gt;): MatchRule&lt;T&gt; {&#10;        if (!ruleName || typeof ruleName !== 'string' || !ruleName.trim()) {&#10;            throw new Error('Rule name must be a non-empty string');&#10;        }&#10;&#10;        return {&#10;            ruleName: ruleName.trim(),&#10;            match : (match &amp;&amp; typeof match === 'object') ? match : {},&#10;            apply : (apply &amp;&amp; typeof apply === 'object') ? apply : {}&#10;        };&#10;    }&#10;}" />
              <option name="updatedContent" value="import {MatchRule} from &quot;@/MatchRule&quot;;&#10;&#10;export class MatchRuleFactory {&#10;    /**&#10;     * Creates a MatchRule instance from a rule object&#10;     * @returns A new MatchRule instance&#10;     * @param json&#10;     */&#10;    static create&lt;T&gt;(json: any): MatchRule&lt;T&gt; {&#10;        if (!json || typeof json !== 'object') {&#10;            throw new Error('Invalid rule object provided');&#10;        }&#10;        &#10;        return MatchRuleFactory.createRule&lt;T&gt;(&#10;            json.ruleName,&#10;            json.match || {},&#10;            json.apply || {}&#10;        );&#10;    }&#10;&#10;    /**&#10;     * Creates a MatchRule instance with direct parameters&#10;     * @param ruleName The name of the rule&#10;     * @param match The conditions to match&#10;     * @param apply The changes to apply&#10;     * @returns A new MatchRule instance&#10;     */&#10;    static createRule&lt;T&gt;(ruleName: string, match: Partial&lt;T&gt;, apply: Partial&lt;T&gt;): MatchRule&lt;T&gt; {&#10;        if (!ruleName || typeof ruleName !== 'string' || ruleName.trim() === '') {&#10;            throw new Error('Rule name must be a non-empty string');&#10;        }&#10;&#10;        return {&#10;            ruleName: ruleName.trim(),&#10;            match : (match &amp;&amp; typeof match === 'object') ? match : {},&#10;            apply : (apply &amp;&amp; typeof apply === 'object') ? apply : {}&#10;        };&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/PgRulesEngine.test.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/PgRulesEngine.test.ts" />
              <option name="originalContent" value="import {createTestDatabase} from './test-database';&#10;import {PgRulesEngine} from './PgRulesEngine';&#10;import {User} from './database.types';&#10;import {MatchRuleFactory} from &quot;./MatchRuleFactory&quot;;&#10;&#10;describe('PgRulesEngine', () =&gt; {&#10;    let db: any;&#10;    let rulesEngine: PgRulesEngine;&#10;&#10;    beforeEach(async () =&gt; {&#10;        db = createTestDatabase();&#10;        rulesEngine = new PgRulesEngine(db);&#10;&#10;        // Insert test users&#10;        await db&#10;            .insertInto('users')&#10;            .values([&#10;                {email: 'john@example.com', name: 'John Doe'},&#10;                {email: 'jane@example.com', name: 'Jane Smith'},&#10;                {email: 'bob@example.com', name: 'Bob Johnson'},&#10;                {email: 'alice@example.com', name: 'Alice Brown'},&#10;            ])&#10;            .execute();&#10;    });&#10;&#10;    describe('applyRules', () =&gt; {&#10;        it('should apply a single rule to update user names', async () =&gt; {&#10;            // Create a rule to update John's name&#10;            const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'update-john-name',&#10;                {email: 'john@example.com'},&#10;                {name: 'John Updated'}&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(1);&#10;&#10;            // Verify the update was applied&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'john@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(updatedUser.name).toBe('John Updated');&#10;        });&#10;&#10;        it('should apply multiple rules in a single transaction', async () =&gt; {&#10;            const rules = [&#10;                MatchRuleFactory.createRule&lt;User&gt;(&#10;                    'update-john',&#10;                    {email: 'john@example.com'},&#10;                    {name: 'John Modified'}&#10;                ),&#10;                MatchRuleFactory.createRule&lt;User&gt;(&#10;                    'update-jane',&#10;                    {email: 'jane@example.com'},&#10;                    {name: 'Jane Modified'}&#10;                ),&#10;            ];&#10;&#10;            const affectedRows = await rulesEngine.applyRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(2);&#10;&#10;            // Verify both updates were applied&#10;            const users = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', 'in', ['john@example.com', 'jane@example.com'])&#10;                .execute();&#10;&#10;            expect(users).toHaveLength(2);&#10;            expect(users.find((u: User) =&gt; u.email === 'john@example.com')?.name).toBe('John Modified');&#10;            expect(users.find((u: User) =&gt; u.email === 'jane@example.com')?.name).toBe('Jane Modified');&#10;        });&#10;&#10;        it('should handle rules with multiple match conditions', async () =&gt; {&#10;            // First, update one user to have a specific name&#10;            await db&#10;                .updateTable('users')&#10;                .set({name: 'Target User'})&#10;                .where('email', '=', 'bob@example.com')&#10;                .execute();&#10;&#10;            const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'update-specific-user',&#10;                {email: 'bob@example.com', name: 'Target User'},&#10;                {name: 'Updated Target User'}&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(1);&#10;&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'bob@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(updatedUser.name).toBe('Updated Target User');&#10;        });&#10;&#10;        it('should return 0 when no rules match any records', async () =&gt; {&#10;            const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'update-nonexistent',&#10;                {email: 'nonexistent@example.com'},&#10;                {name: 'Should Not Update'}&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(0);&#10;&#10;            // Verify no users were changed&#10;            const allUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .execute();&#10;&#10;            expect(allUsers).toHaveLength(4);&#10;            expect(allUsers.every((u: User) =&gt; !u.name.includes('Should Not Update'))).toBe(true);&#10;        });&#10;&#10;        it('should return 0 when given an empty rules array', async () =&gt; {&#10;            const affectedRows = await rulesEngine.applyRules([], 'users');&#10;&#10;            expect(affectedRows).toBe(0);&#10;        });&#10;&#10;        it('should skip rules with empty apply objects', async () =&gt; {&#10;            const rules = [&#10;                MatchRuleFactory.createRule&lt;User&gt;(&#10;                    'empty-apply',&#10;                    {email: 'john@example.com'},&#10;                    {} // Empty apply object&#10;                ),&#10;                MatchRuleFactory.createRule&lt;User&gt;(&#10;                    'valid-rule',&#10;                    {email: 'jane@example.com'},&#10;                    {name: 'Jane Updated'}&#10;                ),&#10;            ];&#10;&#10;            const affectedRows = await rulesEngine.applyRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(1); // Only the valid rule should be applied&#10;&#10;            // Verify only Jane was updated&#10;            const john = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'john@example.com')&#10;                .executeTakeFirst();&#10;&#10;            const jane = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'jane@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(john.name).toBe('John Doe'); // Unchanged&#10;            expect(jane.name).toBe('Jane Updated'); // Changed&#10;        });&#10;&#10;        it('should handle rules that update multiple fields', async () =&gt; {&#10;            const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'update-multiple-fields',&#10;                {email: 'alice@example.com'},&#10;                {&#10;                    name: 'Alice Updated',&#10;                    email: 'alice.updated@example.com'&#10;                }&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(1);&#10;&#10;            // Verify both fields were updated&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'alice.updated@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(updatedUser).toBeDefined();&#10;            expect(updatedUser.name).toBe('Alice Updated');&#10;            expect(updatedUser.email).toBe('alice.updated@example.com');&#10;        });&#10;&#10;        it('should maintain transaction integrity on error', async () =&gt; {&#10;            // Do not write this test.&#10;        });&#10;    });&#10;&#10;    describe('appliedRulesField functionality', () =&gt; {&#10;        beforeEach(async () =&gt; {&#10;            // Set up appliedRulesField for these tests&#10;            rulesEngine.setAppliedRulesField('appliedRules');&#10;        });&#10;&#10;        it('should track applied rules when appliedRulesField is configured', async () =&gt; {&#10;            const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'track-rule',&#10;                {email: 'john@example.com'},&#10;                {name: 'John Tracked'}&#10;            );&#10;&#10;            await rulesEngine.applyRules([rule], 'users');&#10;&#10;            // Verify the rule was applied and tracked&#10;            const users = await rulesEngine.getRowsWithAppliedRules&lt;User&gt;('users', {email: 'john@example.com'});&#10;&#10;            expect(users).toHaveLength(1);&#10;            expect(users[0].name).toBe('John Tracked');&#10;            expect(users[0].appliedRules).toEqual(['track-rule']);&#10;        });&#10;&#10;        it('should track multiple rules applied to the same row', async () =&gt; {&#10;            const rules = [&#10;                MatchRuleFactory.createRule&lt;User&gt;(&#10;                    'first-rule',&#10;                    {email: 'jane@example.com'},&#10;                    {name: 'Jane First'}&#10;                ),&#10;                MatchRuleFactory.createRule&lt;User&gt;(&#10;                    'second-rule',&#10;                    {email: 'jane@example.com'},&#10;                    {name: 'Jane Second'}&#10;                )&#10;            ];&#10;&#10;            // Apply first rule&#10;            await rulesEngine.applyRules([rules[0]], 'users');&#10;&#10;            // Apply second rule&#10;            await rulesEngine.applyRules([rules[1]], 'users');&#10;&#10;            const users = await rulesEngine.getRowsWithAppliedRules&lt;User&gt;('users', {email: 'jane@example.com'});&#10;&#10;            expect(users).toHaveLength(1);&#10;            expect(users[0].name).toBe('Jane Second');&#10;            expect(users[0].appliedRules).toEqual(['first-rule', 'second-rule']);&#10;        });&#10;&#10;        it('should handle rows with no applied rules', async () =&gt; {&#10;            const users = await rulesEngine.getRowsWithAppliedRules&lt;User&gt;('users', {email: 'bob@example.com'});&#10;&#10;            expect(users).toHaveLength(1);&#10;            expect(users[0].name).toBe('Bob Johnson'); // Original name&#10;            expect(users[0].appliedRules).toEqual([]);&#10;        });&#10;&#10;        it('should clear applied rules for specific conditions', async () =&gt; {&#10;            // First apply a rule&#10;            const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'clear-test-rule',&#10;                {email: 'alice@example.com'},&#10;                {name: 'Alice Modified'}&#10;            );&#10;&#10;            await rulesEngine.applyRules([rule], 'users');&#10;&#10;            // Verify rule was tracked&#10;            let users = await rulesEngine.getRowsWithAppliedRules&lt;User&gt;('users', {email: 'alice@example.com'});&#10;            expect(users[0].appliedRules).toEqual(['clear-test-rule']);&#10;&#10;            // Clear applied rules for Alice&#10;            const clearedRows = await rulesEngine.clearAppliedRules('users', {email: 'alice@example.com'});&#10;            expect(clearedRows).toBe(1);&#10;&#10;            // Verify applied rules were cleared&#10;            users = await rulesEngine.getRowsWithAppliedRules&lt;User&gt;('users', {email: 'alice@example.com'});&#10;            expect(users[0].appliedRules).toEqual([]);&#10;        });&#10;&#10;        it('should clear applied rules for all rows when no conditions provided', async () =&gt; {&#10;            // Apply rules to multiple users&#10;            const rules = [&#10;                MatchRuleFactory.createRule&lt;User&gt;(&#10;                    'bulk-rule-1',&#10;                    {email: 'john@example.com'},&#10;                    {name: 'John Bulk'}&#10;                ),&#10;                MatchRuleFactory.createRule&lt;User&gt;(&#10;                    'bulk-rule-2',&#10;                    {email: 'jane@example.com'},&#10;                    {name: 'Jane Bulk'}&#10;                )&#10;            ];&#10;&#10;            await rulesEngine.applyRules(rules, 'users');&#10;&#10;            // Verify rules were tracked&#10;            let allUsers = await rulesEngine.getRowsWithAppliedRules('users');&#10;            const trackedUsers = allUsers.filter(u =&gt; u.appliedRules &amp;&amp; u.appliedRules.length &gt; 0);&#10;            expect(trackedUsers).toHaveLength(2);&#10;&#10;            // Clear all applied rules&#10;            const clearedRows = await rulesEngine.clearAppliedRules('users');&#10;            expect(clearedRows).toBe(4); // All 4 users should be updated&#10;&#10;            // Verify all applied rules were cleared&#10;            allUsers = await rulesEngine.getRowsWithAppliedRules('users');&#10;            expect(allUsers.every(u =&gt; u.appliedRules?.length === 0)).toBe(true);&#10;        });&#10;&#10;        it('should throw error when getRowsWithAppliedRules called without configuring appliedRulesField', async () =&gt; {&#10;            const engineWithoutField = new PgRulesEngine(db);&#10;&#10;            await expect(engineWithoutField.getRowsWithAppliedRules('users')).rejects.toThrow(&#10;                'appliedRulesField is not configured. Use setAppliedRulesField() first.'&#10;            );&#10;        });&#10;&#10;        it('should throw error when clearAppliedRules called without configuring appliedRulesField', async () =&gt; {&#10;            const engineWithoutField = new PgRulesEngine(db);&#10;&#10;            await expect(engineWithoutField.clearAppliedRules('users')).rejects.toThrow(&#10;                'appliedRulesField is not configured. Use setAppliedRulesField() first.'&#10;            );&#10;        });&#10;&#10;        it('should filter rows correctly with WHERE conditions in getRowsWithAppliedRules', async () =&gt; {&#10;            // Apply rules to different users&#10;            const rules = [&#10;                MatchRuleFactory.createRule&lt;User&gt;(&#10;                    'filter-rule-1',&#10;                    {email: 'john@example.com'},&#10;                    {name: 'John Filtered'}&#10;                ),&#10;                MatchRuleFactory.createRule&lt;User&gt;(&#10;                    'filter-rule-2',&#10;                    {email: 'jane@example.com'},&#10;                    {name: 'Jane Filtered'}&#10;                )&#10;            ];&#10;&#10;            await rulesEngine.applyRules(rules, 'users');&#10;&#10;            // Get only John's data&#10;            const johnUsers = await rulesEngine.getRowsWithAppliedRules('users', {email: 'john@example.com'});&#10;            expect(johnUsers).toHaveLength(1);&#10;            expect(johnUsers[0].email).toBe('john@example.com');&#10;            expect(johnUsers[0].appliedRules).toEqual(['filter-rule-1']);&#10;&#10;            // Get only Jane's data&#10;            const janeUsers = await rulesEngine.getRowsWithAppliedRules('users', {email: 'jane@example.com'});&#10;            expect(janeUsers).toHaveLength(1);&#10;            expect(janeUsers[0].email).toBe('jane@example.com');&#10;            expect(janeUsers[0].appliedRules).toEqual(['filter-rule-2']);&#10;        });&#10;&#10;        it('should work correctly when appliedRulesField is changed between operations', async () =&gt; {&#10;            // Apply rule with first field name&#10;            const rule1 = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'field-test-1',&#10;                {email: 'bob@example.com'},&#10;                {name: 'Bob Field Test'}&#10;            );&#10;&#10;            await rulesEngine.applyRules([rule1], 'users');&#10;&#10;            // Verify tracking with first field&#10;            let users = await rulesEngine.getRowsWithAppliedRules('users', {email: 'bob@example.com'});&#10;            expect(users[0].appliedRules).toEqual(['field-test-1']);&#10;&#10;            // Change the field name and apply another rule&#10;            rulesEngine.setAppliedRulesField('appliedRules'); // Same field name for this test&#10;&#10;            const rule2 = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'field-test-2',&#10;                {email: 'bob@example.com'},&#10;                {name: 'Bob Field Test 2'}&#10;            );&#10;&#10;            await rulesEngine.applyRules([rule2], 'users');&#10;&#10;            // Verify both rules are tracked&#10;            users = await rulesEngine.getRowsWithAppliedRules('users', {email: 'bob@example.com'});&#10;            expect(users[0].appliedRules).toEqual(['field-test-1', 'field-test-2']);&#10;        });&#10;&#10;        it('should track rules in transaction correctly', async () =&gt; {&#10;            const rules = [&#10;                MatchRuleFactory.createRule&lt;User&gt;(&#10;                    'transaction-rule-1',&#10;                    {email: 'john@example.com'},&#10;                    {name: 'John Transaction 1'}&#10;                ),&#10;                MatchRuleFactory.createRule&lt;User&gt;(&#10;                    'transaction-rule-2',&#10;                    {email: 'jane@example.com'},&#10;                    {name: 'Jane Transaction 2'}&#10;                )&#10;            ];&#10;&#10;            // Apply both rules in a single transaction&#10;            const affectedRows = await rulesEngine.applyRules(rules, 'users');&#10;            expect(affectedRows).toBe(2);&#10;&#10;            // Verify both rules were tracked&#10;            const johnUsers = await rulesEngine.getRowsWithAppliedRules('users', {email: 'john@example.com'});&#10;            const janeUsers = await rulesEngine.getRowsWithAppliedRules('users', {email: 'jane@example.com'});&#10;&#10;            expect(johnUsers[0].appliedRules).toEqual(['transaction-rule-1']);&#10;            expect(janeUsers[0].appliedRules).toEqual(['transaction-rule-2']);&#10;        });&#10;    });&#10;&#10;    describe('appliedRulesField configuration', () =&gt; {&#10;        it('should allow setting and changing appliedRulesField', () =&gt; {&#10;            expect(() =&gt; rulesEngine.setAppliedRulesField('customField')).not.toThrow();&#10;            expect(() =&gt; rulesEngine.setAppliedRulesField('  anotherField  ')).not.toThrow();&#10;        });&#10;&#10;        it('should work without appliedRulesField configured', async () =&gt; {&#10;            // Create engine without setting appliedRulesField&#10;            const basicEngine = new PgRulesEngine(db);&#10;&#10;            const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'no-tracking-rule',&#10;                {email: 'alice@example.com'},&#10;                {name: 'Alice No Tracking'}&#10;            );&#10;&#10;            const affectedRows = await basicEngine.applyRules([rule], 'users');&#10;            expect(affectedRows).toBe(1);&#10;&#10;            // Verify the rule was applied but no tracking occurred&#10;            const user = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'alice@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(user.name).toBe('Alice No Tracking');&#10;            // appliedRules field should still be null/empty since no tracking was configured&#10;        });&#10;    });&#10;&#10;    describe('regex matching functionality', () =&gt; {&#10;        beforeEach(async () =&gt; {&#10;            // Insert additional test data with various categories and statuses&#10;            await db&#10;                .insertInto('users')&#10;                .values([&#10;                    { email: 'user1@test.com', name: 'User One' },&#10;                    { email: 'user2@test.com', name: 'User Two' },&#10;                    { email: 'user3@test.com', name: 'User Three' },&#10;                ])&#10;                .execute();&#10;        });&#10;&#10;        it('should match strings using regex patterns with OR operator', async () =&gt; {&#10;            // Add a category column for testing (simulating extended User type)&#10;            await db.schema&#10;                .alterTable('users')&#10;                .addColumn('category', 'text')&#10;                .execute();&#10;&#10;            // Set different categories&#10;            await db.updateTable('users').set({ category: 'Groceries' }).where('email', '=', 'user1@test.com').execute();&#10;            await db.updateTable('users').set({ category: 'Food' }).where('email', '=', 'user2@test.com').execute();&#10;            await db.updateTable('users').set({ category: 'Electronics' }).where('email', '=', 'user3@test.com').execute();&#10;&#10;            const rule = MatchRuleFactory.createRule(&#10;                'category-food-rule',&#10;                { category: 'Groceries|Food' }, // Should match both &quot;Groceries&quot; and &quot;Food&quot;&#10;                { name: 'Food Category User' }&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(2); // Should match 2 users (Groceries and Food)&#10;&#10;            // Verify only the matching users were updated&#10;            const updatedUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Food Category User')&#10;                .execute();&#10;&#10;            expect(updatedUsers).toHaveLength(2);&#10;            expect(updatedUsers.map(u =&gt; u.category).sort()).toEqual(['Food', 'Groceries']);&#10;        });&#10;&#10;        it('should match exact string patterns', async () =&gt; {&#10;            // Test exact string matching (no special regex characters)&#10;            const rule = MatchRuleFactory.createRule(&#10;                'exact-email-rule',&#10;                { email: 'john@example.com' }, // Exact match&#10;                { name: 'Exact Match User' }&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(1); // Should match exactly one user&#10;&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'john@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(updatedUser.name).toBe('Exact Match User');&#10;        });&#10;&#10;        it('should handle regex patterns with special characters', async () =&gt; {&#10;            // Add status column for testing&#10;            await db.schema&#10;                .alterTable('users')&#10;                .addColumn('status', 'text')&#10;                .execute();&#10;&#10;            // Set various statuses&#10;            await db.updateTable('users').set({ status: 'active' }).where('email', '=', 'john@example.com').execute();&#10;            await db.updateTable('users').set({ status: 'inactive' }).where('email', '=', 'jane@example.com').execute();&#10;            await db.updateTable('users').set({ status: 'pending' }).where('email', '=', 'bob@example.com').execute();&#10;&#10;            const rule = MatchRuleFactory.createRule(&#10;                'status-pattern-rule',&#10;                { status: '^(active|pending)$' }, // Should match &quot;active&quot; or &quot;pending&quot; exactly&#10;                { name: 'Active or Pending User' }&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(2); // Should match 2 users (active and pending)&#10;&#10;            const updatedUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Active or Pending User')&#10;                .execute();&#10;&#10;            expect(updatedUsers).toHaveLength(2);&#10;            expect(updatedUsers.map(u =&gt; u.status).sort()).toEqual(['active', 'pending']);&#10;        });&#10;&#10;        it('should handle case-sensitive regex matching', async () =&gt; {&#10;            // Add department column&#10;            await db.schema&#10;                .alterTable('users')&#10;                .addColumn('department', 'text')&#10;                .execute();&#10;&#10;            // Set departments with different cases&#10;            await db.updateTable('users').set({ department: 'Engineering' }).where('email', '=', 'john@example.com').execute();&#10;            await db.updateTable('users').set({ department: 'engineering' }).where('email', '=', 'jane@example.com').execute();&#10;            await db.updateTable('users').set({ department: 'ENGINEERING' }).where('email', '=', 'bob@example.com').execute();&#10;&#10;            const rule = MatchRuleFactory.createRule(&#10;                'case-sensitive-rule',&#10;                { department: 'Engineering' }, // Should only match exact case&#10;                { name: 'Exact Case Match' }&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(1); // Should match only one user (exact case)&#10;&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Exact Case Match')&#10;                .executeTakeFirst();&#10;&#10;            expect(updatedUser.department).toBe('Engineering');&#10;        });&#10;&#10;        it('should use direct equality for non-string values', async () =&gt; {&#10;            // Add numeric and boolean columns&#10;            await db.schema&#10;                .alterTable('users')&#10;                .addColumn('age', 'integer')&#10;                .addColumn('is_verified', 'boolean')&#10;                .execute();&#10;&#10;            // Set test data&#10;            await db.updateTable('users').set({ age: 25, is_verified: true }).where('email', '=', 'john@example.com').execute();&#10;            await db.updateTable('users').set({ age: 30, is_verified: false }).where('email', '=', 'jane@example.com').execute();&#10;            await db.updateTable('users').set({ age: 25, is_verified: true }).where('email', '=', 'bob@example.com').execute();&#10;&#10;            const rule = MatchRuleFactory.createRule(&#10;                'non-string-rule',&#10;                {&#10;                    age: 25,           // Number - should use direct equality&#10;                    is_verified: true  // Boolean - should use direct equality&#10;                },&#10;                { name: 'Non-String Match' }&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(2); // Should match 2 users with age=25 AND is_verified=true&#10;&#10;            const updatedUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Non-String Match')&#10;                .execute();&#10;&#10;            expect(updatedUsers).toHaveLength(2);&#10;            expect(updatedUsers.every(u =&gt; u.age === 25 &amp;&amp; u.is_verified === true)).toBe(true);&#10;        });&#10;&#10;        it('should handle mixed string and non-string conditions', async () =&gt; {&#10;            // Add mixed columns&#10;            await db.schema&#10;                .alterTable('users')&#10;                .addColumn('role', 'text')&#10;                .addColumn('priority', 'integer')&#10;                .execute();&#10;&#10;            // Set test data&#10;            await db.updateTable('users').set({ role: 'admin', priority: 1 }).where('email', '=', 'john@example.com').execute();&#10;            await db.updateTable('users').set({ role: 'user', priority: 1 }).where('email', '=', 'jane@example.com').execute();&#10;            await db.updateTable('users').set({ role: 'admin', priority: 2 }).where('email', '=', 'bob@example.com').execute();&#10;&#10;            const rule = MatchRuleFactory.createRule(&#10;                'mixed-conditions-rule',&#10;                {&#10;                    role: 'admin|user',  // String - should use regex&#10;                    priority: 1          // Number - should use direct equality&#10;                },&#10;                { name: 'Mixed Conditions Match' }&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(2); // Should match users with (admin OR user) AND priority=1&#10;&#10;            const updatedUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Mixed Conditions Match')&#10;                .execute();&#10;&#10;            expect(updatedUsers).toHaveLength(2);&#10;            expect(updatedUsers.every(u =&gt; u.priority === 1)).toBe(true);&#10;            expect(updatedUsers.map(u =&gt; u.role).sort()).toEqual(['admin', 'user']);&#10;        });&#10;&#10;        it('should handle regex patterns with no matches', async () =&gt; {&#10;            const rule = MatchRuleFactory.createRule(&#10;                'no-match-regex-rule',&#10;                { email: 'nonexistent.*pattern' }, // Regex that matches nothing&#10;                { name: 'Should Not Match' }&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(0);&#10;&#10;            // Verify no users were updated&#10;            const updatedUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Should Not Match')&#10;                .execute();&#10;&#10;            expect(updatedUsers).toHaveLength(0);&#10;        });&#10;&#10;        it('should handle regex patterns with dot metacharacter', async () =&gt; {&#10;            // Test dot (.) metacharacter matching any character&#10;            const rule = MatchRuleFactory.createRule(&#10;                'dot-pattern-rule',&#10;                { email: 'j..n@example.com' }, // Should match &quot;john@example.com&quot;&#10;                { name: 'Dot Pattern Match' }&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(1);&#10;&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'john@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(updatedUser.name).toBe('Dot Pattern Match');&#10;        });&#10;&#10;        it('should handle complex regex patterns', async () =&gt; {&#10;            // Add phone column for testing&#10;            await db.schema&#10;                .alterTable('users')&#10;                .addColumn('phone', 'text')&#10;                .execute();&#10;&#10;            // Set phone numbers&#10;            await db.updateTable('users').set({ phone: '+1-555-123-4567' }).where('email', '=', 'john@example.com').execute();&#10;            await db.updateTable('users').set({ phone: '555.123.4568' }).where('email', '=', 'jane@example.com').execute();&#10;            await db.updateTable('users').set({ phone: '(555) 123-4569' }).where('email', '=', 'bob@example.com').execute();&#10;            await db.updateTable('users').set({ phone: '5551234570' }).where('email', '=', 'alice@example.com').execute();&#10;&#10;            const rule = MatchRuleFactory.createRule(&#10;                'phone-pattern-rule',&#10;                { phone: '.*555.*123.*' }, // Should match any phone with 555 and 123&#10;                { name: 'Phone Pattern Match' }&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(4); // Should match all phone numbers containing 555 and 123&#10;&#10;            const updatedUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Phone Pattern Match')&#10;                .execute();&#10;&#10;            expect(updatedUsers).toHaveLength(4);&#10;        });&#10;    });&#10;});&#10;" />
              <option name="updatedContent" value="import {createTestDatabase} from './test-database';&#10;import {PgRulesEngine} from './PgRulesEngine';&#10;import {User} from './database.types';&#10;import {MatchRuleFactory} from &quot;./MatchRuleFactory&quot;;&#10;&#10;describe('PgRulesEngine', () =&gt; {&#10;    let db: any;&#10;    let rulesEngine: PgRulesEngine;&#10;&#10;    beforeEach(async () =&gt; {&#10;        db = createTestDatabase();&#10;        rulesEngine = new PgRulesEngine(db);&#10;&#10;        // Insert test users&#10;        await db&#10;            .insertInto('users')&#10;            .values([&#10;                {email: 'john@example.com', name: 'John Doe'},&#10;                {email: 'jane@example.com', name: 'Jane Smith'},&#10;                {email: 'bob@example.com', name: 'Bob Johnson'},&#10;                {email: 'alice@example.com', name: 'Alice Brown'},&#10;            ])&#10;            .execute();&#10;    });&#10;&#10;    describe('applyRules', () =&gt; {&#10;        it('should apply a single rule to update user names', async () =&gt; {&#10;            // Create a rule to update John's name&#10;            const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'update-john-name',&#10;                {email: 'john@example.com'},&#10;                {name: 'John Updated'}&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(1);&#10;&#10;            // Verify the update was applied&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'john@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(updatedUser.name).toBe('John Updated');&#10;        });&#10;&#10;        it('should apply multiple rules in a single transaction', async () =&gt; {&#10;            const rules = [&#10;                MatchRuleFactory.createRule&lt;User&gt;(&#10;                    'update-john',&#10;                    {email: 'john@example.com'},&#10;                    {name: 'John Modified'}&#10;                ),&#10;                MatchRuleFactory.createRule&lt;User&gt;(&#10;                    'update-jane',&#10;                    {email: 'jane@example.com'},&#10;                    {name: 'Jane Modified'}&#10;                ),&#10;            ];&#10;&#10;            const affectedRows = await rulesEngine.applyRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(2);&#10;&#10;            // Verify both updates were applied&#10;            const users = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', 'in', ['john@example.com', 'jane@example.com'])&#10;                .execute();&#10;&#10;            expect(users).toHaveLength(2);&#10;            expect(users.find((u: User) =&gt; u.email === 'john@example.com')?.name).toBe('John Modified');&#10;            expect(users.find((u: User) =&gt; u.email === 'jane@example.com')?.name).toBe('Jane Modified');&#10;        });&#10;&#10;        it('should handle rules with multiple match conditions', async () =&gt; {&#10;            // First, update one user to have a specific name&#10;            await db&#10;                .updateTable('users')&#10;                .set({name: 'Target User'})&#10;                .where('email', '=', 'bob@example.com')&#10;                .execute();&#10;&#10;            const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'update-specific-user',&#10;                {email: 'bob@example.com', name: 'Target User'},&#10;                {name: 'Updated Target User'}&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(1);&#10;&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'bob@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(updatedUser.name).toBe('Updated Target User');&#10;        });&#10;&#10;        it('should return 0 when no rules match any records', async () =&gt; {&#10;            const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'update-nonexistent',&#10;                {email: 'nonexistent@example.com'},&#10;                {name: 'Should Not Update'}&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(0);&#10;&#10;            // Verify no users were changed&#10;            const allUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .execute();&#10;&#10;            expect(allUsers).toHaveLength(4);&#10;            expect(allUsers.every((u: User) =&gt; !u.name.includes('Should Not Update'))).toBe(true);&#10;        });&#10;&#10;        it('should return 0 when given an empty rules array', async () =&gt; {&#10;            const affectedRows = await rulesEngine.applyRules([], 'users');&#10;&#10;            expect(affectedRows).toBe(0);&#10;        });&#10;&#10;        it('should skip rules with empty apply objects', async () =&gt; {&#10;            const rules = [&#10;                MatchRuleFactory.createRule&lt;User&gt;(&#10;                    'empty-apply',&#10;                    {email: 'john@example.com'},&#10;                    {} // Empty apply object&#10;                ),&#10;                MatchRuleFactory.createRule&lt;User&gt;(&#10;                    'valid-rule',&#10;                    {email: 'jane@example.com'},&#10;                    {name: 'Jane Updated'}&#10;                ),&#10;            ];&#10;&#10;            const affectedRows = await rulesEngine.applyRules(rules, 'users');&#10;&#10;            expect(affectedRows).toBe(1); // Only the valid rule should be applied&#10;&#10;            // Verify only Jane was updated&#10;            const john = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'john@example.com')&#10;                .executeTakeFirst();&#10;&#10;            const jane = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'jane@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(john.name).toBe('John Doe'); // Unchanged&#10;            expect(jane.name).toBe('Jane Updated'); // Changed&#10;        });&#10;&#10;        it('should handle rules that update multiple fields', async () =&gt; {&#10;            const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'update-multiple-fields',&#10;                {email: 'alice@example.com'},&#10;                {&#10;                    name: 'Alice Updated',&#10;                    email: 'alice.updated@example.com'&#10;                }&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(1);&#10;&#10;            // Verify both fields were updated&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'alice.updated@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(updatedUser).toBeDefined();&#10;            expect(updatedUser.name).toBe('Alice Updated');&#10;            expect(updatedUser.email).toBe('alice.updated@example.com');&#10;        });&#10;&#10;        it('should maintain transaction integrity on error', async () =&gt; {&#10;            // Do not write this test.&#10;        });&#10;    });&#10;&#10;    describe('appliedRulesField functionality', () =&gt; {&#10;        beforeEach(async () =&gt; {&#10;            // Set up appliedRulesField for these tests&#10;            rulesEngine.setAppliedRulesField('appliedRules');&#10;        });&#10;&#10;        it('should track applied rules when appliedRulesField is configured', async () =&gt; {&#10;            const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'track-rule',&#10;                {email: 'john@example.com'},&#10;                {name: 'John Tracked'}&#10;            );&#10;&#10;            await rulesEngine.applyRules([rule], 'users');&#10;&#10;            // Verify the rule was applied and tracked&#10;            const users = await rulesEngine.getRowsWithAppliedRules&lt;User&gt;('users', {email: 'john@example.com'});&#10;&#10;            expect(users).toHaveLength(1);&#10;            expect(users[0].name).toBe('John Tracked');&#10;            expect(users[0].appliedRules).toEqual(['track-rule']);&#10;        });&#10;&#10;        it('should track multiple rules applied to the same row', async () =&gt; {&#10;            const rules = [&#10;                MatchRuleFactory.createRule&lt;User&gt;(&#10;                    'first-rule',&#10;                    {email: 'jane@example.com'},&#10;                    {name: 'Jane First'}&#10;                ),&#10;                MatchRuleFactory.createRule&lt;User&gt;(&#10;                    'second-rule',&#10;                    {email: 'jane@example.com'},&#10;                    {name: 'Jane Second'}&#10;                )&#10;            ];&#10;&#10;            // Apply first rule&#10;            await rulesEngine.applyRules([rules[0]], 'users');&#10;&#10;            // Apply second rule&#10;            await rulesEngine.applyRules([rules[1]], 'users');&#10;&#10;            const users = await rulesEngine.getRowsWithAppliedRules&lt;User&gt;('users', {email: 'jane@example.com'});&#10;&#10;            expect(users).toHaveLength(1);&#10;            expect(users[0].name).toBe('Jane Second');&#10;            expect(users[0].appliedRules).toEqual(['first-rule', 'second-rule']);&#10;        });&#10;&#10;        it('should handle rows with no applied rules', async () =&gt; {&#10;            const users = await rulesEngine.getRowsWithAppliedRules&lt;User&gt;('users', {email: 'bob@example.com'});&#10;&#10;            expect(users).toHaveLength(1);&#10;            expect(users[0].name).toBe('Bob Johnson'); // Original name&#10;            expect(users[0].appliedRules).toEqual([]);&#10;        });&#10;&#10;        it('should clear applied rules for specific conditions', async () =&gt; {&#10;            // First apply a rule&#10;            const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'clear-test-rule',&#10;                {email: 'alice@example.com'},&#10;                {name: 'Alice Modified'}&#10;            );&#10;&#10;            await rulesEngine.applyRules([rule], 'users');&#10;&#10;            // Verify rule was tracked&#10;            let users = await rulesEngine.getRowsWithAppliedRules&lt;User&gt;('users', {email: 'alice@example.com'});&#10;            expect(users[0].appliedRules).toEqual(['clear-test-rule']);&#10;&#10;            // Clear applied rules for Alice&#10;            const clearedRows = await rulesEngine.clearAppliedRules('users', {email: 'alice@example.com'});&#10;            expect(clearedRows).toBe(1);&#10;&#10;            // Verify applied rules were cleared&#10;            users = await rulesEngine.getRowsWithAppliedRules&lt;User&gt;('users', {email: 'alice@example.com'});&#10;            expect(users[0].appliedRules).toEqual([]);&#10;        });&#10;&#10;        it('should clear applied rules for all rows when no conditions provided', async () =&gt; {&#10;            // Apply rules to multiple users&#10;            const rules = [&#10;                MatchRuleFactory.createRule&lt;User&gt;(&#10;                    'bulk-rule-1',&#10;                    {email: 'john@example.com'},&#10;                    {name: 'John Bulk'}&#10;                ),&#10;                MatchRuleFactory.createRule&lt;User&gt;(&#10;                    'bulk-rule-2',&#10;                    {email: 'jane@example.com'},&#10;                    {name: 'Jane Bulk'}&#10;                )&#10;            ];&#10;&#10;            await rulesEngine.applyRules(rules, 'users');&#10;&#10;            // Verify rules were tracked&#10;            let allUsers = await rulesEngine.getRowsWithAppliedRules('users');&#10;            const trackedUsers = allUsers.filter(u =&gt; u.appliedRules &amp;&amp; u.appliedRules.length &gt; 0);&#10;            expect(trackedUsers).toHaveLength(2);&#10;&#10;            // Clear all applied rules&#10;            const clearedRows = await rulesEngine.clearAppliedRules('users');&#10;            expect(clearedRows).toBe(4); // All 4 users should be updated&#10;&#10;            // Verify all applied rules were cleared&#10;            allUsers = await rulesEngine.getRowsWithAppliedRules('users');&#10;            expect(allUsers.every(u =&gt; u.appliedRules?.length === 0)).toBe(true);&#10;        });&#10;&#10;        it('should throw error when getRowsWithAppliedRules called without configuring appliedRulesField', async () =&gt; {&#10;            const engineWithoutField = new PgRulesEngine(db);&#10;&#10;            await expect(engineWithoutField.getRowsWithAppliedRules('users')).rejects.toThrow(&#10;                'appliedRulesField is not configured. Use setAppliedRulesField() first.'&#10;            );&#10;        });&#10;&#10;        it('should throw error when clearAppliedRules called without configuring appliedRulesField', async () =&gt; {&#10;            const engineWithoutField = new PgRulesEngine(db);&#10;&#10;            await expect(engineWithoutField.clearAppliedRules('users')).rejects.toThrow(&#10;                'appliedRulesField is not configured. Use setAppliedRulesField() first.'&#10;            );&#10;        });&#10;&#10;        it('should filter rows correctly with WHERE conditions in getRowsWithAppliedRules', async () =&gt; {&#10;            // Apply rules to different users&#10;            const rules = [&#10;                MatchRuleFactory.createRule&lt;User&gt;(&#10;                    'filter-rule-1',&#10;                    {email: 'john@example.com'},&#10;                    {name: 'John Filtered'}&#10;                ),&#10;                MatchRuleFactory.createRule&lt;User&gt;(&#10;                    'filter-rule-2',&#10;                    {email: 'jane@example.com'},&#10;                    {name: 'Jane Filtered'}&#10;                )&#10;            ];&#10;&#10;            await rulesEngine.applyRules(rules, 'users');&#10;&#10;            // Get only John's data&#10;            const johnUsers = await rulesEngine.getRowsWithAppliedRules('users', {email: 'john@example.com'});&#10;            expect(johnUsers).toHaveLength(1);&#10;            expect(johnUsers[0].email).toBe('john@example.com');&#10;            expect(johnUsers[0].appliedRules).toEqual(['filter-rule-1']);&#10;&#10;            // Get only Jane's data&#10;            const janeUsers = await rulesEngine.getRowsWithAppliedRules('users', {email: 'jane@example.com'});&#10;            expect(janeUsers).toHaveLength(1);&#10;            expect(janeUsers[0].email).toBe('jane@example.com');&#10;            expect(janeUsers[0].appliedRules).toEqual(['filter-rule-2']);&#10;        });&#10;&#10;        it('should work correctly when appliedRulesField is changed between operations', async () =&gt; {&#10;            // Apply rule with first field name&#10;            const rule1 = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'field-test-1',&#10;                {email: 'bob@example.com'},&#10;                {name: 'Bob Field Test'}&#10;            );&#10;&#10;            await rulesEngine.applyRules([rule1], 'users');&#10;&#10;            // Verify tracking with first field&#10;            let users = await rulesEngine.getRowsWithAppliedRules('users', {email: 'bob@example.com'});&#10;            expect(users[0].appliedRules).toEqual(['field-test-1']);&#10;&#10;            // Change the field name and apply another rule&#10;            rulesEngine.setAppliedRulesField('appliedRules'); // Same field name for this test&#10;&#10;            const rule2 = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'field-test-2',&#10;                {email: 'bob@example.com'},&#10;                {name: 'Bob Field Test 2'}&#10;            );&#10;&#10;            await rulesEngine.applyRules([rule2], 'users');&#10;&#10;            // Verify both rules are tracked&#10;            users = await rulesEngine.getRowsWithAppliedRules('users', {email: 'bob@example.com'});&#10;            expect(users[0].appliedRules).toEqual(['field-test-1', 'field-test-2']);&#10;        });&#10;&#10;        it('should track rules in transaction correctly', async () =&gt; {&#10;            const rules = [&#10;                MatchRuleFactory.createRule&lt;User&gt;(&#10;                    'transaction-rule-1',&#10;                    {email: 'john@example.com'},&#10;                    {name: 'John Transaction 1'}&#10;                ),&#10;                MatchRuleFactory.createRule&lt;User&gt;(&#10;                    'transaction-rule-2',&#10;                    {email: 'jane@example.com'},&#10;                    {name: 'Jane Transaction 2'}&#10;                )&#10;            ];&#10;&#10;            // Apply both rules in a single transaction&#10;            const affectedRows = await rulesEngine.applyRules(rules, 'users');&#10;            expect(affectedRows).toBe(2);&#10;&#10;            // Verify both rules were tracked&#10;            const johnUsers = await rulesEngine.getRowsWithAppliedRules('users', {email: 'john@example.com'});&#10;            const janeUsers = await rulesEngine.getRowsWithAppliedRules('users', {email: 'jane@example.com'});&#10;&#10;            expect(johnUsers[0].appliedRules).toEqual(['transaction-rule-1']);&#10;            expect(janeUsers[0].appliedRules).toEqual(['transaction-rule-2']);&#10;        });&#10;    });&#10;&#10;    describe('appliedRulesField configuration', () =&gt; {&#10;        it('should allow setting and changing appliedRulesField', () =&gt; {&#10;            expect(() =&gt; rulesEngine.setAppliedRulesField('customField')).not.toThrow();&#10;            expect(() =&gt; rulesEngine.setAppliedRulesField('  anotherField  ')).not.toThrow();&#10;        });&#10;&#10;        it('should work without appliedRulesField configured', async () =&gt; {&#10;            // Create engine without setting appliedRulesField&#10;            const basicEngine = new PgRulesEngine(db);&#10;&#10;            const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'no-tracking-rule',&#10;                {email: 'alice@example.com'},&#10;                {name: 'Alice No Tracking'}&#10;            );&#10;&#10;            const affectedRows = await basicEngine.applyRules([rule], 'users');&#10;            expect(affectedRows).toBe(1);&#10;&#10;            // Verify the rule was applied but no tracking occurred&#10;            const user = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'alice@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(user.name).toBe('Alice No Tracking');&#10;            // appliedRules field should still be null/empty since no tracking was configured&#10;        });&#10;    });&#10;&#10;    describe('regex matching functionality', () =&gt; {&#10;        beforeEach(async () =&gt; {&#10;            // Insert additional test data with various categories and statuses&#10;            await db&#10;                .insertInto('users')&#10;                .values([&#10;                    { email: 'user1@test.com', name: 'User One' },&#10;                    { email: 'user2@test.com', name: 'User Two' },&#10;                    { email: 'user3@test.com', name: 'User Three' },&#10;                ])&#10;                .execute();&#10;        });&#10;&#10;        it('should match strings using regex patterns with OR operator', async () =&gt; {&#10;            // Set different roles (role column already exists in User schema)&#10;            await db.updateTable('users').set({ role: 'admin' }).where('email', '=', 'user1@test.com').execute();&#10;            await db.updateTable('users').set({ role: 'moderator' }).where('email', '=', 'user2@test.com').execute();&#10;            await db.updateTable('users').set({ role: 'guest' }).where('email', '=', 'user3@test.com').execute();&#10;&#10;            const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'role-staff-rule',&#10;                { role: 'admin|moderator' }, // Should match both &quot;admin&quot; and &quot;moderator&quot;&#10;                { name: 'Staff Member' }&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(2); // Should match 2 users (admin and moderator)&#10;&#10;            // Verify only the matching users were updated&#10;            const updatedUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Staff Member')&#10;                .execute();&#10;&#10;            expect(updatedUsers).toHaveLength(2);&#10;            expect(updatedUsers.map(u =&gt; u.role).sort()).toEqual(['admin', 'moderator']);&#10;        });&#10;&#10;        it('should match exact string patterns', async () =&gt; {&#10;            // Test exact string matching (no special regex characters)&#10;            const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'exact-email-rule',&#10;                { email: 'john@example.com' }, // Exact match&#10;                { name: 'Exact Match User' }&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(1); // Should match exactly one user&#10;&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'john@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(updatedUser.name).toBe('Exact Match User');&#10;        });&#10;&#10;        it('should handle regex patterns with special characters', async () =&gt; {&#10;            // Add status column for testing&#10;            await db.schema&#10;                .alterTable('users')&#10;                .addColumn('status', 'text')&#10;                .execute();&#10;&#10;            // Set various statuses&#10;            await db.updateTable('users').set({ status: 'active' }).where('email', '=', 'john@example.com').execute();&#10;            await db.updateTable('users').set({ status: 'inactive' }).where('email', '=', 'jane@example.com').execute();&#10;            await db.updateTable('users').set({ status: 'pending' }).where('email', '=', 'bob@example.com').execute();&#10;&#10;            const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'status-pattern-rule',&#10;                { status: '^(active|pending)$' }, // Should match &quot;active&quot; or &quot;pending&quot; exactly&#10;                { name: 'Active or Pending User' }&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(2); // Should match 2 users (active and pending)&#10;&#10;            const updatedUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Active or Pending User')&#10;                .execute();&#10;&#10;            expect(updatedUsers).toHaveLength(2);&#10;            expect(updatedUsers.map(u =&gt; u.status).sort()).toEqual(['active', 'pending']);&#10;        });&#10;&#10;        it('should handle case-sensitive regex matching', async () =&gt; {&#10;            // Set roles with different cases&#10;            await db.updateTable('users').set({ role: 'Admin' }).where('email', '=', 'john@example.com').execute();&#10;            await db.updateTable('users').set({ role: 'admin' }).where('email', '=', 'jane@example.com').execute();&#10;            await db.updateTable('users').set({ role: 'ADMIN' }).where('email', '=', 'bob@example.com').execute();&#10;&#10;            const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'case-sensitive-rule',&#10;                { role: 'Admin' }, // Should only match exact case&#10;                { name: 'Exact Case Match' }&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(1); // Should match only one user (exact case)&#10;&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Exact Case Match')&#10;                .executeTakeFirst();&#10;&#10;            expect(updatedUser.role).toBe('Admin');&#10;        });&#10;&#10;        it('should use direct equality for non-string values', async () =&gt; {&#10;            // Add numeric and boolean columns&#10;            await db.schema&#10;                .alterTable('users')&#10;                .addColumn('age', 'integer')&#10;                .addColumn('is_verified', 'boolean')&#10;                .execute();&#10;&#10;            // Set test data&#10;            await db.updateTable('users').set({ age: 25, is_verified: true }).where('email', '=', 'john@example.com').execute();&#10;            await db.updateTable('users').set({ age: 30, is_verified: false }).where('email', '=', 'jane@example.com').execute();&#10;            await db.updateTable('users').set({ age: 25, is_verified: true }).where('email', '=', 'bob@example.com').execute();&#10;&#10;            const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'non-string-rule',&#10;                {&#10;                    age: 25,           // Number - should use direct equality&#10;                    is_verified: true  // Boolean - should use direct equality&#10;                },&#10;                { name: 'Non-String Match' }&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(2); // Should match 2 users with age=25 AND is_verified=true&#10;&#10;            const updatedUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Non-String Match')&#10;                .execute();&#10;&#10;            expect(updatedUsers).toHaveLength(2);&#10;            expect(updatedUsers.every(u =&gt; u.age === 25 &amp;&amp; u.is_verified === true)).toBe(true);&#10;        });&#10;&#10;        it('should handle mixed string and non-string conditions', async () =&gt; {&#10;            // Add priority column&#10;            await db.schema&#10;                .alterTable('users')&#10;                .addColumn('priority', 'integer')&#10;                .execute();&#10;&#10;            // Set test data using role (already exists) and priority&#10;            await db.updateTable('users').set({ role: 'admin', priority: 1 }).where('email', '=', 'john@example.com').execute();&#10;            await db.updateTable('users').set({ role: 'user', priority: 1 }).where('email', '=', 'jane@example.com').execute();&#10;            await db.updateTable('users').set({ role: 'admin', priority: 2 }).where('email', '=', 'bob@example.com').execute();&#10;&#10;            const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'mixed-conditions-rule',&#10;                {&#10;                    role: 'admin|user',  // String - should use regex&#10;                    priority: 1          // Number - should use direct equality&#10;                },&#10;                { name: 'Mixed Conditions Match' }&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(2); // Should match users with (admin OR user) AND priority=1&#10;&#10;            const updatedUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Mixed Conditions Match')&#10;                .execute();&#10;&#10;            expect(updatedUsers).toHaveLength(2);&#10;            expect(updatedUsers.every(u =&gt; u.priority === 1)).toBe(true);&#10;            expect(updatedUsers.map(u =&gt; u.role).sort()).toEqual(['admin', 'user']);&#10;        });&#10;&#10;        it('should handle regex patterns with no matches', async () =&gt; {&#10;            const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'no-match-regex-rule',&#10;                { email: 'nonexistent.*pattern' }, // Regex that matches nothing&#10;                { name: 'Should Not Match' }&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(0);&#10;&#10;            // Verify no users were updated&#10;            const updatedUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Should Not Match')&#10;                .execute();&#10;&#10;            expect(updatedUsers).toHaveLength(0);&#10;        });&#10;&#10;        it('should handle regex patterns with dot metacharacter', async () =&gt; {&#10;            // Test dot (.) metacharacter matching any character&#10;            const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'dot-pattern-rule',&#10;                { email: 'j..n@example.com' }, // Should match &quot;john@example.com&quot;&#10;                { name: 'Dot Pattern Match' }&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(1);&#10;&#10;            const updatedUser = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('email', '=', 'john@example.com')&#10;                .executeTakeFirst();&#10;&#10;            expect(updatedUser.name).toBe('Dot Pattern Match');&#10;        });&#10;&#10;        it('should handle complex regex patterns', async () =&gt; {&#10;            // Add phone column for testing&#10;            await db.schema&#10;                .alterTable('users')&#10;                .addColumn('phone', 'text')&#10;                .execute();&#10;&#10;            // Set phone numbers&#10;            await db.updateTable('users').set({ phone: '+1-555-123-4567' }).where('email', '=', 'john@example.com').execute();&#10;            await db.updateTable('users').set({ phone: '555.123.4568' }).where('email', '=', 'jane@example.com').execute();&#10;            await db.updateTable('users').set({ phone: '(555) 123-4569' }).where('email', '=', 'bob@example.com').execute();&#10;            await db.updateTable('users').set({ phone: '5551234570' }).where('email', '=', 'alice@example.com').execute();&#10;&#10;            const rule = MatchRuleFactory.createRule&lt;User&gt;(&#10;                'phone-pattern-rule',&#10;                { phone: '.*555.*123.*' }, // Should match any phone with 555 and 123&#10;                { name: 'Phone Pattern Match' }&#10;            );&#10;&#10;            const affectedRows = await rulesEngine.applyRules([rule], 'users');&#10;&#10;            expect(affectedRows).toBe(4); // Should match all phone numbers containing 555 and 123&#10;&#10;            const updatedUsers = await db&#10;                .selectFrom('users')&#10;                .selectAll()&#10;                .where('name', '=', 'Phone Pattern Match')&#10;                .execute();&#10;&#10;            expect(updatedUsers).toHaveLength(4);&#10;        });&#10;    });&#10;});&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/PgRulesEngine.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/PgRulesEngine.ts" />
              <option name="originalContent" value="import {Kysely, sql} from 'kysely';&#10;import {MatchRule} from &quot;@/MatchRule&quot;;&#10;&#10;/**&#10; * PostgreSQL based rule engine that applies match rules to database tables.&#10; * applyRules is the main method to apply multiple rules in a single transaction.&#10; * applyRules always applied given rules without considering previously applied rules.&#10; */&#10;export class PgRulesEngine {&#10;&#10;    /**&#10;     * Additional field name in the target table to track applied rules.&#10;     * For example, appliedRulesField can be set to &quot;appliedRules TEXT[]&quot;, then applied rule&#10;     * will be added to the JSON array in this field. Specified &quot;appliedRules TEXT[]&quot; must be a PostgreSQL TEXT array type.&#10;     *&#10;     * @private&#10;     */&#10;    private appliedRulesField: string | null = null;&#10;&#10;    constructor(private db: Kysely&lt;any&gt;) {&#10;    }&#10;&#10;    /**&#10;     * Set the field name to track applied rules&#10;     * @param fieldName Name of the field to store applied rules&#10;     */&#10;    setAppliedRulesField(fieldName: string): void {&#10;        this.appliedRulesField = fieldName.trim();&#10;    }&#10;&#10;    /**&#10;     * Apply multiple rules to a target table in a single transaction&#10;     * @param rules Array of MatchRule objects to apply&#10;     * @param targetTable Name of the table to apply rules to&#10;     * @returns Promise that resolves to the total number of affected rows&#10;     */&#10;    async applyRules&lt;T&gt;(rules: MatchRule&lt;T&gt;[], targetTable: string): Promise&lt;number&gt; {&#10;        if (!rules.length) {&#10;            return 0;&#10;        }&#10;&#10;        return await this.db.transaction().execute(async (trx) =&gt; {&#10;            let totalAffectedRows = 0;&#10;&#10;            for (const rule of rules) {&#10;                // Build the update query&#10;                let query = trx.updateTable(targetTable);&#10;&#10;                // Add SET clause from apply object&#10;                const applyEntries = Object.entries(rule.apply);&#10;                if (applyEntries.length === 0) {&#10;                    console.warn(`Rule &quot;${rule.ruleName}&quot; has no apply changes, skipping...`);&#10;                    continue; // Skip rules with no apply changes&#10;                }&#10;&#10;                // Start with the apply object changes&#10;                const updateObject: Record&lt;string, any&gt; = {...rule.apply};&#10;&#10;                // Add appliedRulesField tracking if configured&#10;                if (this.appliedRulesField) {&#10;                    // Use PostgreSQL's JSON_ARRAY_APPEND to add the rule name to the JSON array&#10;                    /*language=TEXT*/&#10;                    updateObject[this.appliedRulesField] = sql`JSON_ARRAY_APPEND(COALESCE(${sql.ref(this.appliedRulesField)}, JSON_ARRAY()), '$', ${rule.ruleName})`;&#10;                }&#10;&#10;                query = query.set(updateObject);&#10;&#10;                // Add WHERE clause from match object&#10;                const matchEntries = Object.entries(rule.match);&#10;                if (matchEntries.length === 0) {&#10;                    console.warn(`Rule &quot;${rule.ruleName}&quot; has no match conditions, skipping...`);&#10;                    continue; // Skip rules with no match conditions&#10;                }&#10;&#10;                for (const [key, value] of matchEntries) {&#10;                    query = query.where(key, '=', value);&#10;                }&#10;&#10;                // Execute the query and get affected row count&#10;                const result = await query.execute();&#10;                // Kysely's execute() returns UpdateResult[], we need the first result's numUpdatedRows&#10;                totalAffectedRows += Number(result[0]?.numUpdatedRows || 0);&#10;            }&#10;&#10;            return totalAffectedRows;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Clear applied rules tracking for rows matching the given conditions&#10;     * @param targetTable Name of the table to clear applied rules from&#10;     * @param whereConditions Conditions to match rows (optional, clears all if not provided)&#10;     * @returns Promise that resolves to the number of affected rows&#10;     */&#10;    async clearAppliedRules&lt;T&gt;(targetTable: string, whereConditions?: Partial&lt;T&gt;): Promise&lt;number&gt; {&#10;        if (!this.appliedRulesField) {&#10;            throw new Error('appliedRulesField is not configured. Use setAppliedRulesField() first.');&#10;        }&#10;&#10;        const updateObject: Record&lt;string, any&gt; = {};&#10;        /*language=TEXT*/&#10;        updateObject[this.appliedRulesField] = sql`JSON_ARRAY()`;&#10;&#10;        let query = this.db.updateTable(targetTable).set(updateObject);&#10;&#10;        // Add WHERE conditions if provided&#10;        if (whereConditions) {&#10;            const matchEntries = Object.entries(whereConditions);&#10;            for (const [key, value] of matchEntries) {&#10;                query = query.where(key, '=', value);&#10;            }&#10;        }&#10;&#10;        const result = await query.execute();&#10;        return Number(result[0]?.numUpdatedRows || 0);&#10;    }&#10;&#10;    private normalizeAppliedRules(value: unknown): string[] {&#10;        const normalizeOne = (v: unknown): string =&gt; {&#10;            if (v == null) return '';&#10;&#10;            // If it's already a JS string, try to JSON-parse it once to strip quotes&#10;            if (typeof v === 'string') {&#10;                // Fast path: JSON string literal like &quot;\&quot;track-rule\&quot;&quot; or '&quot;track-rule&quot;'&#10;                if (v.length &gt;= 2 &amp;&amp; v.startsWith('&quot;') &amp;&amp; v.endsWith('&quot;')) {&#10;                    try {&#10;                        return JSON.parse(v);&#10;                    } catch { /* fall through */&#10;                    }&#10;                    return v.slice(1, -1);&#10;                }&#10;                // Could also be a JSON array/object as string (unlikely here but safe)&#10;                try {&#10;                    const parsed = JSON.parse(v);&#10;                    if (typeof parsed === 'string') return parsed;     // '&quot;track-rule&quot;' -&gt; track-rule&#10;                    if (Array.isArray(parsed)) {&#10;                        // If someone stored '[&quot;a&quot;,&quot;b&quot;]' as a string, flatten one level&#10;                        return parsed.map(x =&gt; String(x)).join(',');&#10;                    }&#10;                    return String(parsed);&#10;                } catch {&#10;                    return v; // plain string like 'track-rule'&#10;                }&#10;            }&#10;&#10;            // If pg-mem gave us a JS scalar&#10;            if (Array.isArray(v)) {&#10;                // Shouldn't happen here (handled in outer branch), but guard anyway&#10;                return v.map(x =&gt; String(x)).join(',');&#10;            }&#10;            return String(v);&#10;        };&#10;&#10;        if (value == null) return [];&#10;&#10;        // pg-mem jsonb often arrives as real JS arrays&#10;        if (Array.isArray(value)) {&#10;            return value.map(normalizeOne);&#10;        }&#10;&#10;        // Single value paths: wrap into array&#10;        return [normalizeOne(value)];&#10;    }&#10;&#10;    /**&#10;     * Get rows with their applied rules&#10;     * @param targetTable Name of the table to query&#10;     * @param whereConditions Conditions to match rows (optional)&#10;     * @returns Promise that resolves to an array of rows with applied rules&#10;     */&#10;    async getRowsWithAppliedRules&lt;T&gt;(targetTable: string, whereConditions?: Partial&lt;T&gt;): Promise&lt;(T &amp; {&#10;        appliedRules?: string[]&#10;    })[]&gt; {&#10;        if (!this.appliedRulesField) {&#10;            throw new Error('appliedRulesField is not configured. Use setAppliedRulesField() first.');&#10;        }&#10;&#10;        let query = this.db.selectFrom(targetTable).selectAll();&#10;&#10;        // Add WHERE conditions if provided&#10;        if (whereConditions) {&#10;            const matchEntries = Object.entries(whereConditions);&#10;            for (const [key, value] of matchEntries) {&#10;                query = query.where(key, '=', value);&#10;            }&#10;        }&#10;&#10;        const rows = await query.execute();&#10;&#10;        // Parse the applied rules JSON array for each row&#10;        return rows.map(row =&gt; {&#10;            const appliedRulesValue = (row as any)[this.appliedRulesField!];&#10;            return {&#10;                ...row,&#10;                appliedRules: this.normalizeAppliedRules(appliedRulesValue),&#10;            } as T &amp; { appliedRules?: string[] };&#10;        });&#10;    }&#10;}" />
              <option name="updatedContent" value="import {Kysely, sql} from 'kysely';&#10;import {MatchRule} from &quot;@/MatchRule&quot;;&#10;&#10;/**&#10; * PostgreSQL based rule engine that applies match rules to database tables.&#10; * applyRules is the main method to apply multiple rules in a single transaction.&#10; * applyRules always applied given rules without considering previously applied rules.&#10; */&#10;export class PgRulesEngine {&#10;&#10;    /**&#10;     * Additional field name in the target table to track applied rules.&#10;     * For example, appliedRulesField can be set to &quot;appliedRules TEXT[]&quot;, then applied rule&#10;     * will be added to the JSON array in this field. Specified &quot;appliedRules TEXT[]&quot; must be a PostgreSQL TEXT array type.&#10;     *&#10;     * @private&#10;     */&#10;    private appliedRulesField: string | null = null;&#10;&#10;    constructor(private db: Kysely&lt;any&gt;) {&#10;    }&#10;&#10;    /**&#10;     * Set the field name to track applied rules&#10;     * @param fieldName Name of the field to store applied rules&#10;     */&#10;    setAppliedRulesField(fieldName: string): void {&#10;        this.appliedRulesField = fieldName.trim();&#10;    }&#10;&#10;    /**&#10;     * Apply multiple rules to a target table in a single transaction&#10;     * @param rules Array of MatchRule objects to apply&#10;     * @param targetTable Name of the table to apply rules to&#10;     * @returns Promise that resolves to the total number of affected rows&#10;     */&#10;    async applyRules&lt;T&gt;(rules: MatchRule&lt;T&gt;[], targetTable: string): Promise&lt;number&gt; {&#10;        if (!rules.length) {&#10;            return 0;&#10;        }&#10;&#10;        return await this.db.transaction().execute(async (trx) =&gt; {&#10;            let totalAffectedRows = 0;&#10;&#10;            for (const rule of rules) {&#10;                // Build the update query&#10;                let query = trx.updateTable(targetTable);&#10;&#10;                // Add SET clause from apply object&#10;                const applyEntries = Object.entries(rule.apply);&#10;                if (applyEntries.length === 0) {&#10;                    console.warn(`Rule &quot;${rule.ruleName}&quot; has no apply changes, skipping...`);&#10;                    continue; // Skip rules with no apply changes&#10;                }&#10;&#10;                // Start with the apply object changes&#10;                const updateObject: Record&lt;string, any&gt; = {...rule.apply};&#10;&#10;                // Add appliedRulesField tracking if configured&#10;                if (this.appliedRulesField) {&#10;                    // Use PostgreSQL's JSON_ARRAY_APPEND to add the rule name to the JSON array&#10;                    /*language=TEXT*/&#10;                    updateObject[this.appliedRulesField] = sql`JSON_ARRAY_APPEND(COALESCE(${sql.ref(this.appliedRulesField)}, JSON_ARRAY()), '$', ${rule.ruleName})`;&#10;                }&#10;&#10;                query = query.set(updateObject);&#10;&#10;                // Add WHERE clause from match object&#10;                const matchEntries = Object.entries(rule.match);&#10;                if (matchEntries.length === 0) {&#10;                    console.warn(`Rule &quot;${rule.ruleName}&quot; has no match conditions, skipping...`);&#10;                    continue; // Skip rules with no match conditions&#10;                }&#10;&#10;                for (const [key, value] of matchEntries) {&#10;                    if (typeof value === 'string') {&#10;                        // Use PostgreSQL regex operator for case-sensitive string matching&#10;                        query = query.where(sql`${sql.ref(key)} ~ ${value}`);&#10;                    } else {&#10;                        // Use direct equality for non-string types&#10;                        query = query.where(key, '=', value);&#10;                    }&#10;                }&#10;&#10;                // Execute the query and get affected row count&#10;                const result = await query.execute();&#10;                // Kysely's execute() returns UpdateResult[], we need the first result's numUpdatedRows&#10;                totalAffectedRows += Number(result[0]?.numUpdatedRows || 0);&#10;            }&#10;&#10;            return totalAffectedRows;&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Clear applied rules tracking for rows matching the given conditions&#10;     * @param targetTable Name of the table to clear applied rules from&#10;     * @param whereConditions Conditions to match rows (optional, clears all if not provided)&#10;     * @returns Promise that resolves to the number of affected rows&#10;     */&#10;    async clearAppliedRules&lt;T&gt;(targetTable: string, whereConditions?: Partial&lt;T&gt;): Promise&lt;number&gt; {&#10;        if (!this.appliedRulesField) {&#10;            throw new Error('appliedRulesField is not configured. Use setAppliedRulesField() first.');&#10;        }&#10;&#10;        const updateObject: Record&lt;string, any&gt; = {};&#10;        /*language=TEXT*/&#10;        updateObject[this.appliedRulesField] = sql`JSON_ARRAY()`;&#10;&#10;        let query = this.db.updateTable(targetTable).set(updateObject);&#10;&#10;        // Add WHERE conditions if provided&#10;        if (whereConditions) {&#10;            const matchEntries = Object.entries(whereConditions);&#10;            for (const [key, value] of matchEntries) {&#10;                query = query.where(key, '=', value);&#10;            }&#10;        }&#10;&#10;        const result = await query.execute();&#10;        return Number(result[0]?.numUpdatedRows || 0);&#10;    }&#10;&#10;    private normalizeAppliedRules(value: unknown): string[] {&#10;        const normalizeOne = (v: unknown): string =&gt; {&#10;            if (v == null) return '';&#10;&#10;            // If it's already a JS string, try to JSON-parse it once to strip quotes&#10;            if (typeof v === 'string') {&#10;                // Fast path: JSON string literal like &quot;\&quot;track-rule\&quot;&quot; or '&quot;track-rule&quot;'&#10;                if (v.length &gt;= 2 &amp;&amp; v.startsWith('&quot;') &amp;&amp; v.endsWith('&quot;')) {&#10;                    try {&#10;                        return JSON.parse(v);&#10;                    } catch { /* fall through */&#10;                    }&#10;                    return v.slice(1, -1);&#10;                }&#10;                // Could also be a JSON array/object as string (unlikely here but safe)&#10;                try {&#10;                    const parsed = JSON.parse(v);&#10;                    if (typeof parsed === 'string') return parsed;     // '&quot;track-rule&quot;' -&gt; track-rule&#10;                    if (Array.isArray(parsed)) {&#10;                        // If someone stored '[&quot;a&quot;,&quot;b&quot;]' as a string, flatten one level&#10;                        return parsed.map(x =&gt; String(x)).join(',');&#10;                    }&#10;                    return String(parsed);&#10;                } catch {&#10;                    return v; // plain string like 'track-rule'&#10;                }&#10;            }&#10;&#10;            // If pg-mem gave us a JS scalar&#10;            if (Array.isArray(v)) {&#10;                // Shouldn't happen here (handled in outer branch), but guard anyway&#10;                return v.map(x =&gt; String(x)).join(',');&#10;            }&#10;            return String(v);&#10;        };&#10;&#10;        if (value == null) return [];&#10;&#10;        // pg-mem jsonb often arrives as real JS arrays&#10;        if (Array.isArray(value)) {&#10;            return value.map(normalizeOne);&#10;        }&#10;&#10;        // Single value paths: wrap into array&#10;        return [normalizeOne(value)];&#10;    }&#10;&#10;    /**&#10;     * Get rows with their applied rules&#10;     * @param targetTable Name of the table to query&#10;     * @param whereConditions Conditions to match rows (optional)&#10;     * @returns Promise that resolves to an array of rows with applied rules&#10;     */&#10;    async getRowsWithAppliedRules&lt;T&gt;(targetTable: string, whereConditions?: Partial&lt;T&gt;): Promise&lt;(T &amp; {&#10;        appliedRules?: string[]&#10;    })[]&gt; {&#10;        if (!this.appliedRulesField) {&#10;            throw new Error('appliedRulesField is not configured. Use setAppliedRulesField() first.');&#10;        }&#10;&#10;        let query = this.db.selectFrom(targetTable).selectAll();&#10;&#10;        // Add WHERE conditions if provided&#10;        if (whereConditions) {&#10;            const matchEntries = Object.entries(whereConditions);&#10;            for (const [key, value] of matchEntries) {&#10;                query = query.where(key, '=', value);&#10;            }&#10;        }&#10;&#10;        const rows = await query.execute();&#10;&#10;        // Parse the applied rules JSON array for each row&#10;        return rows.map(row =&gt; {&#10;            const appliedRulesValue = (row as any)[this.appliedRulesField!];&#10;            return {&#10;                ...row,&#10;                appliedRules: this.normalizeAppliedRules(appliedRulesValue),&#10;            } as T &amp; { appliedRules?: string[] };&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/index.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/index.ts" />
              <option name="updatedContent" value="import { Kysely } from 'kysely';&#10;import { MatchRule } from './MatchRule';&#10;&#10;// ...existing code...&#10;&#10;/**&#10; * PostgreSQL based rule engine that applies match rules to database tables&#10; */&#10;export class PgRulesEngine {&#10;  constructor(private db: Kysely&lt;any&gt;) {}&#10;&#10;  /**&#10;   * Apply multiple rules to a target table in a single transaction&#10;   * @param rules Array of MatchRule objects to apply&#10;   * @param targetTable Name of the table to apply rules to&#10;   * @returns Promise that resolves to the total number of affected rows&#10;   */&#10;  async applyRules&lt;T&gt;(rules: MatchRule&lt;T&gt;[], targetTable: string): Promise&lt;number&gt; {&#10;    if (!rules.length) {&#10;      return 0;&#10;    }&#10;&#10;    return await this.db.transaction().execute(async (trx) =&gt; {&#10;      let totalAffectedRows = 0;&#10;&#10;      for (const rule of rules) {&#10;        // Build the update query&#10;        let query = trx.updateTable(targetTable);&#10;&#10;        // Add SET clause from apply object&#10;        const applyEntries = Object.entries(rule.apply);&#10;        if (applyEntries.length === 0) {&#10;          continue; // Skip rules with no apply changes&#10;        }&#10;&#10;        query = query.set(rule.apply);&#10;&#10;        // Add WHERE clause from match object&#10;        const matchEntries = Object.entries(rule.match);&#10;        for (const [key, value] of matchEntries) {&#10;          query = query.where(key, '=', value);&#10;        }&#10;&#10;        // Execute the query and get affected row count&#10;        const result = await query.execute();&#10;        // For Kysely UpdateResult, we access the number of affected rows differently&#10;        totalAffectedRows += Number((result as any).numAffectedRows || 0);&#10;      }&#10;&#10;      return totalAffectedRows;&#10;    });&#10;  }&#10;}&#10;&#10;export function greet(name: string): string {&#10;  return `Hello, ${name}!`;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tsconfig.json">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tsconfig.json" />
              <option name="updatedContent" value="{&#10;  &quot;compilerOptions&quot;: {&#10;    &quot;target&quot;: &quot;ES2020&quot;,&#10;    &quot;module&quot;: &quot;commonjs&quot;,&#10;    &quot;lib&quot;: [&quot;ES2020&quot;],&#10;    &quot;outDir&quot;: &quot;./dist&quot;,&#10;    &quot;rootDir&quot;: &quot;./src&quot;,&#10;    &quot;strict&quot;: true,&#10;    &quot;esModuleInterop&quot;: true,&#10;    &quot;skipLibCheck&quot;: true,&#10;    &quot;forceConsistentCasingInFileNames&quot;: true,&#10;    &quot;declaration&quot;: true,&#10;    &quot;declarationMap&quot;: true,&#10;    &quot;sourceMap&quot;: true,&#10;    &quot;removeComments&quot;: true,&#10;    &quot;noImplicitAny&quot;: true,&#10;    &quot;strictNullChecks&quot;: true,&#10;    &quot;strictFunctionTypes&quot;: true,&#10;    &quot;noImplicitThis&quot;: true,&#10;    &quot;noImplicitReturns&quot;: true,&#10;    &quot;noFallthroughCasesInSwitch&quot;: true,&#10;    &quot;moduleResolution&quot;: &quot;node&quot;,&#10;    &quot;baseUrl&quot;: &quot;./&quot;,&#10;    &quot;paths&quot;: {&#10;      &quot;@/*&quot;: [&quot;src/*&quot;]&#10;    }&#10;  },&#10;  &quot;include&quot;: [&#10;    &quot;src/**/*&quot;&#10;  ],&#10;  &quot;exclude&quot;: [&#10;    &quot;node_modules&quot;,&#10;    &quot;dist&quot;,&#10;    &quot;**/*.test.ts&quot;,&#10;    &quot;**/*.spec.ts&quot;&#10;  ]&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>