<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/MatchRule.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/MatchRule.ts" />
              <option name="originalContent" value="/**&#10; * Represents a match rule that can be applied to database records&#10; */&#10;export interface MatchRule&lt;T = any&gt; {&#10;&#10;    /**&#10;     * Optional priority of the rule.&#10;     * Rules with lower priority numbers will be applied first.&#10;     * If not specified, the default priority is 0.&#10;     */&#10;    readonly priority?: number;&#10;&#10;    /**&#10;     * Name of the rule, used for identification and logging.&#10;     * Rule name can be added to &quot;appliedRules&quot; field in the database to track which rules were applied.&#10;     */&#10;    readonly ruleName: string;&#10;&#10;    /**&#10;     * Conditions to match records against.&#10;     * Values will be matched as regex patterns if they are strings&#10;     * and direct equality for other types.&#10;     * For example, { &quot;category&quot;: &quot;Groceries|Food&quot; } will match records where category is either &quot;Groceries&quot; or &quot;Food&quot;.&#10;     */&#10;    readonly match: Partial&lt;T&gt;;&#10;&#10;    /**&#10;     * Changes to apply to matched records.&#10;     * This object will be used in the SET clause of the SQL UPDATE statement.&#10;     */&#10;    readonly apply: Partial&lt;T&gt;;&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Represents a match rule that can be applied to database records&#10; */&#10;export interface MatchRule&lt;T = any&gt; {&#10;&#10;    /**&#10;     * Priority of the rule.&#10;     * Rules with lower priority numbers will be applied first.&#10;     * If not specified, the default priority is 0.&#10;     */&#10;    readonly priority: number;&#10;&#10;    /**&#10;     * Name of the rule, used for identification and logging.&#10;     * Rule name can be added to &quot;appliedRules&quot; field in the database to track which rules were applied.&#10;     */&#10;    readonly ruleName: string;&#10;&#10;    /**&#10;     * Conditions to match records against.&#10;     * Values will be matched as regex patterns if they are strings&#10;     * and direct equality for other types.&#10;     * For example, { &quot;category&quot;: &quot;Groceries|Food&quot; } will match records where category is either &quot;Groceries&quot; or &quot;Food&quot;.&#10;     */&#10;    readonly match: Partial&lt;T&gt;;&#10;&#10;    /**&#10;     * Changes to apply to matched records.&#10;     * This object will be used in the SET clause of the SQL UPDATE statement.&#10;     */&#10;    readonly apply: Partial&lt;T&gt;;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/index.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/index.ts" />
              <option name="updatedContent" value="import { Kysely } from 'kysely';&#10;import { MatchRule } from './MatchRule';&#10;&#10;// ...existing code...&#10;&#10;/**&#10; * PostgreSQL based rule engine that applies match rules to database tables&#10; */&#10;export class PgRulesEngine {&#10;  constructor(private db: Kysely&lt;any&gt;) {}&#10;&#10;  /**&#10;   * Apply multiple rules to a target table in a single transaction&#10;   * @param rules Array of MatchRule objects to apply&#10;   * @param targetTable Name of the table to apply rules to&#10;   * @returns Promise that resolves to the total number of affected rows&#10;   */&#10;  async applyRules&lt;T&gt;(rules: MatchRule&lt;T&gt;[], targetTable: string): Promise&lt;number&gt; {&#10;    if (!rules.length) {&#10;      return 0;&#10;    }&#10;&#10;    return await this.db.transaction().execute(async (trx) =&gt; {&#10;      let totalAffectedRows = 0;&#10;&#10;      for (const rule of rules) {&#10;        // Build the update query&#10;        let query = trx.updateTable(targetTable);&#10;&#10;        // Add SET clause from apply object&#10;        const applyEntries = Object.entries(rule.apply);&#10;        if (applyEntries.length === 0) {&#10;          continue; // Skip rules with no apply changes&#10;        }&#10;&#10;        query = query.set(rule.apply);&#10;&#10;        // Add WHERE clause from match object&#10;        const matchEntries = Object.entries(rule.match);&#10;        for (const [key, value] of matchEntries) {&#10;          query = query.where(key, '=', value);&#10;        }&#10;&#10;        // Execute the query and get affected row count&#10;        const result = await query.execute();&#10;        // For Kysely UpdateResult, we access the number of affected rows differently&#10;        totalAffectedRows += Number((result as any).numAffectedRows || 0);&#10;      }&#10;&#10;      return totalAffectedRows;&#10;    });&#10;  }&#10;}&#10;&#10;export function greet(name: string): string {&#10;  return `Hello, ${name}!`;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>